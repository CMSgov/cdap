require('./sourcemap-register.js');/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 4550:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValues = void 0;
const client_ssm_1 = __nccwpck_require__(341);
const core_1 = __nccwpck_require__(2186);
const getValues = (paramsObj) => __awaiter(void 0, void 0, void 0, function* () {
    const client = new client_ssm_1.SSMClient({});
    const input = {
        Names: Object.keys(paramsObj),
        WithDecryption: true
    };
    const command = new client_ssm_1.GetParametersCommand(input);
    const response = yield client.send(command);
    const invalid = response.InvalidParameters;
    if (invalid && invalid.length > 0) {
        (0, core_1.setFailed)(`Invalid parameters: ${invalid}`);
    }
    const params = response.Parameters;
    const values = [];
    if (!params)
        return values;
    for (const param of params) {
        if (!param.Name || !param.Value)
            continue; // Convince typescript these are defined
        values.push({
            name: paramsObj[param.Name],
            value: param.Value,
            secret: param.Type === 'SecureString'
        });
    }
    return values;
});
exports.getValues = getValues;


/***/ }),

/***/ 3109:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const core = __importStar(__nccwpck_require__(2186));
const parse_params_1 = __nccwpck_require__(4775);
const get_values_1 = __nccwpck_require__(4550);
const set_env_1 = __nccwpck_require__(1014);
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const params = core.getInput('params');
            const parsed = (0, parse_params_1.parseParams)(params);
            core.debug(`Getting values for these params:\n${parsed}`);
            core.debug(new Date().toTimeString());
            const values = yield (0, get_values_1.getValues)(parsed);
            core.debug(new Date().toTimeString());
            core.debug(`Values retrieved from AWS. Setting env...`);
            (0, set_env_1.setEnv)(values);
        }
        catch (error) {
            if (error instanceof Error)
                core.setFailed(error.message);
        }
    });
}
run();


/***/ }),

/***/ 4775:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseParams = void 0;
const core_1 = __nccwpck_require__(2186);
const parseParams = (params) => {
    return params.split(/\s+/).reduce((obj, param) => {
        if (!param)
            return obj;
        const splitParam = param.split('=');
        if (!splitParam[0] || !splitParam[1]) {
            (0, core_1.setFailed)(`Parameter "${param}" is not of the form "ENV_VAR=/aws/param"`);
        }
        obj[splitParam[1]] = splitParam[0];
        return obj;
    }, {});
};
exports.parseParams = parseParams;


/***/ }),

/***/ 1014:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setEnv = void 0;
const core_1 = __nccwpck_require__(2186);
const setEnv = (params) => {
    for (const param of params) {
        if (param.secret) {
            (0, core_1.setSecret)(param.value);
        }
        (0, core_1.exportVariable)(param.name, param.value);
    }
};
exports.setEnv = setEnv;


/***/ }),

/***/ 7351:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.issue = exports.issueCommand = void 0;
const os = __importStar(__nccwpck_require__(2037));
const utils_1 = __nccwpck_require__(5278);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 2186:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
const command_1 = __nccwpck_require__(7351);
const file_command_1 = __nccwpck_require__(717);
const utils_1 = __nccwpck_require__(5278);
const os = __importStar(__nccwpck_require__(2037));
const path = __importStar(__nccwpck_require__(1017));
const oidc_utils_1 = __nccwpck_require__(8041);
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));
    }
    command_1.issueCommand('set-env', { name }, convertedVal);
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueFileCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.
 * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.
 * Returns an empty string if the value is not defined.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    if (options && options.trimWhitespace === false) {
        return val;
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Gets the values of an multiline input.  Each value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string[]
 *
 */
function getMultilineInput(name, options) {
    const inputs = getInput(name, options)
        .split('\n')
        .filter(x => x !== '');
    if (options && options.trimWhitespace === false) {
        return inputs;
    }
    return inputs.map(input => input.trim());
}
exports.getMultilineInput = getMultilineInput;
/**
 * Gets the input value of the boolean type in the YAML 1.2 "core schema" specification.
 * Support boolean input list: `true | True | TRUE | false | False | FALSE` .
 * The return value is also in boolean type.
 * ref: https://yaml.org/spec/1.2/spec.html#id2804923
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   boolean
 */
function getBooleanInput(name, options) {
    const trueValue = ['true', 'True', 'TRUE'];
    const falseValue = ['false', 'False', 'FALSE'];
    const val = getInput(name, options);
    if (trueValue.includes(val))
        return true;
    if (falseValue.includes(val))
        return false;
    throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}\n` +
        `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
}
exports.getBooleanInput = getBooleanInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    const filePath = process.env['GITHUB_OUTPUT'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));
    }
    process.stdout.write(os.EOL);
    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function error(message, properties = {}) {
    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds a warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function warning(message, properties = {}) {
    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Adds a notice issue
 * @param message notice issue message. Errors will be converted to string via toString()
 * @param properties optional properties to add to the annotation.
 */
function notice(message, properties = {}) {
    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);
}
exports.notice = notice;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    const filePath = process.env['GITHUB_STATE'] || '';
    if (filePath) {
        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));
    }
    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
function getIDToken(aud) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
    });
}
exports.getIDToken = getIDToken;
/**
 * Summary exports
 */
var summary_1 = __nccwpck_require__(1327);
Object.defineProperty(exports, "summary", ({ enumerable: true, get: function () { return summary_1.summary; } }));
/**
 * @deprecated use core.summary
 */
var summary_2 = __nccwpck_require__(1327);
Object.defineProperty(exports, "markdownSummary", ({ enumerable: true, get: function () { return summary_2.markdownSummary; } }));
/**
 * Path exports
 */
var path_utils_1 = __nccwpck_require__(2981);
Object.defineProperty(exports, "toPosixPath", ({ enumerable: true, get: function () { return path_utils_1.toPosixPath; } }));
Object.defineProperty(exports, "toWin32Path", ({ enumerable: true, get: function () { return path_utils_1.toWin32Path; } }));
Object.defineProperty(exports, "toPlatformPath", ({ enumerable: true, get: function () { return path_utils_1.toPlatformPath; } }));
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 717:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

// For internal use, subject to change.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__nccwpck_require__(7147));
const os = __importStar(__nccwpck_require__(2037));
const uuid_1 = __nccwpck_require__(5840);
const utils_1 = __nccwpck_require__(5278);
function issueFileCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueFileCommand = issueFileCommand;
function prepareKeyValueMessage(key, value) {
    const delimiter = `ghadelimiter_${uuid_1.v4()}`;
    const convertedValue = utils_1.toCommandValue(value);
    // These should realistically never happen, but just in case someone finds a
    // way to exploit uuid generation let's not allow keys or values that contain
    // the delimiter.
    if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
    }
    if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
    }
    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
}
exports.prepareKeyValueMessage = prepareKeyValueMessage;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 8041:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OidcClient = void 0;
const http_client_1 = __nccwpck_require__(6255);
const auth_1 = __nccwpck_require__(5526);
const core_1 = __nccwpck_require__(2186);
class OidcClient {
    static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
            allowRetries: allowRetry,
            maxRetries: maxRetry
        };
        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);
    }
    static getRequestToken() {
        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];
        if (!token) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');
        }
        return token;
    }
    static getIDTokenUrl() {
        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];
        if (!runtimeUrl) {
            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');
        }
        return runtimeUrl;
    }
    static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const httpclient = OidcClient.createHttpClient();
            const res = yield httpclient
                .getJson(id_token_url)
                .catch(error => {
                throw new Error(`Failed to get ID Token. \n 
        Error Code : ${error.statusCode}\n 
        Error Message: ${error.result.message}`);
            });
            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
            if (!id_token) {
                throw new Error('Response json body do not have ID Token field');
            }
            return id_token;
        });
    }
    static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // New ID Token is requested from action service
                let id_token_url = OidcClient.getIDTokenUrl();
                if (audience) {
                    const encodedAudience = encodeURIComponent(audience);
                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;
                }
                core_1.debug(`ID token url is ${id_token_url}`);
                const id_token = yield OidcClient.getCall(id_token_url);
                core_1.setSecret(id_token);
                return id_token;
            }
            catch (error) {
                throw new Error(`Error message: ${error.message}`);
            }
        });
    }
}
exports.OidcClient = OidcClient;
//# sourceMappingURL=oidc-utils.js.map

/***/ }),

/***/ 2981:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
const path = __importStar(__nccwpck_require__(1017));
/**
 * toPosixPath converts the given path to the posix form. On Windows, \\ will be
 * replaced with /.
 *
 * @param pth. Path to transform.
 * @return string Posix path.
 */
function toPosixPath(pth) {
    return pth.replace(/[\\]/g, '/');
}
exports.toPosixPath = toPosixPath;
/**
 * toWin32Path converts the given path to the win32 form. On Linux, / will be
 * replaced with \\.
 *
 * @param pth. Path to transform.
 * @return string Win32 path.
 */
function toWin32Path(pth) {
    return pth.replace(/[/]/g, '\\');
}
exports.toWin32Path = toWin32Path;
/**
 * toPlatformPath converts the given path to a platform-specific path. It does
 * this by replacing instances of / and \ with the platform-specific path
 * separator.
 *
 * @param pth The path to platformize.
 * @return string The platform-specific path.
 */
function toPlatformPath(pth) {
    return pth.replace(/[/\\]/g, path.sep);
}
exports.toPlatformPath = toPlatformPath;
//# sourceMappingURL=path-utils.js.map

/***/ }),

/***/ 1327:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
const os_1 = __nccwpck_require__(2037);
const fs_1 = __nccwpck_require__(7147);
const { access, appendFile, writeFile } = fs_1.promises;
exports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';
exports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';
class Summary {
    constructor() {
        this._buffer = '';
    }
    /**
     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
     * Also checks r/w permissions.
     *
     * @returns step summary file path
     */
    filePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._filePath) {
                return this._filePath;
            }
            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
            if (!pathFromEnv) {
                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
            }
            try {
                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
            }
            catch (_a) {
                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
            }
            this._filePath = pathFromEnv;
            return this._filePath;
        });
    }
    /**
     * Wraps content in an HTML tag, adding any HTML attributes
     *
     * @param {string} tag HTML tag to wrap
     * @param {string | null} content content within the tag
     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
     *
     * @returns {string} content wrapped in HTML element
     */
    wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs)
            .map(([key, value]) => ` ${key}="${value}"`)
            .join('');
        if (!content) {
            return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
    }
    /**
     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
     *
     * @param {SummaryWriteOptions} [options] (optional) options for write operation
     *
     * @returns {Promise<Summary>} summary instance
     */
    write(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
            const filePath = yield this.filePath();
            const writeFunc = overwrite ? writeFile : appendFile;
            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });
            return this.emptyBuffer();
        });
    }
    /**
     * Clears the summary buffer and wipes the summary file
     *
     * @returns {Summary} summary instance
     */
    clear() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.emptyBuffer().write({ overwrite: true });
        });
    }
    /**
     * Returns the current summary buffer as a string
     *
     * @returns {string} string of summary buffer
     */
    stringify() {
        return this._buffer;
    }
    /**
     * If the summary buffer is empty
     *
     * @returns {boolen} true if the buffer is empty
     */
    isEmptyBuffer() {
        return this._buffer.length === 0;
    }
    /**
     * Resets the summary buffer without writing to summary file
     *
     * @returns {Summary} summary instance
     */
    emptyBuffer() {
        this._buffer = '';
        return this;
    }
    /**
     * Adds raw text to the summary buffer
     *
     * @param {string} text content to add
     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
     *
     * @returns {Summary} summary instance
     */
    addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
    }
    /**
     * Adds the operating system-specific end-of-line marker to the buffer
     *
     * @returns {Summary} summary instance
     */
    addEOL() {
        return this.addRaw(os_1.EOL);
    }
    /**
     * Adds an HTML codeblock to the summary buffer
     *
     * @param {string} code content to render within fenced code block
     * @param {string} lang (optional) language to syntax highlight code
     *
     * @returns {Summary} summary instance
     */
    addCodeBlock(code, lang) {
        const attrs = Object.assign({}, (lang && { lang }));
        const element = this.wrap('pre', this.wrap('code', code), attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML list to the summary buffer
     *
     * @param {string[]} items list of items to render
     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
     *
     * @returns {Summary} summary instance
     */
    addList(items, ordered = false) {
        const tag = ordered ? 'ol' : 'ul';
        const listItems = items.map(item => this.wrap('li', item)).join('');
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML table to the summary buffer
     *
     * @param {SummaryTableCell[]} rows table rows
     *
     * @returns {Summary} summary instance
     */
    addTable(rows) {
        const tableBody = rows
            .map(row => {
            const cells = row
                .map(cell => {
                if (typeof cell === 'string') {
                    return this.wrap('td', cell);
                }
                const { header, data, colspan, rowspan } = cell;
                const tag = header ? 'th' : 'td';
                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));
                return this.wrap(tag, data, attrs);
            })
                .join('');
            return this.wrap('tr', cells);
        })
            .join('');
        const element = this.wrap('table', tableBody);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds a collapsable HTML details element to the summary buffer
     *
     * @param {string} label text for the closed state
     * @param {string} content collapsable content
     *
     * @returns {Summary} summary instance
     */
    addDetails(label, content) {
        const element = this.wrap('details', this.wrap('summary', label) + content);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML image tag to the summary buffer
     *
     * @param {string} src path to the image you to embed
     * @param {string} alt text description of the image
     * @param {SummaryImageOptions} options (optional) addition image attributes
     *
     * @returns {Summary} summary instance
     */
    addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));
        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML section heading element
     *
     * @param {string} text heading text
     * @param {number | string} [level=1] (optional) the heading level, default: 1
     *
     * @returns {Summary} summary instance
     */
    addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)
            ? tag
            : 'h1';
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML thematic break (<hr>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addSeparator() {
        const element = this.wrap('hr', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML line break (<br>) to the summary buffer
     *
     * @returns {Summary} summary instance
     */
    addBreak() {
        const element = this.wrap('br', null);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML blockquote to the summary buffer
     *
     * @param {string} text quote text
     * @param {string} cite (optional) citation url
     *
     * @returns {Summary} summary instance
     */
    addQuote(text, cite) {
        const attrs = Object.assign({}, (cite && { cite }));
        const element = this.wrap('blockquote', text, attrs);
        return this.addRaw(element).addEOL();
    }
    /**
     * Adds an HTML anchor tag to the summary buffer
     *
     * @param {string} text link text/content
     * @param {string} href hyperlink
     *
     * @returns {Summary} summary instance
     */
    addLink(text, href) {
        const element = this.wrap('a', text, { href });
        return this.addRaw(element).addEOL();
    }
}
const _summary = new Summary();
/**
 * @deprecated use `core.summary`
 */
exports.markdownSummary = _summary;
exports.summary = _summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ 5278:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toCommandProperties = exports.toCommandValue = void 0;
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
/**
 *
 * @param annotationProperties
 * @returns The command properties to send with the actual annotation command
 * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646
 */
function toCommandProperties(annotationProperties) {
    if (!Object.keys(annotationProperties).length) {
        return {};
    }
    return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
    };
}
exports.toCommandProperties = toCommandProperties;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 5526:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
class BasicCredentialHandler {
    constructor(username, password) {
        this.username = username;
        this.password = password;
    }
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BasicCredentialHandler = BasicCredentialHandler;
class BearerCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Bearer ${this.token}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.BearerCredentialHandler = BearerCredentialHandler;
class PersonalAccessTokenCredentialHandler {
    constructor(token) {
        this.token = token;
    }
    // currently implements pre-authorization
    // TODO: support preAuth = false where it hooks on 401
    prepareRequest(options) {
        if (!options.headers) {
            throw Error('The request has no headers');
        }
        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;
    }
    // This handler cannot handle 401
    canHandleAuthentication() {
        return false;
    }
    handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('not implemented');
        });
    }
}
exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
//# sourceMappingURL=auth.js.map

/***/ }),

/***/ 6255:
/***/ (function(__unused_webpack_module, exports, __nccwpck_require__) {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
const http = __importStar(__nccwpck_require__(3685));
const https = __importStar(__nccwpck_require__(5687));
const pm = __importStar(__nccwpck_require__(9835));
const tunnel = __importStar(__nccwpck_require__(4294));
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                let output = Buffer.alloc(0);
                this.message.on('data', (chunk) => {
                    output = Buffer.concat([output, chunk]);
                });
                this.message.on('end', () => {
                    resolve(output.toString());
                });
            }));
        });
    }
    readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const chunks = [];
                this.message.on('data', (chunk) => {
                    chunks.push(chunk);
                });
                this.message.on('end', () => {
                    resolve(Buffer.concat(chunks));
                });
            }));
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    const parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
        });
    }
    get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('GET', requestUrl, null, additionalHeaders || {});
        });
    }
    del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('DELETE', requestUrl, null, additionalHeaders || {});
        });
    }
    post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('POST', requestUrl, data, additionalHeaders || {});
        });
    }
    patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PATCH', requestUrl, data, additionalHeaders || {});
        });
    }
    put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('PUT', requestUrl, data, additionalHeaders || {});
        });
    }
    head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request('HEAD', requestUrl, null, additionalHeaders || {});
        });
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.request(verb, requestUrl, stream, additionalHeaders);
        });
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            const res = yield this.get(requestUrl, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.post(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.put(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = JSON.stringify(obj, null, 2);
            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
            const res = yield this.patch(requestUrl, data, additionalHeaders);
            return this._processResponse(res, this.requestOptions);
        });
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._disposed) {
                throw new Error('Client has already been disposed.');
            }
            const parsedUrl = new URL(requestUrl);
            let info = this._prepareRequest(verb, parsedUrl, headers);
            // Only perform retries on reads since writes may not be idempotent.
            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)
                ? this._maxRetries + 1
                : 1;
            let numTries = 0;
            let response;
            do {
                response = yield this.requestRaw(info, data);
                // Check if it's an authentication challenge
                if (response &&
                    response.message &&
                    response.message.statusCode === HttpCodes.Unauthorized) {
                    let authenticationHandler;
                    for (const handler of this.handlers) {
                        if (handler.canHandleAuthentication(response)) {
                            authenticationHandler = handler;
                            break;
                        }
                    }
                    if (authenticationHandler) {
                        return authenticationHandler.handleAuthentication(this, info, data);
                    }
                    else {
                        // We have received an unauthorized response but have no handlers to handle it.
                        // Let the response return to the caller.
                        return response;
                    }
                }
                let redirectsRemaining = this._maxRedirects;
                while (response.message.statusCode &&
                    HttpRedirectCodes.includes(response.message.statusCode) &&
                    this._allowRedirects &&
                    redirectsRemaining > 0) {
                    const redirectUrl = response.message.headers['location'];
                    if (!redirectUrl) {
                        // if there's no location to redirect to, we won't
                        break;
                    }
                    const parsedRedirectUrl = new URL(redirectUrl);
                    if (parsedUrl.protocol === 'https:' &&
                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&
                        !this._allowRedirectDowngrade) {
                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                    }
                    // we need to finish reading the response before reassigning response
                    // which will leak the open socket.
                    yield response.readBody();
                    // strip authorization header if redirected to a different hostname
                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                        for (const header in headers) {
                            // header names are case insensitive
                            if (header.toLowerCase() === 'authorization') {
                                delete headers[header];
                            }
                        }
                    }
                    // let's make the request with the new redirectUrl
                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                    response = yield this.requestRaw(info, data);
                    redirectsRemaining--;
                }
                if (!response.message.statusCode ||
                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {
                    // If not a retry code, return immediately instead of retrying
                    return response;
                }
                numTries += 1;
                if (numTries < maxTries) {
                    yield response.readBody();
                    yield this._performExponentialBackoff(numTries);
                }
            } while (numTries < maxTries);
            return response;
        });
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                function callbackForResult(err, res) {
                    if (err) {
                        reject(err);
                    }
                    else if (!res) {
                        // If `err` is not passed, then `res` must be passed.
                        reject(new Error('Unknown error'));
                    }
                    else {
                        resolve(res);
                    }
                }
                this.requestRawWithCallback(info, data, callbackForResult);
            });
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        if (typeof data === 'string') {
            if (!info.options.headers) {
                info.options.headers = {};
            }
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        function handleResult(err, res) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        }
        const req = info.httpModule.request(info.options, (msg) => {
            const res = new HttpClientResponse(msg);
            handleResult(undefined, res);
        });
        let socket;
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            for (const handler of this.handlers) {
                handler.prepareRequest(info.options);
            }
        }
        return info;
    }
    _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.
        if (proxyUrl && proxyUrl.hostname) {
            const agentOptions = {
                maxSockets,
                keepAlive: this._keepAlive,
                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
                })), { host: proxyUrl.hostname, port: proxyUrl.port })
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
            return new Promise(resolve => setTimeout(() => resolve(), ms));
        });
    }
    _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                const statusCode = res.message.statusCode || 0;
                const response = {
                    statusCode,
                    result: null,
                    headers: {}
                };
                // not found leads to null obj returned
                if (statusCode === HttpCodes.NotFound) {
                    resolve(response);
                }
                // get the result from the body
                function dateTimeDeserializer(key, value) {
                    if (typeof value === 'string') {
                        const a = new Date(value);
                        if (!isNaN(a.valueOf())) {
                            return a;
                        }
                    }
                    return value;
                }
                let obj;
                let contents;
                try {
                    contents = yield res.readBody();
                    if (contents && contents.length > 0) {
                        if (options && options.deserializeDates) {
                            obj = JSON.parse(contents, dateTimeDeserializer);
                        }
                        else {
                            obj = JSON.parse(contents);
                        }
                        response.result = obj;
                    }
                    response.headers = res.message.headers;
                }
                catch (err) {
                    // Invalid resource (contents not json);  leaving result obj null
                }
                // note that 3xx redirects are handled by the http layer.
                if (statusCode > 299) {
                    let msg;
                    // if exception/error in body, attempt to get better error
                    if (obj && obj.message) {
                        msg = obj.message;
                    }
                    else if (contents && contents.length > 0) {
                        // it may be the case that the exception is in the body message as string
                        msg = contents;
                    }
                    else {
                        msg = `Failed request: (${statusCode})`;
                    }
                    const err = new HttpClientError(msg, statusCode);
                    err.result = response.result;
                    reject(err);
                }
                else {
                    resolve(response);
                }
            }));
        });
    }
}
exports.HttpClient = HttpClient;
const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9835:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkBypass = exports.getProxyUrl = void 0;
function getProxyUrl(reqUrl) {
    const usingSsl = reqUrl.protocol === 'https:';
    if (checkBypass(reqUrl)) {
        return undefined;
    }
    const proxyVar = (() => {
        if (usingSsl) {
            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];
        }
        else {
            return process.env['http_proxy'] || process.env['HTTP_PROXY'];
        }
    })();
    if (proxyVar) {
        try {
            return new URL(proxyVar);
        }
        catch (_a) {
            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))
                return new URL(`http://${proxyVar}`);
        }
    }
    else {
        return undefined;
    }
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    const reqHost = reqUrl.hostname;
    if (isLoopbackAddress(reqHost)) {
        return true;
    }
    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    const upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (const upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperNoProxyItem === '*' ||
            upperReqHosts.some(x => x === upperNoProxyItem ||
                x.endsWith(`.${upperNoProxyItem}`) ||
                (upperNoProxyItem.startsWith('.') &&
                    x.endsWith(`${upperNoProxyItem}`)))) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;
function isLoopbackAddress(host) {
    const hostLower = host.toLowerCase();
    return (hostLower === 'localhost' ||
        hostLower.startsWith('127.') ||
        hostLower.startsWith('[::1]') ||
        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));
}
//# sourceMappingURL=proxy.js.map

/***/ }),

/***/ 3791:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveHttpAuthSchemeConfig = exports.defaultSSMHttpAuthSchemeProvider = exports.defaultSSMHttpAuthSchemeParametersProvider = void 0;
const core_1 = __nccwpck_require__(9963);
const util_middleware_1 = __nccwpck_require__(2390);
const defaultSSMHttpAuthSchemeParametersProvider = async (config, context, input) => {
    return {
        operation: (0, util_middleware_1.getSmithyContext)(context).operation,
        region: await (0, util_middleware_1.normalizeProvider)(config.region)() || (() => {
            throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
        })(),
    };
};
exports.defaultSSMHttpAuthSchemeParametersProvider = defaultSSMHttpAuthSchemeParametersProvider;
function createAwsAuthSigv4HttpAuthOption(authParameters) {
    return {
        schemeId: "aws.auth#sigv4",
        signingProperties: {
            name: "ssm",
            region: authParameters.region,
        },
        propertiesExtractor: (config, context) => ({
            signingProperties: {
                config,
                context,
            },
        }),
    };
}
const defaultSSMHttpAuthSchemeProvider = (authParameters) => {
    const options = [];
    switch (authParameters.operation) {
        default: {
            options.push(createAwsAuthSigv4HttpAuthOption(authParameters));
        }
    }
    return options;
};
exports.defaultSSMHttpAuthSchemeProvider = defaultSSMHttpAuthSchemeProvider;
const resolveHttpAuthSchemeConfig = (config) => {
    const config_0 = (0, core_1.resolveAwsSdkSigV4Config)(config);
    return Object.assign(config_0, {
        authSchemePreference: (0, util_middleware_1.normalizeProvider)(config.authSchemePreference ?? []),
    });
};
exports.resolveHttpAuthSchemeConfig = resolveHttpAuthSchemeConfig;


/***/ }),

/***/ 4521:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __nccwpck_require__(3350);
const util_endpoints_2 = __nccwpck_require__(5473);
const ruleset_1 = __nccwpck_require__(3411);
const cache = new util_endpoints_2.EndpointCache({
    size: 50,
    params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"],
});
const defaultEndpointResolver = (endpointParams, context = {}) => {
    return cache.get(endpointParams, () => (0, util_endpoints_2.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger,
    }));
};
exports.defaultEndpointResolver = defaultEndpointResolver;
util_endpoints_2.customEndpointFunctions.aws = util_endpoints_1.awsEndpointFunctions;


/***/ }),

/***/ 3411:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ruleSet = void 0;
const u = "required", v = "fn", w = "argv", x = "ref";
const a = true, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f = "tree", g = "PartitionResult", h = "getAttr", i = { [u]: false, "type": "string" }, j = { [u]: true, "default": false, "type": "boolean" }, k = { [x]: "Endpoint" }, l = { [v]: c, [w]: [{ [x]: "UseFIPS" }, true] }, m = { [v]: c, [w]: [{ [x]: "UseDualStack" }, true] }, n = {}, o = { [v]: h, [w]: [{ [x]: g }, "supportsFIPS"] }, p = { [x]: g }, q = { [v]: c, [w]: [true, { [v]: h, [w]: [p, "supportsDualStack"] }] }, r = [l], s = [m], t = [{ [x]: "Region" }];
const _data = { version: "1.0", parameters: { Region: i, UseDualStack: j, UseFIPS: j, Endpoint: i }, rules: [{ conditions: [{ [v]: b, [w]: [k] }], rules: [{ conditions: r, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: s, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: k, properties: n, headers: n }, type: e }], type: f }, { conditions: [{ [v]: b, [w]: t }], rules: [{ conditions: [{ [v]: "aws.partition", [w]: t, assign: g }], rules: [{ conditions: [l, m], rules: [{ conditions: [{ [v]: c, [w]: [a, o] }, q], rules: [{ endpoint: { url: "https://ssm-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f }, { conditions: r, rules: [{ conditions: [{ [v]: c, [w]: [o, a] }], rules: [{ conditions: [{ [v]: "stringEquals", [w]: [{ [v]: h, [w]: [p, "name"] }, "aws-us-gov"] }], endpoint: { url: "https://ssm.{Region}.amazonaws.com", properties: n, headers: n }, type: e }, { endpoint: { url: "https://ssm-fips.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f }, { conditions: s, rules: [{ conditions: [q], rules: [{ endpoint: { url: "https://ssm.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: n, headers: n }, type: e }], type: f }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f }, { endpoint: { url: "https://ssm.{Region}.{PartitionResult#dnsSuffix}", properties: n, headers: n }, type: e }], type: f }], type: f }, { error: "Invalid Configuration: Missing Region", type: d }] };
exports.ruleSet = _data;


/***/ }),

/***/ 341:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var middlewareHostHeader = __nccwpck_require__(2545);
var middlewareLogger = __nccwpck_require__(14);
var middlewareRecursionDetection = __nccwpck_require__(5525);
var middlewareUserAgent = __nccwpck_require__(4688);
var configResolver = __nccwpck_require__(3098);
var core = __nccwpck_require__(5829);
var schema = __nccwpck_require__(9826);
var middlewareContentLength = __nccwpck_require__(2800);
var middlewareEndpoint = __nccwpck_require__(2918);
var middlewareRetry = __nccwpck_require__(6039);
var smithyClient = __nccwpck_require__(3570);
var httpAuthSchemeProvider = __nccwpck_require__(3791);
var runtimeConfig = __nccwpck_require__(8509);
var regionConfigResolver = __nccwpck_require__(8156);
var protocolHttp = __nccwpck_require__(4418);
var utilWaiter = __nccwpck_require__(8011);

const resolveClientEndpointParameters = (options) => {
    return Object.assign(options, {
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "ssm",
    });
};
const commonParams = {
    UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
    Endpoint: { type: "builtInParams", name: "endpoint" },
    Region: { type: "builtInParams", name: "region" },
    UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" },
};

const getHttpAuthExtensionConfiguration = (runtimeConfig) => {
    const _httpAuthSchemes = runtimeConfig.httpAuthSchemes;
    let _httpAuthSchemeProvider = runtimeConfig.httpAuthSchemeProvider;
    let _credentials = runtimeConfig.credentials;
    return {
        setHttpAuthScheme(httpAuthScheme) {
            const index = _httpAuthSchemes.findIndex((scheme) => scheme.schemeId === httpAuthScheme.schemeId);
            if (index === -1) {
                _httpAuthSchemes.push(httpAuthScheme);
            }
            else {
                _httpAuthSchemes.splice(index, 1, httpAuthScheme);
            }
        },
        httpAuthSchemes() {
            return _httpAuthSchemes;
        },
        setHttpAuthSchemeProvider(httpAuthSchemeProvider) {
            _httpAuthSchemeProvider = httpAuthSchemeProvider;
        },
        httpAuthSchemeProvider() {
            return _httpAuthSchemeProvider;
        },
        setCredentials(credentials) {
            _credentials = credentials;
        },
        credentials() {
            return _credentials;
        },
    };
};
const resolveHttpAuthRuntimeConfig = (config) => {
    return {
        httpAuthSchemes: config.httpAuthSchemes(),
        httpAuthSchemeProvider: config.httpAuthSchemeProvider(),
        credentials: config.credentials(),
    };
};

const resolveRuntimeExtensions = (runtimeConfig, extensions) => {
    const extensionConfiguration = Object.assign(regionConfigResolver.getAwsRegionExtensionConfiguration(runtimeConfig), smithyClient.getDefaultExtensionConfiguration(runtimeConfig), protocolHttp.getHttpHandlerExtensionConfiguration(runtimeConfig), getHttpAuthExtensionConfiguration(runtimeConfig));
    extensions.forEach((extension) => extension.configure(extensionConfiguration));
    return Object.assign(runtimeConfig, regionConfigResolver.resolveAwsRegionExtensionConfiguration(extensionConfiguration), smithyClient.resolveDefaultRuntimeConfig(extensionConfiguration), protocolHttp.resolveHttpHandlerRuntimeConfig(extensionConfiguration), resolveHttpAuthRuntimeConfig(extensionConfiguration));
};

class SSMClient extends smithyClient.Client {
    config;
    constructor(...[configuration]) {
        const _config_0 = runtimeConfig.getRuntimeConfig(configuration || {});
        super(_config_0);
        this.initConfig = _config_0;
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = middlewareUserAgent.resolveUserAgentConfig(_config_1);
        const _config_3 = middlewareRetry.resolveRetryConfig(_config_2);
        const _config_4 = configResolver.resolveRegionConfig(_config_3);
        const _config_5 = middlewareHostHeader.resolveHostHeaderConfig(_config_4);
        const _config_6 = middlewareEndpoint.resolveEndpointConfig(_config_5);
        const _config_7 = httpAuthSchemeProvider.resolveHttpAuthSchemeConfig(_config_6);
        const _config_8 = resolveRuntimeExtensions(_config_7, configuration?.extensions || []);
        this.config = _config_8;
        this.middlewareStack.use(schema.getSchemaSerdePlugin(this.config));
        this.middlewareStack.use(middlewareUserAgent.getUserAgentPlugin(this.config));
        this.middlewareStack.use(middlewareRetry.getRetryPlugin(this.config));
        this.middlewareStack.use(middlewareContentLength.getContentLengthPlugin(this.config));
        this.middlewareStack.use(middlewareHostHeader.getHostHeaderPlugin(this.config));
        this.middlewareStack.use(middlewareLogger.getLoggerPlugin(this.config));
        this.middlewareStack.use(middlewareRecursionDetection.getRecursionDetectionPlugin(this.config));
        this.middlewareStack.use(core.getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
            httpAuthSchemeParametersProvider: httpAuthSchemeProvider.defaultSSMHttpAuthSchemeParametersProvider,
            identityProviderConfigProvider: async (config) => new core.DefaultIdentityProviderConfig({
                "aws.auth#sigv4": config.credentials,
            }),
        }));
        this.middlewareStack.use(core.getHttpSigningPlugin(this.config));
    }
    destroy() {
        super.destroy();
    }
}

class SSMServiceException extends smithyClient.ServiceException {
    constructor(options) {
        super(options);
        Object.setPrototypeOf(this, SSMServiceException.prototype);
    }
}

class AccessDeniedException extends SSMServiceException {
    name = "AccessDeniedException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AccessDeniedException.prototype);
        this.Message = opts.Message;
    }
}
class InternalServerError extends SSMServiceException {
    name = "InternalServerError";
    $fault = "server";
    Message;
    constructor(opts) {
        super({
            name: "InternalServerError",
            $fault: "server",
            ...opts,
        });
        Object.setPrototypeOf(this, InternalServerError.prototype);
        this.Message = opts.Message;
    }
}
class InvalidResourceId extends SSMServiceException {
    name = "InvalidResourceId";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidResourceId",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidResourceId.prototype);
    }
}
class InvalidResourceType extends SSMServiceException {
    name = "InvalidResourceType";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidResourceType",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidResourceType.prototype);
    }
}
class TooManyTagsError extends SSMServiceException {
    name = "TooManyTagsError";
    $fault = "client";
    constructor(opts) {
        super({
            name: "TooManyTagsError",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, TooManyTagsError.prototype);
    }
}
class TooManyUpdates extends SSMServiceException {
    name = "TooManyUpdates";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "TooManyUpdates",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, TooManyUpdates.prototype);
        this.Message = opts.Message;
    }
}
class AlreadyExistsException extends SSMServiceException {
    name = "AlreadyExistsException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AlreadyExistsException.prototype);
        this.Message = opts.Message;
    }
}
class OpsItemConflictException extends SSMServiceException {
    name = "OpsItemConflictException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "OpsItemConflictException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemConflictException.prototype);
        this.Message = opts.Message;
    }
}
class OpsItemInvalidParameterException extends SSMServiceException {
    name = "OpsItemInvalidParameterException";
    $fault = "client";
    ParameterNames;
    Message;
    constructor(opts) {
        super({
            name: "OpsItemInvalidParameterException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemInvalidParameterException.prototype);
        this.ParameterNames = opts.ParameterNames;
        this.Message = opts.Message;
    }
}
class OpsItemLimitExceededException extends SSMServiceException {
    name = "OpsItemLimitExceededException";
    $fault = "client";
    ResourceTypes;
    Limit;
    LimitType;
    Message;
    constructor(opts) {
        super({
            name: "OpsItemLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemLimitExceededException.prototype);
        this.ResourceTypes = opts.ResourceTypes;
        this.Limit = opts.Limit;
        this.LimitType = opts.LimitType;
        this.Message = opts.Message;
    }
}
class OpsItemNotFoundException extends SSMServiceException {
    name = "OpsItemNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "OpsItemNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class OpsItemRelatedItemAlreadyExistsException extends SSMServiceException {
    name = "OpsItemRelatedItemAlreadyExistsException";
    $fault = "client";
    Message;
    ResourceUri;
    OpsItemId;
    constructor(opts) {
        super({
            name: "OpsItemRelatedItemAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemRelatedItemAlreadyExistsException.prototype);
        this.Message = opts.Message;
        this.ResourceUri = opts.ResourceUri;
        this.OpsItemId = opts.OpsItemId;
    }
}
class DuplicateInstanceId extends SSMServiceException {
    name = "DuplicateInstanceId";
    $fault = "client";
    constructor(opts) {
        super({
            name: "DuplicateInstanceId",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DuplicateInstanceId.prototype);
    }
}
class InvalidCommandId extends SSMServiceException {
    name = "InvalidCommandId";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidCommandId",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidCommandId.prototype);
    }
}
class InvalidInstanceId extends SSMServiceException {
    name = "InvalidInstanceId";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidInstanceId",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidInstanceId.prototype);
        this.Message = opts.Message;
    }
}
class DoesNotExistException extends SSMServiceException {
    name = "DoesNotExistException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "DoesNotExistException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DoesNotExistException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidParameters extends SSMServiceException {
    name = "InvalidParameters";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidParameters",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidParameters.prototype);
        this.Message = opts.Message;
    }
}
class AssociationAlreadyExists extends SSMServiceException {
    name = "AssociationAlreadyExists";
    $fault = "client";
    constructor(opts) {
        super({
            name: "AssociationAlreadyExists",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AssociationAlreadyExists.prototype);
    }
}
class AssociationLimitExceeded extends SSMServiceException {
    name = "AssociationLimitExceeded";
    $fault = "client";
    constructor(opts) {
        super({
            name: "AssociationLimitExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AssociationLimitExceeded.prototype);
    }
}
class InvalidDocument extends SSMServiceException {
    name = "InvalidDocument";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDocument",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDocument.prototype);
        this.Message = opts.Message;
    }
}
class InvalidDocumentVersion extends SSMServiceException {
    name = "InvalidDocumentVersion";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDocumentVersion",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDocumentVersion.prototype);
        this.Message = opts.Message;
    }
}
class InvalidOutputLocation extends SSMServiceException {
    name = "InvalidOutputLocation";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidOutputLocation",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidOutputLocation.prototype);
    }
}
class InvalidSchedule extends SSMServiceException {
    name = "InvalidSchedule";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidSchedule",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidSchedule.prototype);
        this.Message = opts.Message;
    }
}
class InvalidTag extends SSMServiceException {
    name = "InvalidTag";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidTag",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidTag.prototype);
        this.Message = opts.Message;
    }
}
class InvalidTarget extends SSMServiceException {
    name = "InvalidTarget";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidTarget",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidTarget.prototype);
        this.Message = opts.Message;
    }
}
class InvalidTargetMaps extends SSMServiceException {
    name = "InvalidTargetMaps";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidTargetMaps",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidTargetMaps.prototype);
        this.Message = opts.Message;
    }
}
class UnsupportedPlatformType extends SSMServiceException {
    name = "UnsupportedPlatformType";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "UnsupportedPlatformType",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedPlatformType.prototype);
        this.Message = opts.Message;
    }
}
class DocumentAlreadyExists extends SSMServiceException {
    name = "DocumentAlreadyExists";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "DocumentAlreadyExists",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DocumentAlreadyExists.prototype);
        this.Message = opts.Message;
    }
}
class DocumentLimitExceeded extends SSMServiceException {
    name = "DocumentLimitExceeded";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "DocumentLimitExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DocumentLimitExceeded.prototype);
        this.Message = opts.Message;
    }
}
class InvalidDocumentContent extends SSMServiceException {
    name = "InvalidDocumentContent";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDocumentContent",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDocumentContent.prototype);
        this.Message = opts.Message;
    }
}
class InvalidDocumentSchemaVersion extends SSMServiceException {
    name = "InvalidDocumentSchemaVersion";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDocumentSchemaVersion",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDocumentSchemaVersion.prototype);
        this.Message = opts.Message;
    }
}
class MaxDocumentSizeExceeded extends SSMServiceException {
    name = "MaxDocumentSizeExceeded";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "MaxDocumentSizeExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MaxDocumentSizeExceeded.prototype);
        this.Message = opts.Message;
    }
}
class NoLongerSupportedException extends SSMServiceException {
    name = "NoLongerSupportedException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "NoLongerSupportedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, NoLongerSupportedException.prototype);
        this.Message = opts.Message;
    }
}
class IdempotentParameterMismatch extends SSMServiceException {
    name = "IdempotentParameterMismatch";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "IdempotentParameterMismatch",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, IdempotentParameterMismatch.prototype);
        this.Message = opts.Message;
    }
}
class ResourceLimitExceededException extends SSMServiceException {
    name = "ResourceLimitExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourceLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceLimitExceededException.prototype);
        this.Message = opts.Message;
    }
}
class OpsItemAccessDeniedException extends SSMServiceException {
    name = "OpsItemAccessDeniedException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "OpsItemAccessDeniedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemAccessDeniedException.prototype);
        this.Message = opts.Message;
    }
}
class OpsItemAlreadyExistsException extends SSMServiceException {
    name = "OpsItemAlreadyExistsException";
    $fault = "client";
    Message;
    OpsItemId;
    constructor(opts) {
        super({
            name: "OpsItemAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemAlreadyExistsException.prototype);
        this.Message = opts.Message;
        this.OpsItemId = opts.OpsItemId;
    }
}
class OpsMetadataAlreadyExistsException extends SSMServiceException {
    name = "OpsMetadataAlreadyExistsException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "OpsMetadataAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsMetadataAlreadyExistsException.prototype);
    }
}
class OpsMetadataInvalidArgumentException extends SSMServiceException {
    name = "OpsMetadataInvalidArgumentException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "OpsMetadataInvalidArgumentException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsMetadataInvalidArgumentException.prototype);
    }
}
class OpsMetadataLimitExceededException extends SSMServiceException {
    name = "OpsMetadataLimitExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "OpsMetadataLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsMetadataLimitExceededException.prototype);
    }
}
class OpsMetadataTooManyUpdatesException extends SSMServiceException {
    name = "OpsMetadataTooManyUpdatesException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "OpsMetadataTooManyUpdatesException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsMetadataTooManyUpdatesException.prototype);
    }
}
class ResourceDataSyncAlreadyExistsException extends SSMServiceException {
    name = "ResourceDataSyncAlreadyExistsException";
    $fault = "client";
    SyncName;
    constructor(opts) {
        super({
            name: "ResourceDataSyncAlreadyExistsException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceDataSyncAlreadyExistsException.prototype);
        this.SyncName = opts.SyncName;
    }
}
class ResourceDataSyncCountExceededException extends SSMServiceException {
    name = "ResourceDataSyncCountExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourceDataSyncCountExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceDataSyncCountExceededException.prototype);
        this.Message = opts.Message;
    }
}
class ResourceDataSyncInvalidConfigurationException extends SSMServiceException {
    name = "ResourceDataSyncInvalidConfigurationException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourceDataSyncInvalidConfigurationException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceDataSyncInvalidConfigurationException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidActivation extends SSMServiceException {
    name = "InvalidActivation";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidActivation",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidActivation.prototype);
        this.Message = opts.Message;
    }
}
class InvalidActivationId extends SSMServiceException {
    name = "InvalidActivationId";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidActivationId",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidActivationId.prototype);
        this.Message = opts.Message;
    }
}
class AssociationDoesNotExist extends SSMServiceException {
    name = "AssociationDoesNotExist";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AssociationDoesNotExist",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AssociationDoesNotExist.prototype);
        this.Message = opts.Message;
    }
}
class AssociatedInstances extends SSMServiceException {
    name = "AssociatedInstances";
    $fault = "client";
    constructor(opts) {
        super({
            name: "AssociatedInstances",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AssociatedInstances.prototype);
    }
}
class InvalidDocumentOperation extends SSMServiceException {
    name = "InvalidDocumentOperation";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDocumentOperation",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDocumentOperation.prototype);
        this.Message = opts.Message;
    }
}
class InvalidDeleteInventoryParametersException extends SSMServiceException {
    name = "InvalidDeleteInventoryParametersException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDeleteInventoryParametersException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDeleteInventoryParametersException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidInventoryRequestException extends SSMServiceException {
    name = "InvalidInventoryRequestException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidInventoryRequestException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidInventoryRequestException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidOptionException extends SSMServiceException {
    name = "InvalidOptionException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidOptionException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidOptionException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidTypeNameException extends SSMServiceException {
    name = "InvalidTypeNameException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidTypeNameException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidTypeNameException.prototype);
        this.Message = opts.Message;
    }
}
class OpsMetadataNotFoundException extends SSMServiceException {
    name = "OpsMetadataNotFoundException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "OpsMetadataNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsMetadataNotFoundException.prototype);
    }
}
class ParameterNotFound extends SSMServiceException {
    name = "ParameterNotFound";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ParameterNotFound",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ParameterNotFound.prototype);
    }
}
class ResourceInUseException extends SSMServiceException {
    name = "ResourceInUseException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourceInUseException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceInUseException.prototype);
        this.Message = opts.Message;
    }
}
class ResourceDataSyncNotFoundException extends SSMServiceException {
    name = "ResourceDataSyncNotFoundException";
    $fault = "client";
    SyncName;
    SyncType;
    Message;
    constructor(opts) {
        super({
            name: "ResourceDataSyncNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceDataSyncNotFoundException.prototype);
        this.SyncName = opts.SyncName;
        this.SyncType = opts.SyncType;
        this.Message = opts.Message;
    }
}
class MalformedResourcePolicyDocumentException extends SSMServiceException {
    name = "MalformedResourcePolicyDocumentException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "MalformedResourcePolicyDocumentException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, MalformedResourcePolicyDocumentException.prototype);
        this.Message = opts.Message;
    }
}
class ResourceNotFoundException extends SSMServiceException {
    name = "ResourceNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class ResourcePolicyConflictException extends SSMServiceException {
    name = "ResourcePolicyConflictException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourcePolicyConflictException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourcePolicyConflictException.prototype);
        this.Message = opts.Message;
    }
}
class ResourcePolicyInvalidParameterException extends SSMServiceException {
    name = "ResourcePolicyInvalidParameterException";
    $fault = "client";
    ParameterNames;
    Message;
    constructor(opts) {
        super({
            name: "ResourcePolicyInvalidParameterException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourcePolicyInvalidParameterException.prototype);
        this.ParameterNames = opts.ParameterNames;
        this.Message = opts.Message;
    }
}
class ResourcePolicyNotFoundException extends SSMServiceException {
    name = "ResourcePolicyNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourcePolicyNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourcePolicyNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class TargetInUseException extends SSMServiceException {
    name = "TargetInUseException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "TargetInUseException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, TargetInUseException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidFilter extends SSMServiceException {
    name = "InvalidFilter";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidFilter",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidFilter.prototype);
        this.Message = opts.Message;
    }
}
class InvalidNextToken extends SSMServiceException {
    name = "InvalidNextToken";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidNextToken",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidNextToken.prototype);
        this.Message = opts.Message;
    }
}
class InvalidAssociationVersion extends SSMServiceException {
    name = "InvalidAssociationVersion";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidAssociationVersion",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidAssociationVersion.prototype);
        this.Message = opts.Message;
    }
}
class AssociationExecutionDoesNotExist extends SSMServiceException {
    name = "AssociationExecutionDoesNotExist";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AssociationExecutionDoesNotExist",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AssociationExecutionDoesNotExist.prototype);
        this.Message = opts.Message;
    }
}
class InvalidFilterKey extends SSMServiceException {
    name = "InvalidFilterKey";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidFilterKey",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidFilterKey.prototype);
    }
}
class InvalidFilterValue extends SSMServiceException {
    name = "InvalidFilterValue";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidFilterValue",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidFilterValue.prototype);
        this.Message = opts.Message;
    }
}
class AutomationExecutionNotFoundException extends SSMServiceException {
    name = "AutomationExecutionNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AutomationExecutionNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AutomationExecutionNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidPermissionType extends SSMServiceException {
    name = "InvalidPermissionType";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidPermissionType",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidPermissionType.prototype);
        this.Message = opts.Message;
    }
}
class UnsupportedOperatingSystem extends SSMServiceException {
    name = "UnsupportedOperatingSystem";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "UnsupportedOperatingSystem",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedOperatingSystem.prototype);
        this.Message = opts.Message;
    }
}
class InvalidInstanceInformationFilterValue extends SSMServiceException {
    name = "InvalidInstanceInformationFilterValue";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidInstanceInformationFilterValue",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidInstanceInformationFilterValue.prototype);
    }
}
class InvalidInstancePropertyFilterValue extends SSMServiceException {
    name = "InvalidInstancePropertyFilterValue";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidInstancePropertyFilterValue",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidInstancePropertyFilterValue.prototype);
    }
}
class InvalidDeletionIdException extends SSMServiceException {
    name = "InvalidDeletionIdException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDeletionIdException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDeletionIdException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidFilterOption extends SSMServiceException {
    name = "InvalidFilterOption";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidFilterOption",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidFilterOption.prototype);
    }
}
class OpsItemRelatedItemAssociationNotFoundException extends SSMServiceException {
    name = "OpsItemRelatedItemAssociationNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "OpsItemRelatedItemAssociationNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsItemRelatedItemAssociationNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class ThrottlingException extends SSMServiceException {
    name = "ThrottlingException";
    $fault = "client";
    Message;
    QuotaCode;
    ServiceCode;
    constructor(opts) {
        super({
            name: "ThrottlingException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ThrottlingException.prototype);
        this.Message = opts.Message;
        this.QuotaCode = opts.QuotaCode;
        this.ServiceCode = opts.ServiceCode;
    }
}
class ValidationException extends SSMServiceException {
    name = "ValidationException";
    $fault = "client";
    Message;
    ReasonCode;
    constructor(opts) {
        super({
            name: "ValidationException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ValidationException.prototype);
        this.Message = opts.Message;
        this.ReasonCode = opts.ReasonCode;
    }
}
class InvalidDocumentType extends SSMServiceException {
    name = "InvalidDocumentType";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidDocumentType",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidDocumentType.prototype);
        this.Message = opts.Message;
    }
}
class UnsupportedCalendarException extends SSMServiceException {
    name = "UnsupportedCalendarException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "UnsupportedCalendarException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedCalendarException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidPluginName extends SSMServiceException {
    name = "InvalidPluginName";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidPluginName",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidPluginName.prototype);
    }
}
class InvocationDoesNotExist extends SSMServiceException {
    name = "InvocationDoesNotExist";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvocationDoesNotExist",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvocationDoesNotExist.prototype);
    }
}
class UnsupportedFeatureRequiredException extends SSMServiceException {
    name = "UnsupportedFeatureRequiredException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "UnsupportedFeatureRequiredException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedFeatureRequiredException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidAggregatorException extends SSMServiceException {
    name = "InvalidAggregatorException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidAggregatorException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidAggregatorException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidInventoryGroupException extends SSMServiceException {
    name = "InvalidInventoryGroupException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidInventoryGroupException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidInventoryGroupException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidResultAttributeException extends SSMServiceException {
    name = "InvalidResultAttributeException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidResultAttributeException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidResultAttributeException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidKeyId extends SSMServiceException {
    name = "InvalidKeyId";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidKeyId",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidKeyId.prototype);
    }
}
class ParameterVersionNotFound extends SSMServiceException {
    name = "ParameterVersionNotFound";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ParameterVersionNotFound",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ParameterVersionNotFound.prototype);
    }
}
class ServiceSettingNotFound extends SSMServiceException {
    name = "ServiceSettingNotFound";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ServiceSettingNotFound",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ServiceSettingNotFound.prototype);
        this.Message = opts.Message;
    }
}
class ParameterVersionLabelLimitExceeded extends SSMServiceException {
    name = "ParameterVersionLabelLimitExceeded";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ParameterVersionLabelLimitExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ParameterVersionLabelLimitExceeded.prototype);
    }
}
class UnsupportedOperationException extends SSMServiceException {
    name = "UnsupportedOperationException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "UnsupportedOperationException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
        this.Message = opts.Message;
    }
}
class DocumentPermissionLimit extends SSMServiceException {
    name = "DocumentPermissionLimit";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "DocumentPermissionLimit",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DocumentPermissionLimit.prototype);
        this.Message = opts.Message;
    }
}
class ComplianceTypeCountLimitExceededException extends SSMServiceException {
    name = "ComplianceTypeCountLimitExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ComplianceTypeCountLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ComplianceTypeCountLimitExceededException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidItemContentException extends SSMServiceException {
    name = "InvalidItemContentException";
    $fault = "client";
    TypeName;
    Message;
    constructor(opts) {
        super({
            name: "InvalidItemContentException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidItemContentException.prototype);
        this.TypeName = opts.TypeName;
        this.Message = opts.Message;
    }
}
class ItemSizeLimitExceededException extends SSMServiceException {
    name = "ItemSizeLimitExceededException";
    $fault = "client";
    TypeName;
    Message;
    constructor(opts) {
        super({
            name: "ItemSizeLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ItemSizeLimitExceededException.prototype);
        this.TypeName = opts.TypeName;
        this.Message = opts.Message;
    }
}
class TotalSizeLimitExceededException extends SSMServiceException {
    name = "TotalSizeLimitExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "TotalSizeLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, TotalSizeLimitExceededException.prototype);
        this.Message = opts.Message;
    }
}
class CustomSchemaCountLimitExceededException extends SSMServiceException {
    name = "CustomSchemaCountLimitExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "CustomSchemaCountLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, CustomSchemaCountLimitExceededException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidInventoryItemContextException extends SSMServiceException {
    name = "InvalidInventoryItemContextException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidInventoryItemContextException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidInventoryItemContextException.prototype);
        this.Message = opts.Message;
    }
}
class ItemContentMismatchException extends SSMServiceException {
    name = "ItemContentMismatchException";
    $fault = "client";
    TypeName;
    Message;
    constructor(opts) {
        super({
            name: "ItemContentMismatchException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ItemContentMismatchException.prototype);
        this.TypeName = opts.TypeName;
        this.Message = opts.Message;
    }
}
class SubTypeCountLimitExceededException extends SSMServiceException {
    name = "SubTypeCountLimitExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "SubTypeCountLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, SubTypeCountLimitExceededException.prototype);
        this.Message = opts.Message;
    }
}
class UnsupportedInventoryItemContextException extends SSMServiceException {
    name = "UnsupportedInventoryItemContextException";
    $fault = "client";
    TypeName;
    Message;
    constructor(opts) {
        super({
            name: "UnsupportedInventoryItemContextException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedInventoryItemContextException.prototype);
        this.TypeName = opts.TypeName;
        this.Message = opts.Message;
    }
}
class UnsupportedInventorySchemaVersionException extends SSMServiceException {
    name = "UnsupportedInventorySchemaVersionException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "UnsupportedInventorySchemaVersionException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedInventorySchemaVersionException.prototype);
        this.Message = opts.Message;
    }
}
class HierarchyLevelLimitExceededException extends SSMServiceException {
    name = "HierarchyLevelLimitExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "HierarchyLevelLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, HierarchyLevelLimitExceededException.prototype);
    }
}
class HierarchyTypeMismatchException extends SSMServiceException {
    name = "HierarchyTypeMismatchException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "HierarchyTypeMismatchException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, HierarchyTypeMismatchException.prototype);
    }
}
class IncompatiblePolicyException extends SSMServiceException {
    name = "IncompatiblePolicyException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "IncompatiblePolicyException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, IncompatiblePolicyException.prototype);
    }
}
class InvalidAllowedPatternException extends SSMServiceException {
    name = "InvalidAllowedPatternException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidAllowedPatternException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidAllowedPatternException.prototype);
    }
}
class InvalidPolicyAttributeException extends SSMServiceException {
    name = "InvalidPolicyAttributeException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidPolicyAttributeException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidPolicyAttributeException.prototype);
    }
}
class InvalidPolicyTypeException extends SSMServiceException {
    name = "InvalidPolicyTypeException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidPolicyTypeException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidPolicyTypeException.prototype);
    }
}
class ParameterAlreadyExists extends SSMServiceException {
    name = "ParameterAlreadyExists";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ParameterAlreadyExists",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ParameterAlreadyExists.prototype);
    }
}
class ParameterLimitExceeded extends SSMServiceException {
    name = "ParameterLimitExceeded";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ParameterLimitExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ParameterLimitExceeded.prototype);
    }
}
class ParameterMaxVersionLimitExceeded extends SSMServiceException {
    name = "ParameterMaxVersionLimitExceeded";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ParameterMaxVersionLimitExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ParameterMaxVersionLimitExceeded.prototype);
    }
}
class ParameterPatternMismatchException extends SSMServiceException {
    name = "ParameterPatternMismatchException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "ParameterPatternMismatchException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ParameterPatternMismatchException.prototype);
    }
}
class PoliciesLimitExceededException extends SSMServiceException {
    name = "PoliciesLimitExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "PoliciesLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, PoliciesLimitExceededException.prototype);
    }
}
class UnsupportedParameterType extends SSMServiceException {
    name = "UnsupportedParameterType";
    $fault = "client";
    constructor(opts) {
        super({
            name: "UnsupportedParameterType",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, UnsupportedParameterType.prototype);
    }
}
class ResourcePolicyLimitExceededException extends SSMServiceException {
    name = "ResourcePolicyLimitExceededException";
    $fault = "client";
    Limit;
    LimitType;
    Message;
    constructor(opts) {
        super({
            name: "ResourcePolicyLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourcePolicyLimitExceededException.prototype);
        this.Limit = opts.Limit;
        this.LimitType = opts.LimitType;
        this.Message = opts.Message;
    }
}
class FeatureNotAvailableException extends SSMServiceException {
    name = "FeatureNotAvailableException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "FeatureNotAvailableException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, FeatureNotAvailableException.prototype);
        this.Message = opts.Message;
    }
}
class AutomationStepNotFoundException extends SSMServiceException {
    name = "AutomationStepNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AutomationStepNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AutomationStepNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidAutomationSignalException extends SSMServiceException {
    name = "InvalidAutomationSignalException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidAutomationSignalException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidAutomationSignalException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidNotificationConfig extends SSMServiceException {
    name = "InvalidNotificationConfig";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidNotificationConfig",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidNotificationConfig.prototype);
        this.Message = opts.Message;
    }
}
class InvalidOutputFolder extends SSMServiceException {
    name = "InvalidOutputFolder";
    $fault = "client";
    constructor(opts) {
        super({
            name: "InvalidOutputFolder",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidOutputFolder.prototype);
    }
}
class InvalidRole extends SSMServiceException {
    name = "InvalidRole";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidRole",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidRole.prototype);
        this.Message = opts.Message;
    }
}
class ServiceQuotaExceededException extends SSMServiceException {
    name = "ServiceQuotaExceededException";
    $fault = "client";
    Message;
    ResourceId;
    ResourceType;
    QuotaCode;
    ServiceCode;
    constructor(opts) {
        super({
            name: "ServiceQuotaExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ServiceQuotaExceededException.prototype);
        this.Message = opts.Message;
        this.ResourceId = opts.ResourceId;
        this.ResourceType = opts.ResourceType;
        this.QuotaCode = opts.QuotaCode;
        this.ServiceCode = opts.ServiceCode;
    }
}
class InvalidAssociation extends SSMServiceException {
    name = "InvalidAssociation";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidAssociation",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidAssociation.prototype);
        this.Message = opts.Message;
    }
}
class AutomationDefinitionNotFoundException extends SSMServiceException {
    name = "AutomationDefinitionNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AutomationDefinitionNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AutomationDefinitionNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class AutomationDefinitionVersionNotFoundException extends SSMServiceException {
    name = "AutomationDefinitionVersionNotFoundException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AutomationDefinitionVersionNotFoundException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AutomationDefinitionVersionNotFoundException.prototype);
        this.Message = opts.Message;
    }
}
class AutomationExecutionLimitExceededException extends SSMServiceException {
    name = "AutomationExecutionLimitExceededException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AutomationExecutionLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AutomationExecutionLimitExceededException.prototype);
        this.Message = opts.Message;
    }
}
class InvalidAutomationExecutionParametersException extends SSMServiceException {
    name = "InvalidAutomationExecutionParametersException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidAutomationExecutionParametersException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidAutomationExecutionParametersException.prototype);
        this.Message = opts.Message;
    }
}
class AutomationDefinitionNotApprovedException extends SSMServiceException {
    name = "AutomationDefinitionNotApprovedException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AutomationDefinitionNotApprovedException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AutomationDefinitionNotApprovedException.prototype);
        this.Message = opts.Message;
    }
}
class TargetNotConnected extends SSMServiceException {
    name = "TargetNotConnected";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "TargetNotConnected",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, TargetNotConnected.prototype);
        this.Message = opts.Message;
    }
}
class InvalidAutomationStatusUpdateException extends SSMServiceException {
    name = "InvalidAutomationStatusUpdateException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidAutomationStatusUpdateException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidAutomationStatusUpdateException.prototype);
        this.Message = opts.Message;
    }
}
class AssociationVersionLimitExceeded extends SSMServiceException {
    name = "AssociationVersionLimitExceeded";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "AssociationVersionLimitExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, AssociationVersionLimitExceeded.prototype);
        this.Message = opts.Message;
    }
}
class InvalidUpdate extends SSMServiceException {
    name = "InvalidUpdate";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "InvalidUpdate",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, InvalidUpdate.prototype);
        this.Message = opts.Message;
    }
}
class StatusUnchanged extends SSMServiceException {
    name = "StatusUnchanged";
    $fault = "client";
    constructor(opts) {
        super({
            name: "StatusUnchanged",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, StatusUnchanged.prototype);
    }
}
class DocumentVersionLimitExceeded extends SSMServiceException {
    name = "DocumentVersionLimitExceeded";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "DocumentVersionLimitExceeded",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DocumentVersionLimitExceeded.prototype);
        this.Message = opts.Message;
    }
}
class DuplicateDocumentContent extends SSMServiceException {
    name = "DuplicateDocumentContent";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "DuplicateDocumentContent",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DuplicateDocumentContent.prototype);
        this.Message = opts.Message;
    }
}
class DuplicateDocumentVersionName extends SSMServiceException {
    name = "DuplicateDocumentVersionName";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "DuplicateDocumentVersionName",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, DuplicateDocumentVersionName.prototype);
        this.Message = opts.Message;
    }
}
class OpsMetadataKeyLimitExceededException extends SSMServiceException {
    name = "OpsMetadataKeyLimitExceededException";
    $fault = "client";
    constructor(opts) {
        super({
            name: "OpsMetadataKeyLimitExceededException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, OpsMetadataKeyLimitExceededException.prototype);
    }
}
class ResourceDataSyncConflictException extends SSMServiceException {
    name = "ResourceDataSyncConflictException";
    $fault = "client";
    Message;
    constructor(opts) {
        super({
            name: "ResourceDataSyncConflictException",
            $fault: "client",
            ...opts,
        });
        Object.setPrototypeOf(this, ResourceDataSyncConflictException.prototype);
        this.Message = opts.Message;
    }
}

const _A = "Activation";
const _AA = "AutoApprove";
const _AAD = "ApproveAfterDays";
const _AAE = "AssociationAlreadyExists";
const _AC = "AlarmConfiguration";
const _ACL = "AttachmentContentList";
const _ACc = "ActivationCode";
const _ACt = "AttachmentContent";
const _ACtt = "AttachmentsContent";
const _AD = "AssociationDescription";
const _ADE = "AccessDeniedException";
const _ADL = "AssociationDescriptionList";
const _ADNAE = "AutomationDefinitionNotApprovedException";
const _ADNE = "AssociationDoesNotExist";
const _ADNFE = "AutomationDefinitionNotFoundException";
const _ADVNFE = "AutomationDefinitionVersionNotFoundException";
const _ADp = "ApprovalDate";
const _AE = "AssociationExecution";
const _AEDNE = "AssociationExecutionDoesNotExist";
const _AEE = "AlreadyExistsException";
const _AEF = "AssociationExecutionFilter";
const _AEFL = "AssociationExecutionFilterList";
const _AEFLu = "AutomationExecutionFilterList";
const _AEFu = "AutomationExecutionFilter";
const _AEI = "AutomationExecutionId";
const _AEIu = "AutomationExecutionInputs";
const _AEL = "AssociationExecutionsList";
const _AELEE = "AutomationExecutionLimitExceededException";
const _AEM = "AutomationExecutionMetadata";
const _AEML = "AutomationExecutionMetadataList";
const _AENFE = "AutomationExecutionNotFoundException";
const _AEP = "AutomationExecutionPreview";
const _AES = "AutomationExecutionStatus";
const _AET = "AssociationExecutionTarget";
const _AETF = "AssociationExecutionTargetsFilter";
const _AETFL = "AssociationExecutionTargetsFilterList";
const _AETL = "AssociationExecutionTargetsList";
const _AETc = "ActualEndTime";
const _AETs = "AssociationExecutionTargets";
const _AEs = "AssociationExecutions";
const _AEu = "AutomationExecution";
const _AF = "AssociationFilter";
const _AFL = "AssociationFilterList";
const _AI = "AccountId";
const _AIL = "AccountIdList";
const _AILt = "AttachmentInformationList";
const _AITA = "AccountIdsToAdd";
const _AITR = "AccountIdsToRemove";
const _AIc = "ActivationId";
const _AIcc = "AccountIds";
const _AId = "AdditionalInfo";
const _AIdv = "AdvisoryIds";
const _AIs = "AssociatedInstances";
const _AIss = "AssociationId";
const _AIsso = "AssociationIds";
const _AIt = "AttachmentInformation";
const _AItt = "AttachmentsInformation";
const _AKI = "AccessKeyId";
const _AKST = "AccessKeySecretType";
const _AL = "ActivationList";
const _ALE = "AssociationLimitExceeded";
const _ALl = "AlarmList";
const _ALs = "AssociationList";
const _AN = "AssociationName";
const _ANt = "AttributeName";
const _AO = "AssociationOverview";
const _AOACI = "ApplyOnlyAtCronInterval";
const _AOIRI = "AssociateOpsItemRelatedItem";
const _AOIRIR = "AssociateOpsItemRelatedItemRequest";
const _AOIRIRs = "AssociateOpsItemRelatedItemResponse";
const _AOS = "AwsOrganizationsSource";
const _AP = "ApprovedPatches";
const _APCL = "ApprovedPatchesComplianceLevel";
const _APENS = "ApprovedPatchesEnableNonSecurity";
const _APM = "AutomationParameterMap";
const _APl = "AllowedPattern";
const _AR = "ApprovalRules";
const _ARI = "AccessRequestId";
const _ARN = "ARN";
const _ARS = "AccessRequestStatus";
const _AS = "AssociationStatus";
const _ASAC = "AssociationStatusAggregatedCount";
const _ASI = "AccountSharingInfo";
const _ASIL = "AccountSharingInfoList";
const _ASILl = "AlarmStateInformationList";
const _ASIl = "AlarmStateInformation";
const _ASL = "AttachmentsSourceList";
const _ASNFE = "AutomationStepNotFoundException";
const _AST = "ActualStartTime";
const _ASUC = "AvailableSecurityUpdateCount";
const _ASUCS = "AvailableSecurityUpdatesComplianceStatus";
const _ASt = "AttachmentsSource";
const _ASu = "AutomationSubtype";
const _AT = "AssociationType";
const _ATPN = "AutomationTargetParameterName";
const _ATTR = "AddTagsToResource";
const _ATTRR = "AddTagsToResourceRequest";
const _ATTRRd = "AddTagsToResourceResult";
const _ATc = "AccessType";
const _ATg = "AgentType";
const _ATgg = "AggregatorType";
const _ATt = "AtTime";
const _ATu = "AutomationType";
const _AUD = "ApproveUntilDate";
const _AUT = "AllowUnassociatedTargets";
const _AV = "AssociationVersion";
const _AVI = "AssociationVersionInfo";
const _AVL = "AssociationVersionList";
const _AVLE = "AssociationVersionLimitExceeded";
const _AVg = "AgentVersion";
const _AVp = "ApprovedVersion";
const _AVs = "AssociationVersions";
const _AWSKMSKARN = "AWSKMSKeyARN";
const _Ac = "Action";
const _Acc = "Accounts";
const _Ag = "Aggregators";
const _Agg = "Aggregator";
const _Al = "Alarm";
const _Ala = "Alarms";
const _Ar = "Architecture";
const _Arc = "Arch";
const _Arn = "Arn";
const _As = "Association";
const _Ass = "Associations";
const _At = "Attachments";
const _Att = "Attributes";
const _Attr = "Attribute";
const _Au = "Author";
const _Aut = "Automation";
const _BD = "BaselineDescription";
const _BI = "BaselineId";
const _BIa = "BaselineIdentities";
const _BIas = "BaselineIdentity";
const _BIu = "BugzillaIds";
const _BN = "BaselineName";
const _BNu = "BucketName";
const _BO = "BaselineOverride";
const _C = "Command";
const _CA = "CurrentAction";
const _CAB = "CreateAssociationBatch";
const _CABR = "CreateAssociationBatchRequest";
const _CABRE = "CreateAssociationBatchRequestEntry";
const _CABREr = "CreateAssociationBatchRequestEntries";
const _CABRr = "CreateAssociationBatchResult";
const _CAR = "CreateActivationRequest";
const _CARr = "CreateActivationResult";
const _CARre = "CreateAssociationRequest";
const _CARrea = "CreateAssociationResult";
const _CAr = "CreateActivation";
const _CAre = "CreateAssociation";
const _CB = "CutoffBehavior";
const _CBr = "CreatedBy";
const _CC = "CompletedCount";
const _CCR = "CancelCommandRequest";
const _CCRa = "CancelCommandResult";
const _CCa = "CancelCommand";
const _CCl = "ClientContext";
const _CCo = "CompliantCount";
const _CCr = "CriticalCount";
const _CD = "CreatedDate";
const _CDR = "CreateDocumentRequest";
const _CDRr = "CreateDocumentResult";
const _CDh = "ChangeDetails";
const _CDr = "CreationDate";
const _CDre = "CreateDocument";
const _CE = "CategoryEnum";
const _CES = "ComplianceExecutionSummary";
const _CF = "CommandFilter";
const _CFL = "CommandFilterList";
const _CFo = "ComplianceFilter";
const _CH = "ContentHash";
const _CI = "CommandId";
const _CIE = "ComplianceItemEntry";
const _CIEL = "ComplianceItemEntryList";
const _CIL = "CommandInvocationList";
const _CILo = "ComplianceItemList";
const _CIo = "CommandInvocation";
const _CIom = "ComplianceItem";
const _CIomm = "CommandInvocations";
const _CIomp = "ComplianceItems";
const _CL = "ComplianceLevel";
const _CLo = "CommandList";
const _CMW = "CreateMaintenanceWindow";
const _CMWE = "CancelMaintenanceWindowExecution";
const _CMWER = "CancelMaintenanceWindowExecutionRequest";
const _CMWERa = "CancelMaintenanceWindowExecutionResult";
const _CMWR = "CreateMaintenanceWindowRequest";
const _CMWRr = "CreateMaintenanceWindowResult";
const _CN = "CalendarNames";
const _CNCC = "CriticalNonCompliantCount";
const _CNo = "ComputerName";
const _COI = "CreateOpsItem";
const _COIR = "CreateOpsItemRequest";
const _COIRr = "CreateOpsItemResponse";
const _COM = "CreateOpsMetadata";
const _COMR = "CreateOpsMetadataRequest";
const _COMRr = "CreateOpsMetadataResult";
const _CP = "CommandPlugins";
const _CPB = "CreatePatchBaseline";
const _CPBR = "CreatePatchBaselineRequest";
const _CPBRr = "CreatePatchBaselineResult";
const _CPL = "CommandPluginList";
const _CPo = "CommandPlugin";
const _CRDS = "CreateResourceDataSync";
const _CRDSR = "CreateResourceDataSyncRequest";
const _CRDSRr = "CreateResourceDataSyncResult";
const _CRN = "ChangeRequestName";
const _CS = "ComplianceSeverity";
const _CSCLEE = "CustomSchemaCountLimitExceededException";
const _CSF = "ComplianceStringFilter";
const _CSFL = "ComplianceStringFilterList";
const _CSFVL = "ComplianceStringFilterValueList";
const _CSI = "ComplianceSummaryItem";
const _CSIL = "ComplianceSummaryItemList";
const _CSIo = "ComplianceSummaryItems";
const _CSN = "CurrentStepName";
const _CSa = "CancelledSteps";
const _CSo = "CompliantSummary";
const _CT = "CreatedTime";
const _CTCLEE = "ComplianceTypeCountLimitExceededException";
const _CTa = "CaptureTime";
const _CTl = "ClientToken";
const _CTo = "ComplianceType";
const _CTr = "CreateTime";
const _CU = "ContentUrl";
const _CVEI = "CVEIds";
const _CWLGN = "CloudWatchLogGroupName";
const _CWOC = "CloudWatchOutputConfig";
const _CWOE = "CloudWatchOutputEnabled";
const _CWOU = "CloudWatchOutputUrl";
const _Ca = "Category";
const _Cl = "Classification";
const _Co = "Comment";
const _Com = "Commands";
const _Con = "Content";
const _Conf = "Configuration";
const _Cont = "Context";
const _Cou = "Count";
const _Cr = "Credentials";
const _Cu = "Cutoff";
const _D = "Description";
const _DA = "DeleteActivation";
const _DAE = "DocumentAlreadyExists";
const _DAER = "DescribeAssociationExecutionsRequest";
const _DAERe = "DescribeAssociationExecutionsResult";
const _DAERes = "DescribeAutomationExecutionsRequest";
const _DAEResc = "DescribeAutomationExecutionsResult";
const _DAET = "DescribeAssociationExecutionTargets";
const _DAETR = "DescribeAssociationExecutionTargetsRequest";
const _DAETRe = "DescribeAssociationExecutionTargetsResult";
const _DAEe = "DescribeAssociationExecutions";
const _DAEes = "DescribeAutomationExecutions";
const _DAF = "DescribeActivationsFilter";
const _DAFL = "DescribeActivationsFilterList";
const _DAP = "DescribeAvailablePatches";
const _DAPR = "DescribeAvailablePatchesRequest";
const _DAPRe = "DescribeAvailablePatchesResult";
const _DAR = "DeleteActivationRequest";
const _DARe = "DeleteActivationResult";
const _DARel = "DeleteAssociationRequest";
const _DARele = "DeleteAssociationResult";
const _DARes = "DescribeActivationsRequest";
const _DAResc = "DescribeActivationsResult";
const _DARescr = "DescribeAssociationRequest";
const _DARescri = "DescribeAssociationResult";
const _DASE = "DescribeAutomationStepExecutions";
const _DASER = "DescribeAutomationStepExecutionsRequest";
const _DASERe = "DescribeAutomationStepExecutionsResult";
const _DAe = "DeleteAssociation";
const _DAes = "DescribeActivations";
const _DAesc = "DescribeAssociation";
const _DB = "DefaultBaseline";
const _DD = "DocumentDescription";
const _DDC = "DuplicateDocumentContent";
const _DDP = "DescribeDocumentPermission";
const _DDPR = "DescribeDocumentPermissionRequest";
const _DDPRe = "DescribeDocumentPermissionResponse";
const _DDR = "DeleteDocumentRequest";
const _DDRe = "DeleteDocumentResult";
const _DDRes = "DescribeDocumentRequest";
const _DDResc = "DescribeDocumentResult";
const _DDS = "DestinationDataSharing";
const _DDST = "DestinationDataSharingType";
const _DDVD = "DocumentDefaultVersionDescription";
const _DDVN = "DuplicateDocumentVersionName";
const _DDe = "DeleteDocument";
const _DDes = "DescribeDocument";
const _DEIA = "DescribeEffectiveInstanceAssociations";
const _DEIAR = "DescribeEffectiveInstanceAssociationsRequest";
const _DEIARe = "DescribeEffectiveInstanceAssociationsResult";
const _DEPFPB = "DescribeEffectivePatchesForPatchBaseline";
const _DEPFPBR = "DescribeEffectivePatchesForPatchBaselineRequest";
const _DEPFPBRe = "DescribeEffectivePatchesForPatchBaselineResult";
const _DF = "DocumentFormat";
const _DFL = "DocumentFilterList";
const _DFo = "DocumentFilter";
const _DH = "DocumentHash";
const _DHT = "DocumentHashType";
const _DI = "DeletionId";
const _DIAS = "DescribeInstanceAssociationsStatus";
const _DIASR = "DescribeInstanceAssociationsStatusRequest";
const _DIASRe = "DescribeInstanceAssociationsStatusResult";
const _DID = "DescribeInventoryDeletions";
const _DIDR = "DescribeInventoryDeletionsRequest";
const _DIDRe = "DescribeInventoryDeletionsResult";
const _DII = "DuplicateInstanceId";
const _DIIR = "DescribeInstanceInformationRequest";
const _DIIRe = "DescribeInstanceInformationResult";
const _DIIe = "DescribeInstanceInformation";
const _DIL = "DocumentIdentifierList";
const _DIN = "DefaultInstanceName";
const _DIP = "DescribeInstancePatches";
const _DIPR = "DescribeInstancePatchesRequest";
const _DIPRe = "DescribeInstancePatchesResult";
const _DIPRes = "DescribeInstancePropertiesRequest";
const _DIPResc = "DescribeInstancePropertiesResult";
const _DIPS = "DescribeInstancePatchStates";
const _DIPSFPG = "DescribeInstancePatchStatesForPatchGroup";
const _DIPSFPGR = "DescribeInstancePatchStatesForPatchGroupRequest";
const _DIPSFPGRe = "DescribeInstancePatchStatesForPatchGroupResult";
const _DIPSR = "DescribeInstancePatchStatesRequest";
const _DIPSRe = "DescribeInstancePatchStatesResult";
const _DIPe = "DescribeInstanceProperties";
const _DIR = "DeleteInventoryRequest";
const _DIRe = "DeleteInventoryResult";
const _DIe = "DeleteInventory";
const _DIo = "DocumentIdentifier";
const _DIoc = "DocumentIdentifiers";
const _DKVF = "DocumentKeyValuesFilter";
const _DKVFL = "DocumentKeyValuesFilterList";
const _DLE = "DocumentLimitExceeded";
const _DMI = "DeregisterManagedInstance";
const _DMIR = "DeregisterManagedInstanceRequest";
const _DMIRe = "DeregisterManagedInstanceResult";
const _DMRI = "DocumentMetadataResponseInfo";
const _DMW = "DeleteMaintenanceWindow";
const _DMWE = "DescribeMaintenanceWindowExecutions";
const _DMWER = "DescribeMaintenanceWindowExecutionsRequest";
const _DMWERe = "DescribeMaintenanceWindowExecutionsResult";
const _DMWET = "DescribeMaintenanceWindowExecutionTasks";
const _DMWETI = "DescribeMaintenanceWindowExecutionTaskInvocations";
const _DMWETIR = "DescribeMaintenanceWindowExecutionTaskInvocationsRequest";
const _DMWETIRe = "DescribeMaintenanceWindowExecutionTaskInvocationsResult";
const _DMWETR = "DescribeMaintenanceWindowExecutionTasksRequest";
const _DMWETRe = "DescribeMaintenanceWindowExecutionTasksResult";
const _DMWFT = "DescribeMaintenanceWindowsForTarget";
const _DMWFTR = "DescribeMaintenanceWindowsForTargetRequest";
const _DMWFTRe = "DescribeMaintenanceWindowsForTargetResult";
const _DMWR = "DeleteMaintenanceWindowRequest";
const _DMWRe = "DeleteMaintenanceWindowResult";
const _DMWRes = "DescribeMaintenanceWindowsRequest";
const _DMWResc = "DescribeMaintenanceWindowsResult";
const _DMWS = "DescribeMaintenanceWindowSchedule";
const _DMWSR = "DescribeMaintenanceWindowScheduleRequest";
const _DMWSRe = "DescribeMaintenanceWindowScheduleResult";
const _DMWT = "DescribeMaintenanceWindowTargets";
const _DMWTR = "DescribeMaintenanceWindowTargetsRequest";
const _DMWTRe = "DescribeMaintenanceWindowTargetsResult";
const _DMWTRes = "DescribeMaintenanceWindowTasksRequest";
const _DMWTResc = "DescribeMaintenanceWindowTasksResult";
const _DMWTe = "DescribeMaintenanceWindowTasks";
const _DMWe = "DescribeMaintenanceWindows";
const _DN = "DocumentName";
const _DNEE = "DoesNotExistException";
const _DNi = "DisplayName";
const _DOI = "DeleteOpsItem";
const _DOIR = "DeleteOpsItemRequest";
const _DOIRI = "DisassociateOpsItemRelatedItem";
const _DOIRIR = "DisassociateOpsItemRelatedItemRequest";
const _DOIRIRi = "DisassociateOpsItemRelatedItemResponse";
const _DOIRe = "DeleteOpsItemResponse";
const _DOIRes = "DescribeOpsItemsRequest";
const _DOIResc = "DescribeOpsItemsResponse";
const _DOIe = "DescribeOpsItems";
const _DOM = "DeleteOpsMetadata";
const _DOMR = "DeleteOpsMetadataRequest";
const _DOMRe = "DeleteOpsMetadataResult";
const _DP = "DeletedParameters";
const _DPB = "DeletePatchBaseline";
const _DPBFPG = "DeregisterPatchBaselineForPatchGroup";
const _DPBFPGR = "DeregisterPatchBaselineForPatchGroupRequest";
const _DPBFPGRe = "DeregisterPatchBaselineForPatchGroupResult";
const _DPBR = "DeletePatchBaselineRequest";
const _DPBRe = "DeletePatchBaselineResult";
const _DPBRes = "DescribePatchBaselinesRequest";
const _DPBResc = "DescribePatchBaselinesResult";
const _DPBe = "DescribePatchBaselines";
const _DPG = "DescribePatchGroups";
const _DPGR = "DescribePatchGroupsRequest";
const _DPGRe = "DescribePatchGroupsResult";
const _DPGS = "DescribePatchGroupState";
const _DPGSR = "DescribePatchGroupStateRequest";
const _DPGSRe = "DescribePatchGroupStateResult";
const _DPL = "DocumentPermissionLimit";
const _DPLo = "DocumentParameterList";
const _DPP = "DescribePatchProperties";
const _DPPR = "DescribePatchPropertiesRequest";
const _DPPRe = "DescribePatchPropertiesResult";
const _DPR = "DeleteParameterRequest";
const _DPRe = "DeleteParameterResult";
const _DPRel = "DeleteParametersRequest";
const _DPRele = "DeleteParametersResult";
const _DPRes = "DescribeParametersRequest";
const _DPResc = "DescribeParametersResult";
const _DPe = "DeleteParameter";
const _DPel = "DeleteParameters";
const _DPes = "DescribeParameters";
const _DPo = "DocumentParameter";
const _DR = "DryRun";
const _DRCL = "DocumentReviewCommentList";
const _DRCS = "DocumentReviewCommentSource";
const _DRDS = "DeleteResourceDataSync";
const _DRDSR = "DeleteResourceDataSyncRequest";
const _DRDSRe = "DeleteResourceDataSyncResult";
const _DRL = "DocumentRequiresList";
const _DRP = "DeleteResourcePolicy";
const _DRPR = "DeleteResourcePolicyRequest";
const _DRPRe = "DeleteResourcePolicyResponse";
const _DRRL = "DocumentReviewerResponseList";
const _DRRS = "DocumentReviewerResponseSource";
const _DRo = "DocumentRequires";
const _DRoc = "DocumentReviews";
const _DS = "DetailedStatus";
const _DSR = "DescribeSessionsRequest";
const _DSRe = "DescribeSessionsResponse";
const _DST = "DeletionStartTime";
const _DSe = "DeletionSummary";
const _DSep = "DeploymentStatus";
const _DSes = "DescribeSessions";
const _DT = "DocumentType";
const _DTFMW = "DeregisterTargetFromMaintenanceWindow";
const _DTFMWR = "DeregisterTargetFromMaintenanceWindowRequest";
const _DTFMWRe = "DeregisterTargetFromMaintenanceWindowResult";
const _DTFMWRer = "DeregisterTaskFromMaintenanceWindowRequest";
const _DTFMWRere = "DeregisterTaskFromMaintenanceWindowResult";
const _DTFMWe = "DeregisterTaskFromMaintenanceWindow";
const _DTOC = "DeliveryTimedOutCount";
const _DTa = "DataType";
const _DTe = "DetailType";
const _DV = "DocumentVersion";
const _DVI = "DocumentVersionInfo";
const _DVL = "DocumentVersionList";
const _DVLE = "DocumentVersionLimitExceeded";
const _DVN = "DefaultVersionName";
const _DVe = "DefaultVersion";
const _DVef = "DefaultValue";
const _DVo = "DocumentVersions";
const _Da = "Date";
const _Dat = "Data";
const _De = "Details";
const _Det = "Detail";
const _Do = "Document";
const _Du = "Duration";
const _E = "Expired";
const _EA = "ExpiresAfter";
const _EAODS = "EnableAllOpsDataSources";
const _EAn = "EndedAt";
const _EAx = "ExcludeAccounts";
const _EB = "ExecutedBy";
const _EC = "ErrorCount";
const _ECr = "ErrorCode";
const _ED = "ExpirationDate";
const _EDn = "EndDate";
const _EDx = "ExecutionDate";
const _EEDT = "ExecutionEndDateTime";
const _EET = "ExecutionEndTime";
const _EETx = "ExecutionElapsedTime";
const _EI = "ExecutionId";
const _EIv = "EventId";
const _EIx = "ExecutionInputs";
const _ENS = "EnableNonSecurity";
const _EP = "EffectivePatches";
const _EPI = "ExecutionPreviewId";
const _EPL = "EffectivePatchList";
const _EPf = "EffectivePatch";
const _EPx = "ExecutionPreview";
const _ERN = "ExecutionRoleName";
const _ES = "ExecutionSummary";
const _ESDT = "ExecutionStartDateTime";
const _EST = "ExecutionStartTime";
const _ET = "ExecutionTime";
const _ETn = "EndTime";
const _ETx = "ExecutionType";
const _ETxp = "ExpirationTime";
const _En = "Entries";
const _Ena = "Enabled";
const _Ent = "Entry";
const _Enti = "Entities";
const _Entit = "Entity";
const _Ep = "Epoch";
const _Ex = "Expression";
const _F = "Failed";
const _FC = "FailedCount";
const _FCA = "FailedCreateAssociation";
const _FCAE = "FailedCreateAssociationEntry";
const _FCAL = "FailedCreateAssociationList";
const _FD = "FailureDetails";
const _FK = "FilterKey";
const _FM = "FailureMessage";
const _FNAE = "FeatureNotAvailableException";
const _FS = "FailureStage";
const _FSa = "FailedSteps";
const _FT = "FailureType";
const _FV = "FilterValues";
const _FVi = "FilterValue";
const _FWO = "FiltersWithOperator";
const _Fa = "Fault";
const _Fi = "Filters";
const _Fo = "Force";
const _G = "Groups";
const _GAE = "GetAutomationExecution";
const _GAER = "GetAutomationExecutionRequest";
const _GAERe = "GetAutomationExecutionResult";
const _GAT = "GetAccessToken";
const _GATR = "GetAccessTokenRequest";
const _GATRe = "GetAccessTokenResponse";
const _GCI = "GetCommandInvocation";
const _GCIR = "GetCommandInvocationRequest";
const _GCIRe = "GetCommandInvocationResult";
const _GCS = "GetCalendarState";
const _GCSR = "GetCalendarStateRequest";
const _GCSRe = "GetCalendarStateResponse";
const _GCSRet = "GetConnectionStatusRequest";
const _GCSReto = "GetConnectionStatusResponse";
const _GCSe = "GetConnectionStatus";
const _GD = "GetDocument";
const _GDPB = "GetDefaultPatchBaseline";
const _GDPBR = "GetDefaultPatchBaselineRequest";
const _GDPBRe = "GetDefaultPatchBaselineResult";
const _GDPSFI = "GetDeployablePatchSnapshotForInstance";
const _GDPSFIR = "GetDeployablePatchSnapshotForInstanceRequest";
const _GDPSFIRe = "GetDeployablePatchSnapshotForInstanceResult";
const _GDR = "GetDocumentRequest";
const _GDRe = "GetDocumentResult";
const _GEP = "GetExecutionPreview";
const _GEPR = "GetExecutionPreviewRequest";
const _GEPRe = "GetExecutionPreviewResponse";
const _GF = "GlobalFilters";
const _GI = "GetInventory";
const _GIR = "GetInventoryRequest";
const _GIRe = "GetInventoryResult";
const _GIS = "GetInventorySchema";
const _GISR = "GetInventorySchemaRequest";
const _GISRe = "GetInventorySchemaResult";
const _GMW = "GetMaintenanceWindow";
const _GMWE = "GetMaintenanceWindowExecution";
const _GMWER = "GetMaintenanceWindowExecutionRequest";
const _GMWERe = "GetMaintenanceWindowExecutionResult";
const _GMWET = "GetMaintenanceWindowExecutionTask";
const _GMWETI = "GetMaintenanceWindowExecutionTaskInvocation";
const _GMWETIR = "GetMaintenanceWindowExecutionTaskInvocationRequest";
const _GMWETIRe = "GetMaintenanceWindowExecutionTaskInvocationResult";
const _GMWETR = "GetMaintenanceWindowExecutionTaskRequest";
const _GMWETRe = "GetMaintenanceWindowExecutionTaskResult";
const _GMWR = "GetMaintenanceWindowRequest";
const _GMWRe = "GetMaintenanceWindowResult";
const _GMWT = "GetMaintenanceWindowTask";
const _GMWTR = "GetMaintenanceWindowTaskRequest";
const _GMWTRe = "GetMaintenanceWindowTaskResult";
const _GOI = "GetOpsItem";
const _GOIR = "GetOpsItemRequest";
const _GOIRe = "GetOpsItemResponse";
const _GOM = "GetOpsMetadata";
const _GOMR = "GetOpsMetadataRequest";
const _GOMRe = "GetOpsMetadataResult";
const _GOS = "GetOpsSummary";
const _GOSR = "GetOpsSummaryRequest";
const _GOSRe = "GetOpsSummaryResult";
const _GP = "GetParameter";
const _GPB = "GetPatchBaseline";
const _GPBFPG = "GetPatchBaselineForPatchGroup";
const _GPBFPGR = "GetPatchBaselineForPatchGroupRequest";
const _GPBFPGRe = "GetPatchBaselineForPatchGroupResult";
const _GPBP = "GetParametersByPath";
const _GPBPR = "GetParametersByPathRequest";
const _GPBPRe = "GetParametersByPathResult";
const _GPBR = "GetPatchBaselineRequest";
const _GPBRe = "GetPatchBaselineResult";
const _GPH = "GetParameterHistory";
const _GPHR = "GetParameterHistoryRequest";
const _GPHRe = "GetParameterHistoryResult";
const _GPR = "GetParameterRequest";
const _GPRe = "GetParameterResult";
const _GPRet = "GetParametersRequest";
const _GPReta = "GetParametersResult";
const _GPe = "GetParameters";
const _GRP = "GetResourcePolicies";
const _GRPR = "GetResourcePoliciesRequest";
const _GRPRE = "GetResourcePoliciesResponseEntry";
const _GRPREe = "GetResourcePoliciesResponseEntries";
const _GRPRe = "GetResourcePoliciesResponse";
const _GSS = "GetServiceSetting";
const _GSSR = "GetServiceSettingRequest";
const _GSSRe = "GetServiceSettingResult";
const _H = "Hash";
const _HC = "HighCount";
const _HLLEE = "HierarchyLevelLimitExceededException";
const _HT = "HashType";
const _HTME = "HierarchyTypeMismatchException";
const _I = "Id";
const _IA = "InstanceAssociation";
const _IAAO = "InstanceAggregatedAssociationOverview";
const _IAE = "InvalidAggregatorException";
const _IAEPE = "InvalidAutomationExecutionParametersException";
const _IAI = "InvalidActivationId";
const _IAL = "InstanceAssociationList";
const _IALn = "InventoryAggregatorList";
const _IAOL = "InstanceAssociationOutputLocation";
const _IAOU = "InstanceAssociationOutputUrl";
const _IAPE = "InvalidAllowedPatternException";
const _IASAC = "InstanceAssociationStatusAggregatedCount";
const _IASE = "InvalidAutomationSignalException";
const _IASI = "InstanceAssociationStatusInfos";
const _IASIn = "InstanceAssociationStatusInfo";
const _IASUE = "InvalidAutomationStatusUpdateException";
const _IAV = "InvalidAssociationVersion";
const _IAn = "InvalidActivation";
const _IAnv = "InvalidAssociation";
const _IAnve = "InventoryAggregator";
const _IAp = "IpAddress";
const _IC = "InstalledCount";
const _ICH = "ItemContentHash";
const _ICI = "InvalidCommandId";
const _ICME = "ItemContentMismatchException";
const _ICOU = "IncludeChildOrganizationUnits";
const _ICn = "InformationalCount";
const _ICs = "IsCritical";
const _ID = "InventoryDeletions";
const _IDC = "InvalidDocumentContent";
const _IDIE = "InvalidDeletionIdException";
const _IDIPE = "InvalidDeleteInventoryParametersException";
const _IDL = "InventoryDeletionsList";
const _IDNE = "InvocationDoesNotExist";
const _IDO = "InvalidDocumentOperation";
const _IDS = "InventoryDeletionSummary";
const _IDSI = "InventoryDeletionStatusItem";
const _IDSIn = "InventoryDeletionSummaryItem";
const _IDSInv = "InventoryDeletionSummaryItems";
const _IDSV = "InvalidDocumentSchemaVersion";
const _IDT = "InvalidDocumentType";
const _IDV = "IsDefaultVersion";
const _IDVn = "InvalidDocumentVersion";
const _IDn = "InvalidDocument";
const _IE = "IsEnd";
const _IF = "InvalidFilter";
const _IFK = "InvalidFilterKey";
const _IFL = "InventoryFilterList";
const _IFO = "InvalidFilterOption";
const _IFR = "IncludeFutureRegions";
const _IFV = "InvalidFilterValue";
const _IFVL = "InventoryFilterValueList";
const _IFn = "InventoryFilter";
const _IG = "InventoryGroup";
const _IGL = "InventoryGroupList";
const _II = "InstanceId";
const _IIA = "InventoryItemAttribute";
const _IIAL = "InventoryItemAttributeList";
const _IICE = "InvalidItemContentException";
const _IIEL = "InventoryItemEntryList";
const _IIF = "InstanceInformationFilter";
const _IIFL = "InstanceInformationFilterList";
const _IIFV = "InstanceInformationFilterValue";
const _IIFVS = "InstanceInformationFilterValueSet";
const _IIGE = "InvalidInventoryGroupException";
const _III = "InvalidInstanceId";
const _IIICE = "InvalidInventoryItemContextException";
const _IIIFV = "InvalidInstanceInformationFilterValue";
const _IIL = "InstanceInformationList";
const _IILn = "InventoryItemList";
const _IIPFV = "InvalidInstancePropertyFilterValue";
const _IIRE = "InvalidInventoryRequestException";
const _IIS = "InventoryItemSchema";
const _IISF = "InstanceInformationStringFilter";
const _IISFL = "InstanceInformationStringFilterList";
const _IISRL = "InventoryItemSchemaResultList";
const _IIn = "InstanceIds";
const _IIns = "InstanceInfo";
const _IInst = "InstanceInformation";
const _IInv = "InvocationId";
const _IInve = "InventoryItem";
const _IKI = "InvalidKeyId";
const _IL = "InvalidLabels";
const _ILV = "IsLatestVersion";
const _IN = "InstanceName";
const _INC = "InvalidNotificationConfig";
const _INT = "InvalidNextToken";
const _IOC = "InstalledOtherCount";
const _IOE = "InvalidOptionException";
const _IOF = "InvalidOutputFolder";
const _IOL = "InstallOverrideList";
const _IOLn = "InvalidOutputLocation";
const _IP = "InvalidParameters";
const _IPA = "IPAddress";
const _IPAE = "InvalidPolicyAttributeException";
const _IPAF = "IgnorePollAlarmFailure";
const _IPE = "IncompatiblePolicyException";
const _IPF = "InstancePropertyFilter";
const _IPFL = "InstancePropertyFilterList";
const _IPFV = "InstancePropertyFilterValue";
const _IPFVS = "InstancePropertyFilterValueSet";
const _IPM = "IdempotentParameterMismatch";
const _IPN = "InvalidPluginName";
const _IPRC = "InstalledPendingRebootCount";
const _IPS = "InstancePatchStates";
const _IPSF = "InstancePatchStateFilter";
const _IPSFL = "InstancePatchStateFilterList";
const _IPSFLn = "InstancePropertyStringFilterList";
const _IPSFn = "InstancePropertyStringFilter";
const _IPSL = "InstancePatchStateList";
const _IPSLn = "InstancePatchStatesList";
const _IPSn = "InstancePatchState";
const _IPT = "InvalidPermissionType";
const _IPTE = "InvalidPolicyTypeException";
const _IPn = "InstanceProperties";
const _IPns = "InstanceProperty";
const _IR = "IamRole";
const _IRAE = "InvalidResultAttributeException";
const _IRC = "InstalledRejectedCount";
const _IRE = "InventoryResultEntity";
const _IREL = "InventoryResultEntityList";
const _IRI = "InvalidResourceId";
const _IRIM = "InventoryResultItemMap";
const _IRIn = "InventoryResultItem";
const _IRT = "InvalidResourceType";
const _IRn = "InstanceRole";
const _IRnv = "InvalidRole";
const _IS = "InstanceStatus";
const _ISE = "InternalServerError";
const _ISLEE = "ItemSizeLimitExceededException";
const _ISn = "InstanceState";
const _ISnv = "InvalidSchedule";
const _IT = "InstanceType";
const _ITM = "InvalidTargetMaps";
const _ITNE = "InvalidTypeNameException";
const _ITn = "InvalidTag";
const _ITns = "InstalledTime";
const _ITnv = "InvalidTarget";
const _IU = "InvalidUpdate";
const _IV = "IteratorValue";
const _IWASU = "InstancesWithAvailableSecurityUpdates";
const _IWCNCP = "InstancesWithCriticalNonCompliantPatches";
const _IWFP = "InstancesWithFailedPatches";
const _IWIOP = "InstancesWithInstalledOtherPatches";
const _IWIP = "InstancesWithInstalledPatches";
const _IWIPRP = "InstancesWithInstalledPendingRebootPatches";
const _IWIRP = "InstancesWithInstalledRejectedPatches";
const _IWMP = "InstancesWithMissingPatches";
const _IWNAP = "InstancesWithNotApplicablePatches";
const _IWONCP = "InstancesWithOtherNonCompliantPatches";
const _IWSNCP = "InstancesWithSecurityNonCompliantPatches";
const _IWUNAP = "InstancesWithUnreportedNotApplicablePatches";
const _In = "Instances";
const _Inp = "Input";
const _Inpu = "Inputs";
const _Ins = "Instance";
const _It = "Iteration";
const _Ite = "Items";
const _Item = "Item";
const _K = "Key";
const _KBI = "KBId";
const _KI = "KeyId";
const _KN = "KeyName";
const _KNb = "KbNumber";
const _KTD = "KeysToDelete";
const _L = "Labels";
const _LA = "ListAssociations";
const _LAED = "LastAssociationExecutionDate";
const _LAR = "ListAssociationsRequest";
const _LARi = "ListAssociationsResult";
const _LAV = "ListAssociationVersions";
const _LAVR = "ListAssociationVersionsRequest";
const _LAVRi = "ListAssociationVersionsResult";
const _LC = "LowCount";
const _LCI = "ListCommandInvocations";
const _LCIR = "ListCommandInvocationsRequest";
const _LCIRi = "ListCommandInvocationsResult";
const _LCIRis = "ListComplianceItemsRequest";
const _LCIRist = "ListComplianceItemsResult";
const _LCIi = "ListComplianceItems";
const _LCR = "ListCommandsRequest";
const _LCRi = "ListCommandsResult";
const _LCS = "ListComplianceSummaries";
const _LCSR = "ListComplianceSummariesRequest";
const _LCSRi = "ListComplianceSummariesResult";
const _LCi = "ListCommands";
const _LD = "ListDocuments";
const _LDMH = "ListDocumentMetadataHistory";
const _LDMHR = "ListDocumentMetadataHistoryRequest";
const _LDMHRi = "ListDocumentMetadataHistoryResponse";
const _LDR = "ListDocumentsRequest";
const _LDRi = "ListDocumentsResult";
const _LDV = "ListDocumentVersions";
const _LDVR = "ListDocumentVersionsRequest";
const _LDVRi = "ListDocumentVersionsResult";
const _LED = "LastExecutionDate";
const _LF = "LogFile";
const _LI = "LoggingInfo";
const _LIE = "ListInventoryEntries";
const _LIER = "ListInventoryEntriesRequest";
const _LIERi = "ListInventoryEntriesResult";
const _LMB = "LastModifiedBy";
const _LMD = "LastModifiedDate";
const _LMT = "LastModifiedTime";
const _LMU = "LastModifiedUser";
const _LN = "ListNodes";
const _LNR = "ListNodesRequest";
const _LNRIOT = "LastNoRebootInstallOperationTime";
const _LNRi = "ListNodesResult";
const _LNS = "ListNodesSummary";
const _LNSR = "ListNodesSummaryRequest";
const _LNSRi = "ListNodesSummaryResult";
const _LOIE = "ListOpsItemEvents";
const _LOIER = "ListOpsItemEventsRequest";
const _LOIERi = "ListOpsItemEventsResponse";
const _LOIRI = "ListOpsItemRelatedItems";
const _LOIRIR = "ListOpsItemRelatedItemsRequest";
const _LOIRIRi = "ListOpsItemRelatedItemsResponse";
const _LOM = "ListOpsMetadata";
const _LOMR = "ListOpsMetadataRequest";
const _LOMRi = "ListOpsMetadataResult";
const _LPDT = "LastPingDateTime";
const _LPV = "LabelParameterVersion";
const _LPVR = "LabelParameterVersionRequest";
const _LPVRa = "LabelParameterVersionResult";
const _LRCS = "ListResourceComplianceSummaries";
const _LRCSR = "ListResourceComplianceSummariesRequest";
const _LRCSRi = "ListResourceComplianceSummariesResult";
const _LRDS = "ListResourceDataSync";
const _LRDSR = "ListResourceDataSyncRequest";
const _LRDSRi = "ListResourceDataSyncResult";
const _LS = "LastStatus";
const _LSAED = "LastSuccessfulAssociationExecutionDate";
const _LSED = "LastSuccessfulExecutionDate";
const _LSM = "LastStatusMessage";
const _LSSM = "LastSyncStatusMessage";
const _LSST = "LastSuccessfulSyncTime";
const _LST = "LastSyncTime";
const _LSUT = "LastStatusUpdateTime";
const _LT = "LaunchTime";
const _LTFR = "ListTagsForResource";
const _LTFRR = "ListTagsForResourceRequest";
const _LTFRRi = "ListTagsForResourceResult";
const _LTi = "LimitType";
const _LUAD = "LastUpdateAssociationDate";
const _LV = "LatestVersion";
const _La = "Lambda";
const _Lan = "Language";
const _Li = "Limit";
const _M = "Message";
const _MA = "MaxAttempts";
const _MC = "MaxConcurrency";
const _MCe = "MediumCount";
const _MCi = "MissingCount";
const _MD = "ModifiedDate";
const _MDP = "ModifyDocumentPermission";
const _MDPR = "ModifyDocumentPermissionRequest";
const _MDPRo = "ModifyDocumentPermissionResponse";
const _MDSE = "MaxDocumentSizeExceeded";
const _ME = "MaxErrors";
const _MM = "MetadataMap";
const _MN = "MsrcNumber";
const _MR = "MaxResults";
const _MRPDE = "MalformedResourcePolicyDocumentException";
const _MS = "ManagedStatus";
const _MSD = "MaxSessionDuration";
const _MSs = "MsrcSeverity";
const _MTU = "MetadataToUpdate";
const _MV = "MetadataValue";
const _MWAP = "MaintenanceWindowAutomationParameters";
const _MWD = "MaintenanceWindowDescription";
const _MWE = "MaintenanceWindowExecution";
const _MWEL = "MaintenanceWindowExecutionList";
const _MWETI = "MaintenanceWindowExecutionTaskIdentity";
const _MWETII = "MaintenanceWindowExecutionTaskInvocationIdentity";
const _MWETIIL = "MaintenanceWindowExecutionTaskInvocationIdentityList";
const _MWETIL = "MaintenanceWindowExecutionTaskIdentityList";
const _MWETIP = "MaintenanceWindowExecutionTaskInvocationParameters";
const _MWF = "MaintenanceWindowFilter";
const _MWFL = "MaintenanceWindowFilterList";
const _MWFTL = "MaintenanceWindowsForTargetList";
const _MWI = "MaintenanceWindowIdentity";
const _MWIFT = "MaintenanceWindowIdentityForTarget";
const _MWIL = "MaintenanceWindowIdentityList";
const _MWLP = "MaintenanceWindowLambdaPayload";
const _MWLPa = "MaintenanceWindowLambdaParameters";
const _MWRCP = "MaintenanceWindowRunCommandParameters";
const _MWSFI = "MaintenanceWindowStepFunctionsInput";
const _MWSFP = "MaintenanceWindowStepFunctionsParameters";
const _MWT = "MaintenanceWindowTarget";
const _MWTIP = "MaintenanceWindowTaskInvocationParameters";
const _MWTL = "MaintenanceWindowTargetList";
const _MWTLa = "MaintenanceWindowTaskList";
const _MWTP = "MaintenanceWindowTaskParameters";
const _MWTPL = "MaintenanceWindowTaskParametersList";
const _MWTPV = "MaintenanceWindowTaskParameterValue";
const _MWTPVE = "MaintenanceWindowTaskParameterValueExpression";
const _MWTPVL = "MaintenanceWindowTaskParameterValueList";
const _MWTa = "MaintenanceWindowTask";
const _Ma = "Mappings";
const _Me = "Metadata";
const _Mo = "Mode";
const _N = "Name";
const _NA = "NodeAggregator";
const _NAC = "NotApplicableCount";
const _NAL = "NodeAggregatorList";
const _NAo = "NotificationArn";
const _NC = "NotificationConfig";
const _NCC = "NonCompliantCount";
const _NCS = "NonCompliantSummary";
const _NE = "NotificationEvents";
const _NET = "NextExecutionTime";
const _NF = "NodeFilter";
const _NFL = "NodeFilterList";
const _NFVL = "NodeFilterValueList";
const _NL = "NodeList";
const _NLSE = "NoLongerSupportedException";
const _NOI = "NodeOwnerInfo";
const _NS = "NextStep";
const _NSL = "NodeSummaryList";
const _NT = "NextToken";
const _NTT = "NextTransitionTime";
const _NTo = "NodeType";
const _NTot = "NotificationType";
const _Na = "Names";
const _No = "Notifications";
const _Nod = "Nodes";
const _Node = "Node";
const _O = "Overview";
const _OA = "OpsAggregator";
const _OAL = "OpsAggregatorList";
const _OD = "OperationalData";
const _ODTD = "OperationalDataToDelete";
const _OE = "OpsEntity";
const _OEI = "OpsEntityItem";
const _OEIEL = "OpsEntityItemEntryList";
const _OEIM = "OpsEntityItemMap";
const _OEL = "OpsEntityList";
const _OET = "OperationEndTime";
const _OF = "OpsFilter";
const _OFL = "OpsFilterList";
const _OFVL = "OpsFilterValueList";
const _OFn = "OnFailure";
const _OI = "OwnerInformation";
const _OIA = "OpsItemArn";
const _OIADE = "OpsItemAccessDeniedException";
const _OIAEE = "OpsItemAlreadyExistsException";
const _OICE = "OpsItemConflictException";
const _OIDV = "OpsItemDataValue";
const _OIEF = "OpsItemEventFilter";
const _OIEFp = "OpsItemEventFilters";
const _OIES = "OpsItemEventSummary";
const _OIESp = "OpsItemEventSummaries";
const _OIF = "OpsItemFilters";
const _OIFp = "OpsItemFilter";
const _OII = "OpsItemId";
const _OIIPE = "OpsItemInvalidParameterException";
const _OIIp = "OpsItemIdentity";
const _OILEE = "OpsItemLimitExceededException";
const _OIN = "OpsItemNotification";
const _OINFE = "OpsItemNotFoundException";
const _OINp = "OpsItemNotifications";
const _OIOD = "OpsItemOperationalData";
const _OIRIAEE = "OpsItemRelatedItemAlreadyExistsException";
const _OIRIANFE = "OpsItemRelatedItemAssociationNotFoundException";
const _OIRIF = "OpsItemRelatedItemsFilter";
const _OIRIFp = "OpsItemRelatedItemsFilters";
const _OIRIS = "OpsItemRelatedItemSummary";
const _OIRISp = "OpsItemRelatedItemSummaries";
const _OIS = "OpsItemSummaries";
const _OISp = "OpsItemSummary";
const _OIT = "OpsItemType";
const _OIp = "OpsItem";
const _OL = "OutputLocation";
const _OM = "OpsMetadata";
const _OMA = "OpsMetadataArn";
const _OMAEE = "OpsMetadataAlreadyExistsException";
const _OMF = "OpsMetadataFilter";
const _OMFL = "OpsMetadataFilterList";
const _OMIAE = "OpsMetadataInvalidArgumentException";
const _OMKLEE = "OpsMetadataKeyLimitExceededException";
const _OML = "OpsMetadataList";
const _OMLEE = "OpsMetadataLimitExceededException";
const _OMNFE = "OpsMetadataNotFoundException";
const _OMTMUE = "OpsMetadataTooManyUpdatesException";
const _ONCC = "OtherNonCompliantCount";
const _OP = "OverriddenParameters";
const _ORA = "OpsResultAttribute";
const _ORAL = "OpsResultAttributeList";
const _OS = "OutputSource";
const _OSBN = "OutputS3BucketName";
const _OSI = "OutputSourceId";
const _OSKP = "OutputS3KeyPrefix";
const _OSR = "OutputS3Region";
const _OST = "OperationStartTime";
const _OSTr = "OrganizationSourceType";
const _OSTu = "OutputSourceType";
const _OSp = "OperatingSystem";
const _OSv = "OverallSeverity";
const _OU = "OutputUrl";
const _OUI = "OrganizationalUnitId";
const _OUP = "OrganizationalUnitPath";
const _OUr = "OrganizationalUnits";
const _Op = "Operation";
const _Ope = "Operator";
const _Opt = "Option";
const _Ou = "Outputs";
const _Out = "Output";
const _Ov = "Overwrite";
const _Ow = "Owner";
const _P = "Parameters";
const _PAE = "ParameterAlreadyExists";
const _PAEI = "ParentAutomationExecutionId";
const _PBI = "PatchBaselineIdentity";
const _PBIL = "PatchBaselineIdentityList";
const _PC = "ProgressCounters";
const _PCD = "PatchComplianceData";
const _PCDL = "PatchComplianceDataList";
const _PCI = "PutComplianceItems";
const _PCIR = "PutComplianceItemsRequest";
const _PCIRu = "PutComplianceItemsResult";
const _PET = "PlannedEndTime";
const _PF = "ParameterFilters";
const _PFG = "PatchFilterGroup";
const _PFL = "ParametersFilterList";
const _PFLa = "PatchFilterList";
const _PFa = "ParametersFilter";
const _PFat = "PatchFilter";
const _PFatc = "PatchFilters";
const _PFr = "ProductFamily";
const _PG = "PatchGroup";
const _PGPBM = "PatchGroupPatchBaselineMapping";
const _PGPBML = "PatchGroupPatchBaselineMappingList";
const _PGa = "PatchGroups";
const _PH = "PolicyHash";
const _PHL = "ParameterHistoryList";
const _PHa = "ParameterHistory";
const _PI = "PolicyId";
const _PIP = "ParameterInlinePolicy";
const _PIR = "PutInventoryRequest";
const _PIRu = "PutInventoryResult";
const _PIu = "PutInventory";
const _PL = "ParameterList";
const _PLE = "ParameterLimitExceeded";
const _PLEE = "PoliciesLimitExceededException";
const _PLa = "PatchList";
const _PM = "ParameterMetadata";
const _PML = "ParameterMetadataList";
const _PMVLE = "ParameterMaxVersionLimitExceeded";
const _PN = "PluginName";
const _PNF = "ParameterNotFound";
const _PNa = "ParameterNames";
const _PNl = "PlatformName";
const _POF = "PatchOrchestratorFilter";
const _POFL = "PatchOrchestratorFilterList";
const _PP = "PutParameter";
const _PPL = "PatchPropertiesList";
const _PPLa = "ParameterPolicyList";
const _PPME = "ParameterPatternMismatchException";
const _PPR = "PutParameterRequest";
const _PPRu = "PutParameterResult";
const _PR = "PatchRule";
const _PRG = "PatchRuleGroup";
const _PRL = "PatchRuleList";
const _PRP = "PutResourcePolicy";
const _PRPR = "PutResourcePolicyRequest";
const _PRPRu = "PutResourcePolicyResponse";
const _PRV = "PendingReviewVersion";
const _PRa = "PatchRules";
const _PS = "PatchSet";
const _PSC = "PatchSourceConfiguration";
const _PSD = "ParentStepDetails";
const _PSF = "ParameterStringFilter";
const _PSFL = "ParameterStringFilterList";
const _PSL = "PatchSourceList";
const _PSPV = "PSParameterValue";
const _PST = "PlannedStartTime";
const _PSa = "PatchStatus";
const _PSat = "PatchSource";
const _PSi = "PingStatus";
const _PSo = "PolicyStatus";
const _PT = "PermissionType";
const _PTL = "PlatformTypeList";
const _PTl = "PlatformTypes";
const _PTla = "PlatformType";
const _PTo = "PolicyText";
const _PTol = "PolicyType";
const _PV = "PlatformVersion";
const _PVLLE = "ParameterVersionLabelLimitExceeded";
const _PVNF = "ParameterVersionNotFound";
const _PVa = "ParameterVersion";
const _PVar = "ParameterValues";
const _Pa = "Patches";
const _Par = "Parameter";
const _Pat = "Patch";
const _Path = "Path";
const _Pay = "Payload";
const _Po = "Policies";
const _Pol = "Policy";
const _Pr = "Priority";
const _Pre = "Prefix";
const _Pro = "Property";
const _Prod = "Product";
const _Produ = "Products";
const _Prop = "Properties";
const _Q = "Qualifier";
const _QC = "QuotaCode";
const _R = "Runbooks";
const _RA = "ResourceArn";
const _RAL = "ResultAttributeList";
const _RAe = "ResultAttributes";
const _RAes = "ResultAttribute";
const _RC = "RegistrationsCount";
const _RCBS = "ResourceCountByStatus";
const _RCSI = "ResourceComplianceSummaryItems";
const _RCSIL = "ResourceComplianceSummaryItemList";
const _RCSIe = "ResourceComplianceSummaryItem";
const _RCe = "ResponseCode";
const _RCea = "ReasonCode";
const _RCem = "RemainingCount";
const _RCu = "RunCommand";
const _RD = "RegistrationDate";
const _RDPB = "RegisterDefaultPatchBaseline";
const _RDPBR = "RegisterDefaultPatchBaselineRequest";
const _RDPBRe = "RegisterDefaultPatchBaselineResult";
const _RDSAEE = "ResourceDataSyncAlreadyExistsException";
const _RDSAOS = "ResourceDataSyncAwsOrganizationsSource";
const _RDSCE = "ResourceDataSyncConflictException";
const _RDSCEE = "ResourceDataSyncCountExceededException";
const _RDSDDS = "ResourceDataSyncDestinationDataSharing";
const _RDSI = "ResourceDataSyncItems";
const _RDSICE = "ResourceDataSyncInvalidConfigurationException";
const _RDSIL = "ResourceDataSyncItemList";
const _RDSIe = "ResourceDataSyncItem";
const _RDSNFE = "ResourceDataSyncNotFoundException";
const _RDSOU = "ResourceDataSyncOrganizationalUnit";
const _RDSOUL = "ResourceDataSyncOrganizationalUnitList";
const _RDSS = "ResourceDataSyncSource";
const _RDSSD = "ResourceDataSyncS3Destination";
const _RDSSWS = "ResourceDataSyncSourceWithState";
const _RDT = "RequestedDateTime";
const _RDe = "ReleaseDate";
const _RFDT = "ResponseFinishDateTime";
const _RI = "ResourceId";
const _RIL = "ReviewInformationList";
const _RIUE = "ResourceInUseException";
const _RIe = "ReviewInformation";
const _RIes = "ResourceIds";
const _RL = "RegistrationLimit";
const _RLEE = "ResourceLimitExceededException";
const _RLe = "RemovedLabels";
const _RM = "RegistrationMetadata";
const _RMI = "RegistrationMetadataItem";
const _RML = "RegistrationMetadataList";
const _RNFE = "ResourceNotFoundException";
const _RO = "ReverseOrder";
const _ROI = "RelatedOpsItems";
const _ROIe = "RelatedOpsItem";
const _ROe = "RebootOption";
const _RP = "RejectedPatches";
const _RPA = "RejectedPatchesAction";
const _RPBFPG = "RegisterPatchBaselineForPatchGroup";
const _RPBFPGR = "RegisterPatchBaselineForPatchGroupRequest";
const _RPBFPGRe = "RegisterPatchBaselineForPatchGroupResult";
const _RPCE = "ResourcePolicyConflictException";
const _RPIPE = "ResourcePolicyInvalidParameterException";
const _RPLEE = "ResourcePolicyLimitExceededException";
const _RPNFE = "ResourcePolicyNotFoundException";
const _RR = "ReviewerResponse";
const _RS = "ReviewStatus";
const _RSDT = "ResponseStartDateTime";
const _RSR = "ResumeSessionRequest";
const _RSRe = "ResumeSessionResponse";
const _RSS = "ResetServiceSetting";
const _RSSR = "ResetServiceSettingRequest";
const _RSSRe = "ResetServiceSettingResult";
const _RSe = "ResumeSession";
const _RT = "ResourceType";
const _RTFR = "RemoveTagsFromResource";
const _RTFRR = "RemoveTagsFromResourceRequest";
const _RTFRRe = "RemoveTagsFromResourceResult";
const _RTWMW = "RegisterTargetWithMaintenanceWindow";
const _RTWMWR = "RegisterTargetWithMaintenanceWindowRequest";
const _RTWMWRe = "RegisterTargetWithMaintenanceWindowResult";
const _RTWMWReg = "RegisterTaskWithMaintenanceWindowRequest";
const _RTWMWRegi = "RegisterTaskWithMaintenanceWindowResult";
const _RTWMWe = "RegisterTaskWithMaintenanceWindow";
const _RTe = "ResolvedTargets";
const _RTeq = "RequireType";
const _RTes = "ResourceTypes";
const _RTev = "ReviewedTime";
const _RU = "ResourceUri";
const _Re = "Regions";
const _Rea = "Reason";
const _Rec = "Recursive";
const _Reg = "Region";
const _Rel = "Release";
const _Rep = "Repository";
const _Repl = "Replace";
const _Req = "Requires";
const _Res = "Response";
const _Rev = "Reviewer";
const _Ru = "Runbook";
const _S = "State";
const _SAE = "StartAutomationExecution";
const _SAER = "StartAutomationExecutionRequest";
const _SAERt = "StartAutomationExecutionResult";
const _SAERto = "StopAutomationExecutionRequest";
const _SAERtop = "StopAutomationExecutionResult";
const _SAEt = "StopAutomationExecution";
const _SAK = "SecretAccessKey";
const _SAO = "StartAssociationsOnce";
const _SAOR = "StartAssociationsOnceRequest";
const _SAORt = "StartAssociationsOnceResult";
const _SAR = "StartAccessRequest";
const _SARR = "StartAccessRequestRequest";
const _SARRt = "StartAccessRequestResponse";
const _SAS = "SendAutomationSignal";
const _SASR = "SendAutomationSignalRequest";
const _SASRe = "SendAutomationSignalResult";
const _SBN = "S3BucketName";
const _SC = "SyncCompliance";
const _SCR = "SendCommandRequest";
const _SCRE = "StartChangeRequestExecution";
const _SCRER = "StartChangeRequestExecutionRequest";
const _SCRERt = "StartChangeRequestExecutionResult";
const _SCRe = "SendCommandResult";
const _SCT = "SyncCreatedTime";
const _SCe = "ServiceCode";
const _SCen = "SendCommand";
const _SD = "StatusDetails";
const _SDO = "SchemaDeleteOption";
const _SDU = "SnapshotDownloadUrl";
const _SDV = "SharedDocumentVersion";
const _SDe = "S3Destination";
const _SDt = "StartDate";
const _SE = "ScheduleExpression";
const _SEC = "StandardErrorContent";
const _SEF = "StepExecutionFilter";
const _SEFL = "StepExecutionFilterList";
const _SEI = "StepExecutionId";
const _SEL = "StepExecutionList";
const _SEP = "StartExecutionPreview";
const _SEPR = "StartExecutionPreviewRequest";
const _SEPRt = "StartExecutionPreviewResponse";
const _SET = "StepExecutionsTruncated";
const _SETc = "ScheduledEndTime";
const _SEU = "StandardErrorUrl";
const _SEt = "StepExecutions";
const _SEte = "StepExecution";
const _SF = "StepFunctions";
const _SFL = "SessionFilterList";
const _SFe = "SessionFilter";
const _SFy = "SyncFormat";
const _SI = "StatusInformation";
const _SIe = "SettingId";
const _SIes = "SessionId";
const _SIn = "SnapshotId";
const _SIo = "SourceId";
const _SIu = "SummaryItems";
const _SKP = "S3KeyPrefix";
const _SL = "S3Location";
const _SLMT = "SyncLastModifiedTime";
const _SLe = "SessionList";
const _SM = "StatusMessage";
const _SMOU = "SessionManagerOutputUrl";
const _SMP = "SessionManagerParameters";
const _SN = "SyncName";
const _SNCC = "SecurityNonCompliantCount";
const _SNt = "StepName";
const _SO = "ScheduleOffset";
const _SOC = "StandardOutputContent";
const _SOL = "S3OutputLocation";
const _SOU = "StandardOutputUrl";
const _SOUu = "S3OutputUrl";
const _SP = "StepPreviews";
const _SQEE = "ServiceQuotaExceededException";
const _SR = "ServiceRole";
const _SRA = "ServiceRoleArn";
const _SRe = "S3Region";
const _SRo = "SourceResult";
const _SRou = "SourceRegions";
const _SS = "SeveritySummary";
const _SSNF = "ServiceSettingNotFound";
const _SSR = "StartSessionRequest";
const _SSRt = "StartSessionResponse";
const _SSe = "ServiceSetting";
const _SSt = "StepStatus";
const _SSta = "StartSession";
const _SSu = "SuccessSteps";
const _SSy = "SyncSource";
const _ST = "ScheduledTime";
const _STCLEE = "SubTypeCountLimitExceededException";
const _STT = "SessionTokenType";
const _STc = "ScheduleTimezone";
const _STe = "SessionToken";
const _STi = "SignalType";
const _STo = "SourceType";
const _STt = "StartTime";
const _STu = "SubType";
const _STy = "SyncType";
const _SU = "StreamUrl";
const _SUt = "StatusUnchanged";
const _SV = "SchemaVersion";
const _SVe = "SettingValue";
const _SWE = "ScheduledWindowExecutions";
const _SWEL = "ScheduledWindowExecutionList";
const _SWEc = "ScheduledWindowExecution";
const _Sa = "Safe";
const _Sc = "Schedule";
const _Sch = "Schemas";
const _Se = "Severity";
const _Sel = "Selector";
const _Ses = "Sessions";
const _Sess = "Session";
const _Sh = "Shared";
const _Sha = "Sha1";
const _Si = "Size";
const _So = "Sources";
const _Sou = "Source";
const _St = "Status";
const _Su = "Successful";
const _Sum = "Summary";
const _Summ = "Summaries";
const _T = "Tags";
const _TA = "TriggeredAlarms";
const _TAa = "TaskArn";
const _TAo = "TotalAccounts";
const _TC = "TargetCount";
const _TCo = "TotalCount";
const _TE = "ThrottlingException";
const _TEI = "TaskExecutionId";
const _TI = "TaskId";
const _TIP = "TaskInvocationParameters";
const _TIUE = "TargetInUseException";
const _TIa = "TaskIds";
const _TK = "TagKeys";
const _TL = "TargetLocations";
const _TLAC = "TargetLocationAlarmConfiguration";
const _TLMC = "TargetLocationMaxConcurrency";
const _TLME = "TargetLocationMaxErrors";
const _TLURL = "TargetLocationsURL";
const _TLa = "TagList";
const _TLar = "TargetLocation";
const _TM = "TargetMaps";
const _TMC = "TargetsMaxConcurrency";
const _TME = "TargetsMaxErrors";
const _TMTE = "TooManyTagsError";
const _TMU = "TooManyUpdates";
const _TMa = "TargetMap";
const _TN = "TypeName";
const _TNC = "TargetNotConnected";
const _TO = "TraceOutput";
const _TOS = "TimedOutSteps";
const _TP = "TargetPreviews";
const _TPL = "TargetPreviewList";
const _TPN = "TargetParameterName";
const _TPa = "TaskParameters";
const _TPar = "TargetPreview";
const _TS = "TimeoutSeconds";
const _TSLEE = "TotalSizeLimitExceededException";
const _TSR = "TerminateSessionRequest";
const _TSRe = "TerminateSessionResponse";
const _TSe = "TerminateSession";
const _TSo = "TotalSteps";
const _TT = "TargetType";
const _TTa = "TaskType";
const _TV = "TokenValue";
const _Ta = "Targets";
const _Tag = "Tag";
const _Tar = "Target";
const _Tas = "Tasks";
const _Ti = "Title";
const _Tie = "Tier";
const _Tr = "Truncated";
const _Ty = "Type";
const _U = "Url";
const _UA = "UpdateAssociation";
const _UAR = "UpdateAssociationRequest";
const _UARp = "UpdateAssociationResult";
const _UAS = "UpdateAssociationStatus";
const _UASR = "UpdateAssociationStatusRequest";
const _UASRp = "UpdateAssociationStatusResult";
const _UC = "UnspecifiedCount";
const _UCE = "UnsupportedCalendarException";
const _UD = "UpdateDocument";
const _UDDV = "UpdateDocumentDefaultVersion";
const _UDDVR = "UpdateDocumentDefaultVersionRequest";
const _UDDVRp = "UpdateDocumentDefaultVersionResult";
const _UDM = "UpdateDocumentMetadata";
const _UDMR = "UpdateDocumentMetadataRequest";
const _UDMRp = "UpdateDocumentMetadataResponse";
const _UDR = "UpdateDocumentRequest";
const _UDRp = "UpdateDocumentResult";
const _UFRE = "UnsupportedFeatureRequiredException";
const _UIICE = "UnsupportedInventoryItemContextException";
const _UISVE = "UnsupportedInventorySchemaVersionException";
const _UMIR = "UpdateManagedInstanceRole";
const _UMIRR = "UpdateManagedInstanceRoleRequest";
const _UMIRRp = "UpdateManagedInstanceRoleResult";
const _UMW = "UpdateMaintenanceWindow";
const _UMWR = "UpdateMaintenanceWindowRequest";
const _UMWRp = "UpdateMaintenanceWindowResult";
const _UMWT = "UpdateMaintenanceWindowTarget";
const _UMWTR = "UpdateMaintenanceWindowTargetRequest";
const _UMWTRp = "UpdateMaintenanceWindowTargetResult";
const _UMWTRpd = "UpdateMaintenanceWindowTaskRequest";
const _UMWTRpda = "UpdateMaintenanceWindowTaskResult";
const _UMWTp = "UpdateMaintenanceWindowTask";
const _UNAC = "UnreportedNotApplicableCount";
const _UOE = "UnsupportedOperationException";
const _UOI = "UpdateOpsItem";
const _UOIR = "UpdateOpsItemRequest";
const _UOIRp = "UpdateOpsItemResponse";
const _UOM = "UpdateOpsMetadata";
const _UOMR = "UpdateOpsMetadataRequest";
const _UOMRp = "UpdateOpsMetadataResult";
const _UOS = "UnsupportedOperatingSystem";
const _UPB = "UpdatePatchBaseline";
const _UPBR = "UpdatePatchBaselineRequest";
const _UPBRp = "UpdatePatchBaselineResult";
const _UPT = "UnsupportedParameterType";
const _UPTn = "UnsupportedPlatformType";
const _UPV = "UnlabelParameterVersion";
const _UPVR = "UnlabelParameterVersionRequest";
const _UPVRn = "UnlabelParameterVersionResult";
const _URDS = "UpdateResourceDataSync";
const _URDSR = "UpdateResourceDataSyncRequest";
const _URDSRp = "UpdateResourceDataSyncResult";
const _USDSE = "UseS3DualStackEndpoint";
const _USS = "UpdateServiceSetting";
const _USSR = "UpdateServiceSettingRequest";
const _USSRp = "UpdateServiceSettingResult";
const _UT = "UpdatedTime";
const _UTp = "UploadType";
const _V = "Value";
const _VE = "ValidationException";
const _VN = "VersionName";
const _VNS = "ValidNextSteps";
const _Va = "Values";
const _Var = "Variables";
const _Ve = "Version";
const _Ven = "Vendor";
const _WD = "WithDecryption";
const _WE = "WindowExecutions";
const _WEI = "WindowExecutionId";
const _WETI = "WindowExecutionTaskIdentities";
const _WETII = "WindowExecutionTaskInvocationIdentities";
const _WI = "WindowId";
const _WIi = "WindowIdentities";
const _WTI = "WindowTargetId";
const _WTIi = "WindowTaskId";
const _aQE = "awsQueryError";
const _c = "client";
const _e = "error";
const _en = "entries";
const _k = "key";
const _m = "message";
const _s = "server";
const _sm = "smithy.ts.sdk.synthetic.com.amazonaws.ssm";
const _v = "value";
const _vS = "valueSet";
const _xN = "xmlName";
const n0 = "com.amazonaws.ssm";
var AccessKeySecretType = [0, n0, _AKST, 8, 0];
var IPAddress = [0, n0, _IPA, 8, 0];
var MaintenanceWindowDescription = [0, n0, _MWD, 8, 0];
var MaintenanceWindowExecutionTaskInvocationParameters = [0, n0, _MWETIP, 8, 0];
var MaintenanceWindowLambdaPayload = [0, n0, _MWLP, 8, 21];
var MaintenanceWindowStepFunctionsInput = [0, n0, _MWSFI, 8, 0];
var MaintenanceWindowTaskParameterValue = [0, n0, _MWTPV, 8, 0];
var OwnerInformation = [0, n0, _OI, 8, 0];
var PatchSourceConfiguration = [0, n0, _PSC, 8, 0];
var PSParameterValue = [0, n0, _PSPV, 8, 0];
var SessionTokenType = [0, n0, _STT, 8, 0];
var AccessDeniedException$ = [-3, n0, _ADE,
    { [_e]: _c },
    [_M],
    [0], 1
];
schema.TypeRegistry.for(n0).registerError(AccessDeniedException$, AccessDeniedException);
var AccountSharingInfo$ = [3, n0, _ASI,
    0,
    [_AI, _SDV],
    [0, 0]
];
var Activation$ = [3, n0, _A,
    0,
    [_AIc, _D, _DIN, _IR, _RL, _RC, _ED, _E, _CD, _T],
    [0, 0, 0, 0, 1, 1, 4, 2, 4, () => TagList]
];
var AddTagsToResourceRequest$ = [3, n0, _ATTRR,
    0,
    [_RT, _RI, _T],
    [0, 0, () => TagList], 3
];
var AddTagsToResourceResult$ = [3, n0, _ATTRRd,
    0,
    [],
    []
];
var Alarm$ = [3, n0, _Al,
    0,
    [_N],
    [0], 1
];
var AlarmConfiguration$ = [3, n0, _AC,
    0,
    [_Ala, _IPAF],
    [() => AlarmList, 2], 1
];
var AlarmStateInformation$ = [3, n0, _ASIl,
    0,
    [_N, _S],
    [0, 0], 2
];
var AlreadyExistsException$ = [-3, n0, _AEE,
    { [_aQE]: [`AlreadyExistsException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AlreadyExistsException$, AlreadyExistsException);
var AssociatedInstances$ = [-3, n0, _AIs,
    { [_aQE]: [`AssociatedInstances`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(AssociatedInstances$, AssociatedInstances);
var AssociateOpsItemRelatedItemRequest$ = [3, n0, _AOIRIR,
    0,
    [_OII, _AT, _RT, _RU],
    [0, 0, 0, 0], 4
];
var AssociateOpsItemRelatedItemResponse$ = [3, n0, _AOIRIRs,
    0,
    [_AIss],
    [0]
];
var Association$ = [3, n0, _As,
    0,
    [_N, _II, _AIss, _AV, _DV, _Ta, _LED, _O, _SE, _AN, _SO, _Du, _TM],
    [0, 0, 0, 0, 0, () => Targets, 4, () => AssociationOverview$, 0, 0, 1, 1, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]]]
];
var AssociationAlreadyExists$ = [-3, n0, _AAE,
    { [_aQE]: [`AssociationAlreadyExists`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(AssociationAlreadyExists$, AssociationAlreadyExists);
var AssociationDescription$ = [3, n0, _AD,
    0,
    [_N, _II, _AV, _Da, _LUAD, _St, _O, _DV, _ATPN, _P, _AIss, _Ta, _SE, _OL, _LED, _LSED, _AN, _ME, _MC, _CS, _SC, _AOACI, _CN, _TL, _SO, _Du, _TM, _AC, _TA],
    [0, 0, 0, 4, 4, () => AssociationStatus$, () => AssociationOverview$, 0, 0, [() => _Parameters, 0], 0, () => Targets, 0, () => InstanceAssociationOutputLocation$, 4, 4, 0, 0, 0, 0, 0, 2, 64 | 0, () => TargetLocations, 1, 1, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], () => AlarmConfiguration$, () => AlarmStateInformationList]
];
var AssociationDoesNotExist$ = [-3, n0, _ADNE,
    { [_aQE]: [`AssociationDoesNotExist`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AssociationDoesNotExist$, AssociationDoesNotExist);
var AssociationExecution$ = [3, n0, _AE,
    0,
    [_AIss, _AV, _EI, _St, _DS, _CT, _LED, _RCBS, _AC, _TA],
    [0, 0, 0, 0, 0, 4, 4, 0, () => AlarmConfiguration$, () => AlarmStateInformationList]
];
var AssociationExecutionDoesNotExist$ = [-3, n0, _AEDNE,
    { [_aQE]: [`AssociationExecutionDoesNotExist`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AssociationExecutionDoesNotExist$, AssociationExecutionDoesNotExist);
var AssociationExecutionFilter$ = [3, n0, _AEF,
    0,
    [_K, _V, _Ty],
    [0, 0, 0], 3
];
var AssociationExecutionTarget$ = [3, n0, _AET,
    0,
    [_AIss, _AV, _EI, _RI, _RT, _St, _DS, _LED, _OS],
    [0, 0, 0, 0, 0, 0, 0, 4, () => OutputSource$]
];
var AssociationExecutionTargetsFilter$ = [3, n0, _AETF,
    0,
    [_K, _V],
    [0, 0], 2
];
var AssociationFilter$ = [3, n0, _AF,
    0,
    [_k, _v],
    [0, 0], 2
];
var AssociationLimitExceeded$ = [-3, n0, _ALE,
    { [_aQE]: [`AssociationLimitExceeded`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(AssociationLimitExceeded$, AssociationLimitExceeded);
var AssociationOverview$ = [3, n0, _AO,
    0,
    [_St, _DS, _ASAC],
    [0, 0, 128 | 1]
];
var AssociationStatus$ = [3, n0, _AS,
    0,
    [_Da, _N, _M, _AId],
    [4, 0, 0, 0], 3
];
var AssociationVersionInfo$ = [3, n0, _AVI,
    0,
    [_AIss, _AV, _CD, _N, _DV, _P, _Ta, _SE, _OL, _AN, _ME, _MC, _CS, _SC, _AOACI, _CN, _TL, _SO, _Du, _TM],
    [0, 0, 4, 0, 0, [() => _Parameters, 0], () => Targets, 0, () => InstanceAssociationOutputLocation$, 0, 0, 0, 0, 0, 2, 64 | 0, () => TargetLocations, 1, 1, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]]]
];
var AssociationVersionLimitExceeded$ = [-3, n0, _AVLE,
    { [_aQE]: [`AssociationVersionLimitExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AssociationVersionLimitExceeded$, AssociationVersionLimitExceeded);
var AttachmentContent$ = [3, n0, _ACt,
    0,
    [_N, _Si, _H, _HT, _U],
    [0, 1, 0, 0, 0]
];
var AttachmentInformation$ = [3, n0, _AIt,
    0,
    [_N],
    [0]
];
var AttachmentsSource$ = [3, n0, _ASt,
    0,
    [_K, _Va, _N],
    [0, 64 | 0, 0]
];
var AutomationDefinitionNotApprovedException$ = [-3, n0, _ADNAE,
    { [_aQE]: [`AutomationDefinitionNotApproved`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AutomationDefinitionNotApprovedException$, AutomationDefinitionNotApprovedException);
var AutomationDefinitionNotFoundException$ = [-3, n0, _ADNFE,
    { [_aQE]: [`AutomationDefinitionNotFound`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AutomationDefinitionNotFoundException$, AutomationDefinitionNotFoundException);
var AutomationDefinitionVersionNotFoundException$ = [-3, n0, _ADVNFE,
    { [_aQE]: [`AutomationDefinitionVersionNotFound`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AutomationDefinitionVersionNotFoundException$, AutomationDefinitionVersionNotFoundException);
var AutomationExecution$ = [3, n0, _AEu,
    0,
    [_AEI, _DN, _DV, _EST, _EET, _AES, _SEt, _SET, _P, _Ou, _FM, _Mo, _PAEI, _EB, _CSN, _CA, _TPN, _Ta, _TM, _RTe, _MC, _ME, _Tar, _TL, _PC, _AC, _TA, _TLURL, _ASu, _ST, _R, _OII, _AIss, _CRN, _Var],
    [0, 0, 0, 4, 4, 0, () => StepExecutionList, 2, [2, n0, _APM, 0, 0, 64 | 0], [2, n0, _APM, 0, 0, 64 | 0], 0, 0, 0, 0, 0, 0, 0, () => Targets, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], () => ResolvedTargets$, 0, 0, 0, () => TargetLocations, () => ProgressCounters$, () => AlarmConfiguration$, () => AlarmStateInformationList, 0, 0, 4, () => Runbooks, 0, 0, 0, [2, n0, _APM, 0, 0, 64 | 0]]
];
var AutomationExecutionFilter$ = [3, n0, _AEFu,
    0,
    [_K, _Va],
    [0, 64 | 0], 2
];
var AutomationExecutionInputs$ = [3, n0, _AEIu,
    0,
    [_P, _TPN, _Ta, _TM, _TL, _TLURL],
    [[2, n0, _APM, 0, 0, 64 | 0], 0, () => Targets, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], () => TargetLocations, 0]
];
var AutomationExecutionLimitExceededException$ = [-3, n0, _AELEE,
    { [_aQE]: [`AutomationExecutionLimitExceeded`, 429], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AutomationExecutionLimitExceededException$, AutomationExecutionLimitExceededException);
var AutomationExecutionMetadata$ = [3, n0, _AEM,
    0,
    [_AEI, _DN, _DV, _AES, _EST, _EET, _EB, _LF, _Ou, _Mo, _PAEI, _CSN, _CA, _FM, _TPN, _Ta, _TM, _RTe, _MC, _ME, _Tar, _ATu, _AC, _TA, _TLURL, _ASu, _ST, _R, _OII, _AIss, _CRN],
    [0, 0, 0, 0, 4, 4, 0, 0, [2, n0, _APM, 0, 0, 64 | 0], 0, 0, 0, 0, 0, 0, () => Targets, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], () => ResolvedTargets$, 0, 0, 0, 0, () => AlarmConfiguration$, () => AlarmStateInformationList, 0, 0, 4, () => Runbooks, 0, 0, 0]
];
var AutomationExecutionNotFoundException$ = [-3, n0, _AENFE,
    { [_aQE]: [`AutomationExecutionNotFound`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AutomationExecutionNotFoundException$, AutomationExecutionNotFoundException);
var AutomationExecutionPreview$ = [3, n0, _AEP,
    0,
    [_SP, _Re, _TP, _TAo],
    [128 | 1, 64 | 0, () => TargetPreviewList, 1]
];
var AutomationStepNotFoundException$ = [-3, n0, _ASNFE,
    { [_aQE]: [`AutomationStepNotFoundException`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(AutomationStepNotFoundException$, AutomationStepNotFoundException);
var BaselineOverride$ = [3, n0, _BO,
    0,
    [_OSp, _GF, _AR, _AP, _APCL, _RP, _RPA, _APENS, _So, _ASUCS],
    [0, () => PatchFilterGroup$, () => PatchRuleGroup$, 64 | 0, 0, 64 | 0, 0, 2, [() => PatchSourceList, 0], 0]
];
var CancelCommandRequest$ = [3, n0, _CCR,
    0,
    [_CI, _IIn],
    [0, 64 | 0], 1
];
var CancelCommandResult$ = [3, n0, _CCRa,
    0,
    [],
    []
];
var CancelMaintenanceWindowExecutionRequest$ = [3, n0, _CMWER,
    0,
    [_WEI],
    [0], 1
];
var CancelMaintenanceWindowExecutionResult$ = [3, n0, _CMWERa,
    0,
    [_WEI],
    [0]
];
var CloudWatchOutputConfig$ = [3, n0, _CWOC,
    0,
    [_CWLGN, _CWOE],
    [0, 2]
];
var Command$ = [3, n0, _C,
    0,
    [_CI, _DN, _DV, _Co, _EA, _P, _IIn, _Ta, _RDT, _St, _SD, _OSR, _OSBN, _OSKP, _MC, _ME, _TC, _CC, _EC, _DTOC, _SR, _NC, _CWOC, _TS, _AC, _TA],
    [0, 0, 0, 0, 4, [() => _Parameters, 0], 64 | 0, () => Targets, 4, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, () => NotificationConfig$, () => CloudWatchOutputConfig$, 1, () => AlarmConfiguration$, () => AlarmStateInformationList]
];
var CommandFilter$ = [3, n0, _CF,
    0,
    [_k, _v],
    [0, 0], 2
];
var CommandInvocation$ = [3, n0, _CIo,
    0,
    [_CI, _II, _IN, _Co, _DN, _DV, _RDT, _St, _SD, _TO, _SOU, _SEU, _CP, _SR, _NC, _CWOC],
    [0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, () => CommandPluginList, 0, () => NotificationConfig$, () => CloudWatchOutputConfig$]
];
var CommandPlugin$ = [3, n0, _CPo,
    0,
    [_N, _St, _SD, _RCe, _RSDT, _RFDT, _Out, _SOU, _SEU, _OSR, _OSBN, _OSKP],
    [0, 0, 0, 1, 4, 4, 0, 0, 0, 0, 0, 0]
];
var ComplianceExecutionSummary$ = [3, n0, _CES,
    0,
    [_ET, _EI, _ETx],
    [4, 0, 0], 1
];
var ComplianceItem$ = [3, n0, _CIom,
    0,
    [_CTo, _RT, _RI, _I, _Ti, _St, _Se, _ES, _De],
    [0, 0, 0, 0, 0, 0, 0, () => ComplianceExecutionSummary$, 128 | 0]
];
var ComplianceItemEntry$ = [3, n0, _CIE,
    0,
    [_Se, _St, _I, _Ti, _De],
    [0, 0, 0, 0, 128 | 0], 2
];
var ComplianceStringFilter$ = [3, n0, _CSF,
    0,
    [_K, _Va, _Ty],
    [0, [() => ComplianceStringFilterValueList, 0], 0]
];
var ComplianceSummaryItem$ = [3, n0, _CSI,
    0,
    [_CTo, _CSo, _NCS],
    [0, () => CompliantSummary$, () => NonCompliantSummary$]
];
var ComplianceTypeCountLimitExceededException$ = [-3, n0, _CTCLEE,
    { [_aQE]: [`ComplianceTypeCountLimitExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ComplianceTypeCountLimitExceededException$, ComplianceTypeCountLimitExceededException);
var CompliantSummary$ = [3, n0, _CSo,
    0,
    [_CCo, _SS],
    [1, () => SeveritySummary$]
];
var CreateActivationRequest$ = [3, n0, _CAR,
    0,
    [_IR, _D, _DIN, _RL, _ED, _T, _RM],
    [0, 0, 0, 1, 4, () => TagList, () => RegistrationMetadataList], 1
];
var CreateActivationResult$ = [3, n0, _CARr,
    0,
    [_AIc, _ACc],
    [0, 0]
];
var CreateAssociationBatchRequest$ = [3, n0, _CABR,
    0,
    [_En],
    [[() => CreateAssociationBatchRequestEntries, 0]], 1
];
var CreateAssociationBatchRequestEntry$ = [3, n0, _CABRE,
    0,
    [_N, _II, _P, _ATPN, _DV, _Ta, _SE, _OL, _AN, _ME, _MC, _CS, _SC, _AOACI, _CN, _TL, _SO, _Du, _TM, _AC],
    [0, 0, [() => _Parameters, 0], 0, 0, () => Targets, 0, () => InstanceAssociationOutputLocation$, 0, 0, 0, 0, 0, 2, 64 | 0, () => TargetLocations, 1, 1, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], () => AlarmConfiguration$], 1
];
var CreateAssociationBatchResult$ = [3, n0, _CABRr,
    0,
    [_Su, _F],
    [[() => AssociationDescriptionList, 0], [() => FailedCreateAssociationList, 0]]
];
var CreateAssociationRequest$ = [3, n0, _CARre,
    0,
    [_N, _DV, _II, _P, _Ta, _SE, _OL, _AN, _ATPN, _ME, _MC, _CS, _SC, _AOACI, _CN, _TL, _SO, _Du, _TM, _T, _AC],
    [0, 0, 0, [() => _Parameters, 0], () => Targets, 0, () => InstanceAssociationOutputLocation$, 0, 0, 0, 0, 0, 0, 2, 64 | 0, () => TargetLocations, 1, 1, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], () => TagList, () => AlarmConfiguration$], 1
];
var CreateAssociationResult$ = [3, n0, _CARrea,
    0,
    [_AD],
    [[() => AssociationDescription$, 0]]
];
var CreateDocumentRequest$ = [3, n0, _CDR,
    0,
    [_Con, _N, _Req, _At, _DNi, _VN, _DT, _DF, _TT, _T],
    [0, 0, () => DocumentRequiresList, () => AttachmentsSourceList, 0, 0, 0, 0, 0, () => TagList], 2
];
var CreateDocumentResult$ = [3, n0, _CDRr,
    0,
    [_DD],
    [[() => DocumentDescription$, 0]]
];
var CreateMaintenanceWindowRequest$ = [3, n0, _CMWR,
    0,
    [_N, _Sc, _Du, _Cu, _AUT, _D, _SDt, _EDn, _STc, _SO, _CTl, _T],
    [0, 0, 1, 1, 2, [() => MaintenanceWindowDescription, 0], 0, 0, 0, 1, [0, 4], () => TagList], 5
];
var CreateMaintenanceWindowResult$ = [3, n0, _CMWRr,
    0,
    [_WI],
    [0]
];
var CreateOpsItemRequest$ = [3, n0, _COIR,
    0,
    [_D, _Sou, _Ti, _OIT, _OD, _No, _Pr, _ROI, _T, _Ca, _Se, _AST, _AETc, _PST, _PET, _AI],
    [0, 0, 0, 0, () => OpsItemOperationalData, () => OpsItemNotifications, 1, () => RelatedOpsItems, () => TagList, 0, 0, 4, 4, 4, 4, 0], 3
];
var CreateOpsItemResponse$ = [3, n0, _COIRr,
    0,
    [_OII, _OIA],
    [0, 0]
];
var CreateOpsMetadataRequest$ = [3, n0, _COMR,
    0,
    [_RI, _Me, _T],
    [0, () => MetadataMap, () => TagList], 1
];
var CreateOpsMetadataResult$ = [3, n0, _COMRr,
    0,
    [_OMA],
    [0]
];
var CreatePatchBaselineRequest$ = [3, n0, _CPBR,
    0,
    [_N, _OSp, _GF, _AR, _AP, _APCL, _APENS, _RP, _RPA, _D, _So, _ASUCS, _CTl, _T],
    [0, 0, () => PatchFilterGroup$, () => PatchRuleGroup$, 64 | 0, 0, 2, 64 | 0, 0, 0, [() => PatchSourceList, 0], 0, [0, 4], () => TagList], 1
];
var CreatePatchBaselineResult$ = [3, n0, _CPBRr,
    0,
    [_BI],
    [0]
];
var CreateResourceDataSyncRequest$ = [3, n0, _CRDSR,
    0,
    [_SN, _SDe, _STy, _SSy],
    [0, () => ResourceDataSyncS3Destination$, 0, () => ResourceDataSyncSource$], 1
];
var CreateResourceDataSyncResult$ = [3, n0, _CRDSRr,
    0,
    [],
    []
];
var Credentials$ = [3, n0, _Cr,
    0,
    [_AKI, _SAK, _STe, _ETxp],
    [0, [() => AccessKeySecretType, 0], [() => SessionTokenType, 0], 4], 4
];
var CustomSchemaCountLimitExceededException$ = [-3, n0, _CSCLEE,
    { [_aQE]: [`CustomSchemaCountLimitExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(CustomSchemaCountLimitExceededException$, CustomSchemaCountLimitExceededException);
var DeleteActivationRequest$ = [3, n0, _DAR,
    0,
    [_AIc],
    [0], 1
];
var DeleteActivationResult$ = [3, n0, _DARe,
    0,
    [],
    []
];
var DeleteAssociationRequest$ = [3, n0, _DARel,
    0,
    [_N, _II, _AIss],
    [0, 0, 0]
];
var DeleteAssociationResult$ = [3, n0, _DARele,
    0,
    [],
    []
];
var DeleteDocumentRequest$ = [3, n0, _DDR,
    0,
    [_N, _DV, _VN, _Fo],
    [0, 0, 0, 2], 1
];
var DeleteDocumentResult$ = [3, n0, _DDRe,
    0,
    [],
    []
];
var DeleteInventoryRequest$ = [3, n0, _DIR,
    0,
    [_TN, _SDO, _DR, _CTl],
    [0, 0, 2, [0, 4]], 1
];
var DeleteInventoryResult$ = [3, n0, _DIRe,
    0,
    [_DI, _TN, _DSe],
    [0, 0, () => InventoryDeletionSummary$]
];
var DeleteMaintenanceWindowRequest$ = [3, n0, _DMWR,
    0,
    [_WI],
    [0], 1
];
var DeleteMaintenanceWindowResult$ = [3, n0, _DMWRe,
    0,
    [_WI],
    [0]
];
var DeleteOpsItemRequest$ = [3, n0, _DOIR,
    0,
    [_OII],
    [0], 1
];
var DeleteOpsItemResponse$ = [3, n0, _DOIRe,
    0,
    [],
    []
];
var DeleteOpsMetadataRequest$ = [3, n0, _DOMR,
    0,
    [_OMA],
    [0], 1
];
var DeleteOpsMetadataResult$ = [3, n0, _DOMRe,
    0,
    [],
    []
];
var DeleteParameterRequest$ = [3, n0, _DPR,
    0,
    [_N],
    [0], 1
];
var DeleteParameterResult$ = [3, n0, _DPRe,
    0,
    [],
    []
];
var DeleteParametersRequest$ = [3, n0, _DPRel,
    0,
    [_Na],
    [64 | 0], 1
];
var DeleteParametersResult$ = [3, n0, _DPRele,
    0,
    [_DP, _IP],
    [64 | 0, 64 | 0]
];
var DeletePatchBaselineRequest$ = [3, n0, _DPBR,
    0,
    [_BI],
    [0], 1
];
var DeletePatchBaselineResult$ = [3, n0, _DPBRe,
    0,
    [_BI],
    [0]
];
var DeleteResourceDataSyncRequest$ = [3, n0, _DRDSR,
    0,
    [_SN, _STy],
    [0, 0], 1
];
var DeleteResourceDataSyncResult$ = [3, n0, _DRDSRe,
    0,
    [],
    []
];
var DeleteResourcePolicyRequest$ = [3, n0, _DRPR,
    0,
    [_RA, _PI, _PH],
    [0, 0, 0], 3
];
var DeleteResourcePolicyResponse$ = [3, n0, _DRPRe,
    0,
    [],
    []
];
var DeregisterManagedInstanceRequest$ = [3, n0, _DMIR,
    0,
    [_II],
    [0], 1
];
var DeregisterManagedInstanceResult$ = [3, n0, _DMIRe,
    0,
    [],
    []
];
var DeregisterPatchBaselineForPatchGroupRequest$ = [3, n0, _DPBFPGR,
    0,
    [_BI, _PG],
    [0, 0], 2
];
var DeregisterPatchBaselineForPatchGroupResult$ = [3, n0, _DPBFPGRe,
    0,
    [_BI, _PG],
    [0, 0]
];
var DeregisterTargetFromMaintenanceWindowRequest$ = [3, n0, _DTFMWR,
    0,
    [_WI, _WTI, _Sa],
    [0, 0, 2], 2
];
var DeregisterTargetFromMaintenanceWindowResult$ = [3, n0, _DTFMWRe,
    0,
    [_WI, _WTI],
    [0, 0]
];
var DeregisterTaskFromMaintenanceWindowRequest$ = [3, n0, _DTFMWRer,
    0,
    [_WI, _WTIi],
    [0, 0], 2
];
var DeregisterTaskFromMaintenanceWindowResult$ = [3, n0, _DTFMWRere,
    0,
    [_WI, _WTIi],
    [0, 0]
];
var DescribeActivationsFilter$ = [3, n0, _DAF,
    0,
    [_FK, _FV],
    [0, 64 | 0]
];
var DescribeActivationsRequest$ = [3, n0, _DARes,
    0,
    [_Fi, _MR, _NT],
    [() => DescribeActivationsFilterList, 1, 0]
];
var DescribeActivationsResult$ = [3, n0, _DAResc,
    0,
    [_AL, _NT],
    [() => ActivationList, 0]
];
var DescribeAssociationExecutionsRequest$ = [3, n0, _DAER,
    0,
    [_AIss, _Fi, _MR, _NT],
    [0, [() => AssociationExecutionFilterList, 0], 1, 0], 1
];
var DescribeAssociationExecutionsResult$ = [3, n0, _DAERe,
    0,
    [_AEs, _NT],
    [[() => AssociationExecutionsList, 0], 0]
];
var DescribeAssociationExecutionTargetsRequest$ = [3, n0, _DAETR,
    0,
    [_AIss, _EI, _Fi, _MR, _NT],
    [0, 0, [() => AssociationExecutionTargetsFilterList, 0], 1, 0], 2
];
var DescribeAssociationExecutionTargetsResult$ = [3, n0, _DAETRe,
    0,
    [_AETs, _NT],
    [[() => AssociationExecutionTargetsList, 0], 0]
];
var DescribeAssociationRequest$ = [3, n0, _DARescr,
    0,
    [_N, _II, _AIss, _AV],
    [0, 0, 0, 0]
];
var DescribeAssociationResult$ = [3, n0, _DARescri,
    0,
    [_AD],
    [[() => AssociationDescription$, 0]]
];
var DescribeAutomationExecutionsRequest$ = [3, n0, _DAERes,
    0,
    [_Fi, _MR, _NT],
    [() => AutomationExecutionFilterList, 1, 0]
];
var DescribeAutomationExecutionsResult$ = [3, n0, _DAEResc,
    0,
    [_AEML, _NT],
    [() => AutomationExecutionMetadataList, 0]
];
var DescribeAutomationStepExecutionsRequest$ = [3, n0, _DASER,
    0,
    [_AEI, _Fi, _NT, _MR, _RO],
    [0, () => StepExecutionFilterList, 0, 1, 2], 1
];
var DescribeAutomationStepExecutionsResult$ = [3, n0, _DASERe,
    0,
    [_SEt, _NT],
    [() => StepExecutionList, 0]
];
var DescribeAvailablePatchesRequest$ = [3, n0, _DAPR,
    0,
    [_Fi, _MR, _NT],
    [() => PatchOrchestratorFilterList, 1, 0]
];
var DescribeAvailablePatchesResult$ = [3, n0, _DAPRe,
    0,
    [_Pa, _NT],
    [() => PatchList, 0]
];
var DescribeDocumentPermissionRequest$ = [3, n0, _DDPR,
    0,
    [_N, _PT, _MR, _NT],
    [0, 0, 1, 0], 2
];
var DescribeDocumentPermissionResponse$ = [3, n0, _DDPRe,
    0,
    [_AIcc, _ASIL, _NT],
    [[() => AccountIdList, 0], [() => AccountSharingInfoList, 0], 0]
];
var DescribeDocumentRequest$ = [3, n0, _DDRes,
    0,
    [_N, _DV, _VN],
    [0, 0, 0], 1
];
var DescribeDocumentResult$ = [3, n0, _DDResc,
    0,
    [_Do],
    [[() => DocumentDescription$, 0]]
];
var DescribeEffectiveInstanceAssociationsRequest$ = [3, n0, _DEIAR,
    0,
    [_II, _MR, _NT],
    [0, 1, 0], 1
];
var DescribeEffectiveInstanceAssociationsResult$ = [3, n0, _DEIARe,
    0,
    [_Ass, _NT],
    [() => InstanceAssociationList, 0]
];
var DescribeEffectivePatchesForPatchBaselineRequest$ = [3, n0, _DEPFPBR,
    0,
    [_BI, _MR, _NT],
    [0, 1, 0], 1
];
var DescribeEffectivePatchesForPatchBaselineResult$ = [3, n0, _DEPFPBRe,
    0,
    [_EP, _NT],
    [() => EffectivePatchList, 0]
];
var DescribeInstanceAssociationsStatusRequest$ = [3, n0, _DIASR,
    0,
    [_II, _MR, _NT],
    [0, 1, 0], 1
];
var DescribeInstanceAssociationsStatusResult$ = [3, n0, _DIASRe,
    0,
    [_IASI, _NT],
    [() => InstanceAssociationStatusInfos, 0]
];
var DescribeInstanceInformationRequest$ = [3, n0, _DIIR,
    0,
    [_IIFL, _Fi, _MR, _NT],
    [[() => InstanceInformationFilterList, 0], [() => InstanceInformationStringFilterList, 0], 1, 0]
];
var DescribeInstanceInformationResult$ = [3, n0, _DIIRe,
    0,
    [_IIL, _NT],
    [[() => InstanceInformationList, 0], 0]
];
var DescribeInstancePatchesRequest$ = [3, n0, _DIPR,
    0,
    [_II, _Fi, _NT, _MR],
    [0, () => PatchOrchestratorFilterList, 0, 1], 1
];
var DescribeInstancePatchesResult$ = [3, n0, _DIPRe,
    0,
    [_Pa, _NT],
    [() => PatchComplianceDataList, 0]
];
var DescribeInstancePatchStatesForPatchGroupRequest$ = [3, n0, _DIPSFPGR,
    0,
    [_PG, _Fi, _NT, _MR],
    [0, () => InstancePatchStateFilterList, 0, 1], 1
];
var DescribeInstancePatchStatesForPatchGroupResult$ = [3, n0, _DIPSFPGRe,
    0,
    [_IPS, _NT],
    [[() => InstancePatchStatesList, 0], 0]
];
var DescribeInstancePatchStatesRequest$ = [3, n0, _DIPSR,
    0,
    [_IIn, _NT, _MR],
    [64 | 0, 0, 1], 1
];
var DescribeInstancePatchStatesResult$ = [3, n0, _DIPSRe,
    0,
    [_IPS, _NT],
    [[() => InstancePatchStateList, 0], 0]
];
var DescribeInstancePropertiesRequest$ = [3, n0, _DIPRes,
    0,
    [_IPFL, _FWO, _MR, _NT],
    [[() => InstancePropertyFilterList, 0], [() => InstancePropertyStringFilterList, 0], 1, 0]
];
var DescribeInstancePropertiesResult$ = [3, n0, _DIPResc,
    0,
    [_IPn, _NT],
    [[() => InstanceProperties, 0], 0]
];
var DescribeInventoryDeletionsRequest$ = [3, n0, _DIDR,
    0,
    [_DI, _NT, _MR],
    [0, 0, 1]
];
var DescribeInventoryDeletionsResult$ = [3, n0, _DIDRe,
    0,
    [_ID, _NT],
    [() => InventoryDeletionsList, 0]
];
var DescribeMaintenanceWindowExecutionsRequest$ = [3, n0, _DMWER,
    0,
    [_WI, _Fi, _MR, _NT],
    [0, () => MaintenanceWindowFilterList, 1, 0], 1
];
var DescribeMaintenanceWindowExecutionsResult$ = [3, n0, _DMWERe,
    0,
    [_WE, _NT],
    [() => MaintenanceWindowExecutionList, 0]
];
var DescribeMaintenanceWindowExecutionTaskInvocationsRequest$ = [3, n0, _DMWETIR,
    0,
    [_WEI, _TI, _Fi, _MR, _NT],
    [0, 0, () => MaintenanceWindowFilterList, 1, 0], 2
];
var DescribeMaintenanceWindowExecutionTaskInvocationsResult$ = [3, n0, _DMWETIRe,
    0,
    [_WETII, _NT],
    [[() => MaintenanceWindowExecutionTaskInvocationIdentityList, 0], 0]
];
var DescribeMaintenanceWindowExecutionTasksRequest$ = [3, n0, _DMWETR,
    0,
    [_WEI, _Fi, _MR, _NT],
    [0, () => MaintenanceWindowFilterList, 1, 0], 1
];
var DescribeMaintenanceWindowExecutionTasksResult$ = [3, n0, _DMWETRe,
    0,
    [_WETI, _NT],
    [() => MaintenanceWindowExecutionTaskIdentityList, 0]
];
var DescribeMaintenanceWindowScheduleRequest$ = [3, n0, _DMWSR,
    0,
    [_WI, _Ta, _RT, _Fi, _MR, _NT],
    [0, () => Targets, 0, () => PatchOrchestratorFilterList, 1, 0]
];
var DescribeMaintenanceWindowScheduleResult$ = [3, n0, _DMWSRe,
    0,
    [_SWE, _NT],
    [() => ScheduledWindowExecutionList, 0]
];
var DescribeMaintenanceWindowsForTargetRequest$ = [3, n0, _DMWFTR,
    0,
    [_Ta, _RT, _MR, _NT],
    [() => Targets, 0, 1, 0], 2
];
var DescribeMaintenanceWindowsForTargetResult$ = [3, n0, _DMWFTRe,
    0,
    [_WIi, _NT],
    [() => MaintenanceWindowsForTargetList, 0]
];
var DescribeMaintenanceWindowsRequest$ = [3, n0, _DMWRes,
    0,
    [_Fi, _MR, _NT],
    [() => MaintenanceWindowFilterList, 1, 0]
];
var DescribeMaintenanceWindowsResult$ = [3, n0, _DMWResc,
    0,
    [_WIi, _NT],
    [[() => MaintenanceWindowIdentityList, 0], 0]
];
var DescribeMaintenanceWindowTargetsRequest$ = [3, n0, _DMWTR,
    0,
    [_WI, _Fi, _MR, _NT],
    [0, () => MaintenanceWindowFilterList, 1, 0], 1
];
var DescribeMaintenanceWindowTargetsResult$ = [3, n0, _DMWTRe,
    0,
    [_Ta, _NT],
    [[() => MaintenanceWindowTargetList, 0], 0]
];
var DescribeMaintenanceWindowTasksRequest$ = [3, n0, _DMWTRes,
    0,
    [_WI, _Fi, _MR, _NT],
    [0, () => MaintenanceWindowFilterList, 1, 0], 1
];
var DescribeMaintenanceWindowTasksResult$ = [3, n0, _DMWTResc,
    0,
    [_Tas, _NT],
    [[() => MaintenanceWindowTaskList, 0], 0]
];
var DescribeOpsItemsRequest$ = [3, n0, _DOIRes,
    0,
    [_OIF, _MR, _NT],
    [() => OpsItemFilters, 1, 0]
];
var DescribeOpsItemsResponse$ = [3, n0, _DOIResc,
    0,
    [_NT, _OIS],
    [0, () => OpsItemSummaries]
];
var DescribeParametersRequest$ = [3, n0, _DPRes,
    0,
    [_Fi, _PF, _MR, _NT, _Sh],
    [() => ParametersFilterList, () => ParameterStringFilterList, 1, 0, 2]
];
var DescribeParametersResult$ = [3, n0, _DPResc,
    0,
    [_P, _NT],
    [() => ParameterMetadataList, 0]
];
var DescribePatchBaselinesRequest$ = [3, n0, _DPBRes,
    0,
    [_Fi, _MR, _NT],
    [() => PatchOrchestratorFilterList, 1, 0]
];
var DescribePatchBaselinesResult$ = [3, n0, _DPBResc,
    0,
    [_BIa, _NT],
    [() => PatchBaselineIdentityList, 0]
];
var DescribePatchGroupsRequest$ = [3, n0, _DPGR,
    0,
    [_MR, _Fi, _NT],
    [1, () => PatchOrchestratorFilterList, 0]
];
var DescribePatchGroupsResult$ = [3, n0, _DPGRe,
    0,
    [_Ma, _NT],
    [() => PatchGroupPatchBaselineMappingList, 0]
];
var DescribePatchGroupStateRequest$ = [3, n0, _DPGSR,
    0,
    [_PG],
    [0], 1
];
var DescribePatchGroupStateResult$ = [3, n0, _DPGSRe,
    0,
    [_In, _IWIP, _IWIOP, _IWIPRP, _IWIRP, _IWMP, _IWFP, _IWNAP, _IWUNAP, _IWCNCP, _IWSNCP, _IWONCP, _IWASU],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
];
var DescribePatchPropertiesRequest$ = [3, n0, _DPPR,
    0,
    [_OSp, _Pro, _PS, _MR, _NT],
    [0, 0, 0, 1, 0], 2
];
var DescribePatchPropertiesResult$ = [3, n0, _DPPRe,
    0,
    [_Prop, _NT],
    [[1, n0, _PPL, 0, 128 | 0], 0]
];
var DescribeSessionsRequest$ = [3, n0, _DSR,
    0,
    [_S, _MR, _NT, _Fi],
    [0, 1, 0, () => SessionFilterList], 1
];
var DescribeSessionsResponse$ = [3, n0, _DSRe,
    0,
    [_Ses, _NT],
    [() => SessionList, 0]
];
var DisassociateOpsItemRelatedItemRequest$ = [3, n0, _DOIRIR,
    0,
    [_OII, _AIss],
    [0, 0], 2
];
var DisassociateOpsItemRelatedItemResponse$ = [3, n0, _DOIRIRi,
    0,
    [],
    []
];
var DocumentAlreadyExists$ = [-3, n0, _DAE,
    { [_aQE]: [`DocumentAlreadyExists`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(DocumentAlreadyExists$, DocumentAlreadyExists);
var DocumentDefaultVersionDescription$ = [3, n0, _DDVD,
    0,
    [_N, _DVe, _DVN],
    [0, 0, 0]
];
var DocumentDescription$ = [3, n0, _DD,
    0,
    [_Sha, _H, _HT, _N, _DNi, _VN, _Ow, _CD, _St, _SI, _DV, _D, _P, _PTl, _DT, _SV, _LV, _DVe, _DF, _TT, _T, _AItt, _Req, _Au, _RIe, _AVp, _PRV, _RS, _Ca, _CE],
    [0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, [() => DocumentParameterList, 0], [() => PlatformTypeList, 0], 0, 0, 0, 0, 0, 0, () => TagList, [() => AttachmentInformationList, 0], () => DocumentRequiresList, 0, [() => ReviewInformationList, 0], 0, 0, 0, 64 | 0, 64 | 0]
];
var DocumentFilter$ = [3, n0, _DFo,
    0,
    [_k, _v],
    [0, 0], 2
];
var DocumentIdentifier$ = [3, n0, _DIo,
    0,
    [_N, _CD, _DNi, _Ow, _VN, _PTl, _DV, _DT, _SV, _DF, _TT, _T, _Req, _RS, _Au],
    [0, 4, 0, 0, 0, [() => PlatformTypeList, 0], 0, 0, 0, 0, 0, () => TagList, () => DocumentRequiresList, 0, 0]
];
var DocumentKeyValuesFilter$ = [3, n0, _DKVF,
    0,
    [_K, _Va],
    [0, 64 | 0]
];
var DocumentLimitExceeded$ = [-3, n0, _DLE,
    { [_aQE]: [`DocumentLimitExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(DocumentLimitExceeded$, DocumentLimitExceeded);
var DocumentMetadataResponseInfo$ = [3, n0, _DMRI,
    0,
    [_RR],
    [() => DocumentReviewerResponseList]
];
var DocumentParameter$ = [3, n0, _DPo,
    0,
    [_N, _Ty, _D, _DVef],
    [0, 0, 0, 0]
];
var DocumentPermissionLimit$ = [-3, n0, _DPL,
    { [_aQE]: [`DocumentPermissionLimit`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(DocumentPermissionLimit$, DocumentPermissionLimit);
var DocumentRequires$ = [3, n0, _DRo,
    0,
    [_N, _Ve, _RTeq, _VN],
    [0, 0, 0, 0], 1
];
var DocumentReviewCommentSource$ = [3, n0, _DRCS,
    0,
    [_Ty, _Con],
    [0, 0]
];
var DocumentReviewerResponseSource$ = [3, n0, _DRRS,
    0,
    [_CTr, _UT, _RS, _Co, _Rev],
    [4, 4, 0, () => DocumentReviewCommentList, 0]
];
var DocumentReviews$ = [3, n0, _DRoc,
    0,
    [_Ac, _Co],
    [0, () => DocumentReviewCommentList], 1
];
var DocumentVersionInfo$ = [3, n0, _DVI,
    0,
    [_N, _DNi, _DV, _VN, _CD, _IDV, _DF, _St, _SI, _RS],
    [0, 0, 0, 0, 4, 2, 0, 0, 0, 0]
];
var DocumentVersionLimitExceeded$ = [-3, n0, _DVLE,
    { [_aQE]: [`DocumentVersionLimitExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(DocumentVersionLimitExceeded$, DocumentVersionLimitExceeded);
var DoesNotExistException$ = [-3, n0, _DNEE,
    { [_aQE]: [`DoesNotExistException`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(DoesNotExistException$, DoesNotExistException);
var DuplicateDocumentContent$ = [-3, n0, _DDC,
    { [_aQE]: [`DuplicateDocumentContent`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(DuplicateDocumentContent$, DuplicateDocumentContent);
var DuplicateDocumentVersionName$ = [-3, n0, _DDVN,
    { [_aQE]: [`DuplicateDocumentVersionName`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(DuplicateDocumentVersionName$, DuplicateDocumentVersionName);
var DuplicateInstanceId$ = [-3, n0, _DII,
    { [_aQE]: [`DuplicateInstanceId`, 404], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(DuplicateInstanceId$, DuplicateInstanceId);
var EffectivePatch$ = [3, n0, _EPf,
    0,
    [_Pat, _PSa],
    [() => Patch$, () => PatchStatus$]
];
var FailedCreateAssociation$ = [3, n0, _FCA,
    0,
    [_Ent, _M, _Fa],
    [[() => CreateAssociationBatchRequestEntry$, 0], 0, 0]
];
var FailureDetails$ = [3, n0, _FD,
    0,
    [_FS, _FT, _De],
    [0, 0, [2, n0, _APM, 0, 0, 64 | 0]]
];
var FeatureNotAvailableException$ = [-3, n0, _FNAE,
    { [_aQE]: [`FeatureNotAvailableException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(FeatureNotAvailableException$, FeatureNotAvailableException);
var GetAccessTokenRequest$ = [3, n0, _GATR,
    0,
    [_ARI],
    [0], 1
];
var GetAccessTokenResponse$ = [3, n0, _GATRe,
    0,
    [_Cr, _ARS],
    [[() => Credentials$, 0], 0]
];
var GetAutomationExecutionRequest$ = [3, n0, _GAER,
    0,
    [_AEI],
    [0], 1
];
var GetAutomationExecutionResult$ = [3, n0, _GAERe,
    0,
    [_AEu],
    [() => AutomationExecution$]
];
var GetCalendarStateRequest$ = [3, n0, _GCSR,
    0,
    [_CN, _ATt],
    [64 | 0, 0], 1
];
var GetCalendarStateResponse$ = [3, n0, _GCSRe,
    0,
    [_S, _ATt, _NTT],
    [0, 0, 0]
];
var GetCommandInvocationRequest$ = [3, n0, _GCIR,
    0,
    [_CI, _II, _PN],
    [0, 0, 0], 2
];
var GetCommandInvocationResult$ = [3, n0, _GCIRe,
    0,
    [_CI, _II, _Co, _DN, _DV, _PN, _RCe, _ESDT, _EETx, _EEDT, _St, _SD, _SOC, _SOU, _SEC, _SEU, _CWOC],
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, () => CloudWatchOutputConfig$]
];
var GetConnectionStatusRequest$ = [3, n0, _GCSRet,
    0,
    [_Tar],
    [0], 1
];
var GetConnectionStatusResponse$ = [3, n0, _GCSReto,
    0,
    [_Tar, _St],
    [0, 0]
];
var GetDefaultPatchBaselineRequest$ = [3, n0, _GDPBR,
    0,
    [_OSp],
    [0]
];
var GetDefaultPatchBaselineResult$ = [3, n0, _GDPBRe,
    0,
    [_BI, _OSp],
    [0, 0]
];
var GetDeployablePatchSnapshotForInstanceRequest$ = [3, n0, _GDPSFIR,
    0,
    [_II, _SIn, _BO, _USDSE],
    [0, 0, [() => BaselineOverride$, 0], 2], 2
];
var GetDeployablePatchSnapshotForInstanceResult$ = [3, n0, _GDPSFIRe,
    0,
    [_II, _SIn, _SDU, _Prod],
    [0, 0, 0, 0]
];
var GetDocumentRequest$ = [3, n0, _GDR,
    0,
    [_N, _VN, _DV, _DF],
    [0, 0, 0, 0], 1
];
var GetDocumentResult$ = [3, n0, _GDRe,
    0,
    [_N, _CD, _DNi, _VN, _DV, _St, _SI, _Con, _DT, _DF, _Req, _ACtt, _RS],
    [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, () => DocumentRequiresList, [() => AttachmentContentList, 0], 0]
];
var GetExecutionPreviewRequest$ = [3, n0, _GEPR,
    0,
    [_EPI],
    [0], 1
];
var GetExecutionPreviewResponse$ = [3, n0, _GEPRe,
    0,
    [_EPI, _EAn, _St, _SM, _EPx],
    [0, 4, 0, 0, () => ExecutionPreview$]
];
var GetInventoryRequest$ = [3, n0, _GIR,
    0,
    [_Fi, _Ag, _RAe, _NT, _MR],
    [[() => InventoryFilterList, 0], [() => InventoryAggregatorList, 0], [() => ResultAttributeList, 0], 0, 1]
];
var GetInventoryResult$ = [3, n0, _GIRe,
    0,
    [_Enti, _NT],
    [[() => InventoryResultEntityList, 0], 0]
];
var GetInventorySchemaRequest$ = [3, n0, _GISR,
    0,
    [_TN, _NT, _MR, _Agg, _STu],
    [0, 0, 1, 2, 2]
];
var GetInventorySchemaResult$ = [3, n0, _GISRe,
    0,
    [_Sch, _NT],
    [[() => InventoryItemSchemaResultList, 0], 0]
];
var GetMaintenanceWindowExecutionRequest$ = [3, n0, _GMWER,
    0,
    [_WEI],
    [0], 1
];
var GetMaintenanceWindowExecutionResult$ = [3, n0, _GMWERe,
    0,
    [_WEI, _TIa, _St, _SD, _STt, _ETn],
    [0, 64 | 0, 0, 0, 4, 4]
];
var GetMaintenanceWindowExecutionTaskInvocationRequest$ = [3, n0, _GMWETIR,
    0,
    [_WEI, _TI, _IInv],
    [0, 0, 0], 3
];
var GetMaintenanceWindowExecutionTaskInvocationResult$ = [3, n0, _GMWETIRe,
    0,
    [_WEI, _TEI, _IInv, _EI, _TTa, _P, _St, _SD, _STt, _ETn, _OI, _WTI],
    [0, 0, 0, 0, 0, [() => MaintenanceWindowExecutionTaskInvocationParameters, 0], 0, 0, 4, 4, [() => OwnerInformation, 0], 0]
];
var GetMaintenanceWindowExecutionTaskRequest$ = [3, n0, _GMWETR,
    0,
    [_WEI, _TI],
    [0, 0], 2
];
var GetMaintenanceWindowExecutionTaskResult$ = [3, n0, _GMWETRe,
    0,
    [_WEI, _TEI, _TAa, _SR, _Ty, _TPa, _Pr, _MC, _ME, _St, _SD, _STt, _ETn, _AC, _TA],
    [0, 0, 0, 0, 0, [() => MaintenanceWindowTaskParametersList, 0], 1, 0, 0, 0, 0, 4, 4, () => AlarmConfiguration$, () => AlarmStateInformationList]
];
var GetMaintenanceWindowRequest$ = [3, n0, _GMWR,
    0,
    [_WI],
    [0], 1
];
var GetMaintenanceWindowResult$ = [3, n0, _GMWRe,
    0,
    [_WI, _N, _D, _SDt, _EDn, _Sc, _STc, _SO, _NET, _Du, _Cu, _AUT, _Ena, _CD, _MD],
    [0, 0, [() => MaintenanceWindowDescription, 0], 0, 0, 0, 0, 1, 0, 1, 1, 2, 2, 4, 4]
];
var GetMaintenanceWindowTaskRequest$ = [3, n0, _GMWTR,
    0,
    [_WI, _WTIi],
    [0, 0], 2
];
var GetMaintenanceWindowTaskResult$ = [3, n0, _GMWTRe,
    0,
    [_WI, _WTIi, _Ta, _TAa, _SRA, _TTa, _TPa, _TIP, _Pr, _MC, _ME, _LI, _N, _D, _CB, _AC],
    [0, 0, () => Targets, 0, 0, 0, [() => MaintenanceWindowTaskParameters, 0], [() => MaintenanceWindowTaskInvocationParameters$, 0], 1, 0, 0, () => LoggingInfo$, 0, [() => MaintenanceWindowDescription, 0], 0, () => AlarmConfiguration$]
];
var GetOpsItemRequest$ = [3, n0, _GOIR,
    0,
    [_OII, _OIA],
    [0, 0], 1
];
var GetOpsItemResponse$ = [3, n0, _GOIRe,
    0,
    [_OIp],
    [() => OpsItem$]
];
var GetOpsMetadataRequest$ = [3, n0, _GOMR,
    0,
    [_OMA, _MR, _NT],
    [0, 1, 0], 1
];
var GetOpsMetadataResult$ = [3, n0, _GOMRe,
    0,
    [_RI, _Me, _NT],
    [0, () => MetadataMap, 0]
];
var GetOpsSummaryRequest$ = [3, n0, _GOSR,
    0,
    [_SN, _Fi, _Ag, _RAe, _NT, _MR],
    [0, [() => OpsFilterList, 0], [() => OpsAggregatorList, 0], [() => OpsResultAttributeList, 0], 0, 1]
];
var GetOpsSummaryResult$ = [3, n0, _GOSRe,
    0,
    [_Enti, _NT],
    [[() => OpsEntityList, 0], 0]
];
var GetParameterHistoryRequest$ = [3, n0, _GPHR,
    0,
    [_N, _WD, _MR, _NT],
    [0, 2, 1, 0], 1
];
var GetParameterHistoryResult$ = [3, n0, _GPHRe,
    0,
    [_P, _NT],
    [[() => ParameterHistoryList, 0], 0]
];
var GetParameterRequest$ = [3, n0, _GPR,
    0,
    [_N, _WD],
    [0, 2], 1
];
var GetParameterResult$ = [3, n0, _GPRe,
    0,
    [_Par],
    [[() => Parameter$, 0]]
];
var GetParametersByPathRequest$ = [3, n0, _GPBPR,
    0,
    [_Path, _Rec, _PF, _WD, _MR, _NT],
    [0, 2, () => ParameterStringFilterList, 2, 1, 0], 1
];
var GetParametersByPathResult$ = [3, n0, _GPBPRe,
    0,
    [_P, _NT],
    [[() => ParameterList, 0], 0]
];
var GetParametersRequest$ = [3, n0, _GPRet,
    0,
    [_Na, _WD],
    [64 | 0, 2], 1
];
var GetParametersResult$ = [3, n0, _GPReta,
    0,
    [_P, _IP],
    [[() => ParameterList, 0], 64 | 0]
];
var GetPatchBaselineForPatchGroupRequest$ = [3, n0, _GPBFPGR,
    0,
    [_PG, _OSp],
    [0, 0], 1
];
var GetPatchBaselineForPatchGroupResult$ = [3, n0, _GPBFPGRe,
    0,
    [_BI, _PG, _OSp],
    [0, 0, 0]
];
var GetPatchBaselineRequest$ = [3, n0, _GPBR,
    0,
    [_BI],
    [0], 1
];
var GetPatchBaselineResult$ = [3, n0, _GPBRe,
    0,
    [_BI, _N, _OSp, _GF, _AR, _AP, _APCL, _APENS, _RP, _RPA, _PGa, _CD, _MD, _D, _So, _ASUCS],
    [0, 0, 0, () => PatchFilterGroup$, () => PatchRuleGroup$, 64 | 0, 0, 2, 64 | 0, 0, 64 | 0, 4, 4, 0, [() => PatchSourceList, 0], 0]
];
var GetResourcePoliciesRequest$ = [3, n0, _GRPR,
    0,
    [_RA, _NT, _MR],
    [0, 0, 1], 1
];
var GetResourcePoliciesResponse$ = [3, n0, _GRPRe,
    0,
    [_NT, _Po],
    [0, () => GetResourcePoliciesResponseEntries]
];
var GetResourcePoliciesResponseEntry$ = [3, n0, _GRPRE,
    0,
    [_PI, _PH, _Pol],
    [0, 0, 0]
];
var GetServiceSettingRequest$ = [3, n0, _GSSR,
    0,
    [_SIe],
    [0], 1
];
var GetServiceSettingResult$ = [3, n0, _GSSRe,
    0,
    [_SSe],
    [() => ServiceSetting$]
];
var HierarchyLevelLimitExceededException$ = [-3, n0, _HLLEE,
    { [_aQE]: [`HierarchyLevelLimitExceededException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(HierarchyLevelLimitExceededException$, HierarchyLevelLimitExceededException);
var HierarchyTypeMismatchException$ = [-3, n0, _HTME,
    { [_aQE]: [`HierarchyTypeMismatchException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(HierarchyTypeMismatchException$, HierarchyTypeMismatchException);
var IdempotentParameterMismatch$ = [-3, n0, _IPM,
    { [_aQE]: [`IdempotentParameterMismatch`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(IdempotentParameterMismatch$, IdempotentParameterMismatch);
var IncompatiblePolicyException$ = [-3, n0, _IPE,
    { [_aQE]: [`IncompatiblePolicyException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(IncompatiblePolicyException$, IncompatiblePolicyException);
var InstanceAggregatedAssociationOverview$ = [3, n0, _IAAO,
    0,
    [_DS, _IASAC],
    [0, 128 | 1]
];
var InstanceAssociation$ = [3, n0, _IA,
    0,
    [_AIss, _II, _Con, _AV],
    [0, 0, 0, 0]
];
var InstanceAssociationOutputLocation$ = [3, n0, _IAOL,
    0,
    [_SL],
    [() => S3OutputLocation$]
];
var InstanceAssociationOutputUrl$ = [3, n0, _IAOU,
    0,
    [_SOUu],
    [() => S3OutputUrl$]
];
var InstanceAssociationStatusInfo$ = [3, n0, _IASIn,
    0,
    [_AIss, _N, _DV, _AV, _II, _EDx, _St, _DS, _ES, _ECr, _OU, _AN],
    [0, 0, 0, 0, 0, 4, 0, 0, 0, 0, () => InstanceAssociationOutputUrl$, 0]
];
var InstanceInfo$ = [3, n0, _IIns,
    0,
    [_ATg, _AVg, _CNo, _IS, _IAp, _MS, _PTla, _PNl, _PV, _RT],
    [0, 0, 0, 0, [() => IPAddress, 0], 0, 0, 0, 0, 0]
];
var InstanceInformation$ = [3, n0, _IInst,
    0,
    [_II, _PSi, _LPDT, _AVg, _ILV, _PTla, _PNl, _PV, _AIc, _IR, _RD, _RT, _N, _IPA, _CNo, _AS, _LAED, _LSAED, _AO, _SIo, _STo],
    [0, 0, 4, 0, 2, 0, 0, 0, 0, 0, 4, 0, 0, [() => IPAddress, 0], 0, 0, 4, 4, () => InstanceAggregatedAssociationOverview$, 0, 0]
];
var InstanceInformationFilter$ = [3, n0, _IIF,
    0,
    [_k, _vS],
    [0, [() => InstanceInformationFilterValueSet, 0]], 2
];
var InstanceInformationStringFilter$ = [3, n0, _IISF,
    0,
    [_K, _Va],
    [0, [() => InstanceInformationFilterValueSet, 0]], 2
];
var InstancePatchState$ = [3, n0, _IPSn,
    0,
    [_II, _PG, _BI, _OST, _OET, _Op, _SIn, _IOL, _OI, _IC, _IOC, _IPRC, _IRC, _MCi, _FC, _UNAC, _NAC, _ASUC, _LNRIOT, _ROe, _CNCC, _SNCC, _ONCC],
    [0, 0, 0, 4, 4, 0, 0, 0, [() => OwnerInformation, 0], 1, 1, 1, 1, 1, 1, 1, 1, 1, 4, 0, 1, 1, 1], 6
];
var InstancePatchStateFilter$ = [3, n0, _IPSF,
    0,
    [_K, _Va, _Ty],
    [0, 64 | 0, 0], 3
];
var InstanceProperty$ = [3, n0, _IPns,
    0,
    [_N, _II, _IT, _IRn, _KN, _ISn, _Ar, _IPA, _LT, _PSi, _LPDT, _AVg, _PTla, _PNl, _PV, _AIc, _IR, _RD, _RT, _CNo, _AS, _LAED, _LSAED, _AO, _SIo, _STo],
    [0, 0, 0, 0, 0, 0, 0, [() => IPAddress, 0], 4, 0, 4, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 4, 4, () => InstanceAggregatedAssociationOverview$, 0, 0]
];
var InstancePropertyFilter$ = [3, n0, _IPF,
    0,
    [_k, _vS],
    [0, [() => InstancePropertyFilterValueSet, 0]], 2
];
var InstancePropertyStringFilter$ = [3, n0, _IPSFn,
    0,
    [_K, _Va, _Ope],
    [0, [() => InstancePropertyFilterValueSet, 0], 0], 2
];
var InternalServerError$ = [-3, n0, _ISE,
    { [_aQE]: [`InternalServerError`, 500], [_e]: _s },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InternalServerError$, InternalServerError);
var InvalidActivation$ = [-3, n0, _IAn,
    { [_aQE]: [`InvalidActivation`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidActivation$, InvalidActivation);
var InvalidActivationId$ = [-3, n0, _IAI,
    { [_aQE]: [`InvalidActivationId`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidActivationId$, InvalidActivationId);
var InvalidAggregatorException$ = [-3, n0, _IAE,
    { [_aQE]: [`InvalidAggregator`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidAggregatorException$, InvalidAggregatorException);
var InvalidAllowedPatternException$ = [-3, n0, _IAPE,
    { [_aQE]: [`InvalidAllowedPatternException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidAllowedPatternException$, InvalidAllowedPatternException);
var InvalidAssociation$ = [-3, n0, _IAnv,
    { [_aQE]: [`InvalidAssociation`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidAssociation$, InvalidAssociation);
var InvalidAssociationVersion$ = [-3, n0, _IAV,
    { [_aQE]: [`InvalidAssociationVersion`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidAssociationVersion$, InvalidAssociationVersion);
var InvalidAutomationExecutionParametersException$ = [-3, n0, _IAEPE,
    { [_aQE]: [`InvalidAutomationExecutionParameters`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidAutomationExecutionParametersException$, InvalidAutomationExecutionParametersException);
var InvalidAutomationSignalException$ = [-3, n0, _IASE,
    { [_aQE]: [`InvalidAutomationSignalException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidAutomationSignalException$, InvalidAutomationSignalException);
var InvalidAutomationStatusUpdateException$ = [-3, n0, _IASUE,
    { [_aQE]: [`InvalidAutomationStatusUpdateException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidAutomationStatusUpdateException$, InvalidAutomationStatusUpdateException);
var InvalidCommandId$ = [-3, n0, _ICI,
    { [_aQE]: [`InvalidCommandId`, 404], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvalidCommandId$, InvalidCommandId);
var InvalidDeleteInventoryParametersException$ = [-3, n0, _IDIPE,
    { [_aQE]: [`InvalidDeleteInventoryParameters`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDeleteInventoryParametersException$, InvalidDeleteInventoryParametersException);
var InvalidDeletionIdException$ = [-3, n0, _IDIE,
    { [_aQE]: [`InvalidDeletionId`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDeletionIdException$, InvalidDeletionIdException);
var InvalidDocument$ = [-3, n0, _IDn,
    { [_aQE]: [`InvalidDocument`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDocument$, InvalidDocument);
var InvalidDocumentContent$ = [-3, n0, _IDC,
    { [_aQE]: [`InvalidDocumentContent`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDocumentContent$, InvalidDocumentContent);
var InvalidDocumentOperation$ = [-3, n0, _IDO,
    { [_aQE]: [`InvalidDocumentOperation`, 403], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDocumentOperation$, InvalidDocumentOperation);
var InvalidDocumentSchemaVersion$ = [-3, n0, _IDSV,
    { [_aQE]: [`InvalidDocumentSchemaVersion`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDocumentSchemaVersion$, InvalidDocumentSchemaVersion);
var InvalidDocumentType$ = [-3, n0, _IDT,
    { [_aQE]: [`InvalidDocumentType`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDocumentType$, InvalidDocumentType);
var InvalidDocumentVersion$ = [-3, n0, _IDVn,
    { [_aQE]: [`InvalidDocumentVersion`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidDocumentVersion$, InvalidDocumentVersion);
var InvalidFilter$ = [-3, n0, _IF,
    { [_aQE]: [`InvalidFilter`, 441], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidFilter$, InvalidFilter);
var InvalidFilterKey$ = [-3, n0, _IFK,
    { [_aQE]: [`InvalidFilterKey`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvalidFilterKey$, InvalidFilterKey);
var InvalidFilterOption$ = [-3, n0, _IFO,
    { [_aQE]: [`InvalidFilterOption`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidFilterOption$, InvalidFilterOption);
var InvalidFilterValue$ = [-3, n0, _IFV,
    { [_aQE]: [`InvalidFilterValue`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidFilterValue$, InvalidFilterValue);
var InvalidInstanceId$ = [-3, n0, _III,
    { [_aQE]: [`InvalidInstanceId`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidInstanceId$, InvalidInstanceId);
var InvalidInstanceInformationFilterValue$ = [-3, n0, _IIIFV,
    { [_aQE]: [`InvalidInstanceInformationFilterValue`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidInstanceInformationFilterValue$, InvalidInstanceInformationFilterValue);
var InvalidInstancePropertyFilterValue$ = [-3, n0, _IIPFV,
    { [_aQE]: [`InvalidInstancePropertyFilterValue`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidInstancePropertyFilterValue$, InvalidInstancePropertyFilterValue);
var InvalidInventoryGroupException$ = [-3, n0, _IIGE,
    { [_aQE]: [`InvalidInventoryGroup`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidInventoryGroupException$, InvalidInventoryGroupException);
var InvalidInventoryItemContextException$ = [-3, n0, _IIICE,
    { [_aQE]: [`InvalidInventoryItemContext`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidInventoryItemContextException$, InvalidInventoryItemContextException);
var InvalidInventoryRequestException$ = [-3, n0, _IIRE,
    { [_aQE]: [`InvalidInventoryRequest`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidInventoryRequestException$, InvalidInventoryRequestException);
var InvalidItemContentException$ = [-3, n0, _IICE,
    { [_aQE]: [`InvalidItemContent`, 400], [_e]: _c },
    [_TN, _M],
    [0, 0]
];
schema.TypeRegistry.for(n0).registerError(InvalidItemContentException$, InvalidItemContentException);
var InvalidKeyId$ = [-3, n0, _IKI,
    { [_aQE]: [`InvalidKeyId`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidKeyId$, InvalidKeyId);
var InvalidNextToken$ = [-3, n0, _INT,
    { [_aQE]: [`InvalidNextToken`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidNextToken$, InvalidNextToken);
var InvalidNotificationConfig$ = [-3, n0, _INC,
    { [_aQE]: [`InvalidNotificationConfig`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidNotificationConfig$, InvalidNotificationConfig);
var InvalidOptionException$ = [-3, n0, _IOE,
    { [_aQE]: [`InvalidOption`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidOptionException$, InvalidOptionException);
var InvalidOutputFolder$ = [-3, n0, _IOF,
    { [_aQE]: [`InvalidOutputFolder`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvalidOutputFolder$, InvalidOutputFolder);
var InvalidOutputLocation$ = [-3, n0, _IOLn,
    { [_aQE]: [`InvalidOutputLocation`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvalidOutputLocation$, InvalidOutputLocation);
var InvalidParameters$ = [-3, n0, _IP,
    { [_aQE]: [`InvalidParameters`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidParameters$, InvalidParameters);
var InvalidPermissionType$ = [-3, n0, _IPT,
    { [_aQE]: [`InvalidPermissionType`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidPermissionType$, InvalidPermissionType);
var InvalidPluginName$ = [-3, n0, _IPN,
    { [_aQE]: [`InvalidPluginName`, 404], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvalidPluginName$, InvalidPluginName);
var InvalidPolicyAttributeException$ = [-3, n0, _IPAE,
    { [_aQE]: [`InvalidPolicyAttributeException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidPolicyAttributeException$, InvalidPolicyAttributeException);
var InvalidPolicyTypeException$ = [-3, n0, _IPTE,
    { [_aQE]: [`InvalidPolicyTypeException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidPolicyTypeException$, InvalidPolicyTypeException);
var InvalidResourceId$ = [-3, n0, _IRI,
    { [_aQE]: [`InvalidResourceId`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvalidResourceId$, InvalidResourceId);
var InvalidResourceType$ = [-3, n0, _IRT,
    { [_aQE]: [`InvalidResourceType`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvalidResourceType$, InvalidResourceType);
var InvalidResultAttributeException$ = [-3, n0, _IRAE,
    { [_aQE]: [`InvalidResultAttribute`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidResultAttributeException$, InvalidResultAttributeException);
var InvalidRole$ = [-3, n0, _IRnv,
    { [_aQE]: [`InvalidRole`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidRole$, InvalidRole);
var InvalidSchedule$ = [-3, n0, _ISnv,
    { [_aQE]: [`InvalidSchedule`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidSchedule$, InvalidSchedule);
var InvalidTag$ = [-3, n0, _ITn,
    { [_aQE]: [`InvalidTag`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidTag$, InvalidTag);
var InvalidTarget$ = [-3, n0, _ITnv,
    { [_aQE]: [`InvalidTarget`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidTarget$, InvalidTarget);
var InvalidTargetMaps$ = [-3, n0, _ITM,
    { [_aQE]: [`InvalidTargetMaps`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidTargetMaps$, InvalidTargetMaps);
var InvalidTypeNameException$ = [-3, n0, _ITNE,
    { [_aQE]: [`InvalidTypeName`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidTypeNameException$, InvalidTypeNameException);
var InvalidUpdate$ = [-3, n0, _IU,
    { [_aQE]: [`InvalidUpdate`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(InvalidUpdate$, InvalidUpdate);
var InventoryAggregator$ = [3, n0, _IAnve,
    0,
    [_Ex, _Ag, _G],
    [0, [() => InventoryAggregatorList, 0], [() => InventoryGroupList, 0]]
];
var InventoryDeletionStatusItem$ = [3, n0, _IDSI,
    0,
    [_DI, _TN, _DST, _LS, _LSM, _DSe, _LSUT],
    [0, 0, 4, 0, 0, () => InventoryDeletionSummary$, 4]
];
var InventoryDeletionSummary$ = [3, n0, _IDS,
    0,
    [_TCo, _RCem, _SIu],
    [1, 1, () => InventoryDeletionSummaryItems]
];
var InventoryDeletionSummaryItem$ = [3, n0, _IDSIn,
    0,
    [_Ve, _Cou, _RCem],
    [0, 1, 1]
];
var InventoryFilter$ = [3, n0, _IFn,
    0,
    [_K, _Va, _Ty],
    [0, [() => InventoryFilterValueList, 0], 0], 2
];
var InventoryGroup$ = [3, n0, _IG,
    0,
    [_N, _Fi],
    [0, [() => InventoryFilterList, 0]], 2
];
var InventoryItem$ = [3, n0, _IInve,
    0,
    [_TN, _SV, _CTa, _CH, _Con, _Cont],
    [0, 0, 0, 0, [1, n0, _IIEL, 0, 128 | 0], 128 | 0], 3
];
var InventoryItemAttribute$ = [3, n0, _IIA,
    0,
    [_N, _DTa],
    [0, 0], 2
];
var InventoryItemSchema$ = [3, n0, _IIS,
    0,
    [_TN, _Att, _Ve, _DNi],
    [0, [() => InventoryItemAttributeList, 0], 0, 0], 2
];
var InventoryResultEntity$ = [3, n0, _IRE,
    0,
    [_I, _Dat],
    [0, () => InventoryResultItemMap]
];
var InventoryResultItem$ = [3, n0, _IRIn,
    0,
    [_TN, _SV, _Con, _CTa, _CH],
    [0, 0, [1, n0, _IIEL, 0, 128 | 0], 0, 0], 3
];
var InvocationDoesNotExist$ = [-3, n0, _IDNE,
    { [_aQE]: [`InvocationDoesNotExist`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(InvocationDoesNotExist$, InvocationDoesNotExist);
var ItemContentMismatchException$ = [-3, n0, _ICME,
    { [_aQE]: [`ItemContentMismatch`, 400], [_e]: _c },
    [_TN, _M],
    [0, 0]
];
schema.TypeRegistry.for(n0).registerError(ItemContentMismatchException$, ItemContentMismatchException);
var ItemSizeLimitExceededException$ = [-3, n0, _ISLEE,
    { [_aQE]: [`ItemSizeLimitExceeded`, 400], [_e]: _c },
    [_TN, _M],
    [0, 0]
];
schema.TypeRegistry.for(n0).registerError(ItemSizeLimitExceededException$, ItemSizeLimitExceededException);
var LabelParameterVersionRequest$ = [3, n0, _LPVR,
    0,
    [_N, _L, _PVa],
    [0, 64 | 0, 1], 2
];
var LabelParameterVersionResult$ = [3, n0, _LPVRa,
    0,
    [_IL, _PVa],
    [64 | 0, 1]
];
var ListAssociationsRequest$ = [3, n0, _LAR,
    0,
    [_AFL, _MR, _NT],
    [[() => AssociationFilterList, 0], 1, 0]
];
var ListAssociationsResult$ = [3, n0, _LARi,
    0,
    [_Ass, _NT],
    [[() => AssociationList, 0], 0]
];
var ListAssociationVersionsRequest$ = [3, n0, _LAVR,
    0,
    [_AIss, _MR, _NT],
    [0, 1, 0], 1
];
var ListAssociationVersionsResult$ = [3, n0, _LAVRi,
    0,
    [_AVs, _NT],
    [[() => AssociationVersionList, 0], 0]
];
var ListCommandInvocationsRequest$ = [3, n0, _LCIR,
    0,
    [_CI, _II, _MR, _NT, _Fi, _De],
    [0, 0, 1, 0, () => CommandFilterList, 2]
];
var ListCommandInvocationsResult$ = [3, n0, _LCIRi,
    0,
    [_CIomm, _NT],
    [() => CommandInvocationList, 0]
];
var ListCommandsRequest$ = [3, n0, _LCR,
    0,
    [_CI, _II, _MR, _NT, _Fi],
    [0, 0, 1, 0, () => CommandFilterList]
];
var ListCommandsResult$ = [3, n0, _LCRi,
    0,
    [_Com, _NT],
    [[() => CommandList, 0], 0]
];
var ListComplianceItemsRequest$ = [3, n0, _LCIRis,
    0,
    [_Fi, _RIes, _RTes, _NT, _MR],
    [[() => ComplianceStringFilterList, 0], 64 | 0, 64 | 0, 0, 1]
];
var ListComplianceItemsResult$ = [3, n0, _LCIRist,
    0,
    [_CIomp, _NT],
    [[() => ComplianceItemList, 0], 0]
];
var ListComplianceSummariesRequest$ = [3, n0, _LCSR,
    0,
    [_Fi, _NT, _MR],
    [[() => ComplianceStringFilterList, 0], 0, 1]
];
var ListComplianceSummariesResult$ = [3, n0, _LCSRi,
    0,
    [_CSIo, _NT],
    [[() => ComplianceSummaryItemList, 0], 0]
];
var ListDocumentMetadataHistoryRequest$ = [3, n0, _LDMHR,
    0,
    [_N, _Me, _DV, _NT, _MR],
    [0, 0, 0, 0, 1], 2
];
var ListDocumentMetadataHistoryResponse$ = [3, n0, _LDMHRi,
    0,
    [_N, _DV, _Au, _Me, _NT],
    [0, 0, 0, () => DocumentMetadataResponseInfo$, 0]
];
var ListDocumentsRequest$ = [3, n0, _LDR,
    0,
    [_DFL, _Fi, _MR, _NT],
    [[() => DocumentFilterList, 0], () => DocumentKeyValuesFilterList, 1, 0]
];
var ListDocumentsResult$ = [3, n0, _LDRi,
    0,
    [_DIoc, _NT],
    [[() => DocumentIdentifierList, 0], 0]
];
var ListDocumentVersionsRequest$ = [3, n0, _LDVR,
    0,
    [_N, _MR, _NT],
    [0, 1, 0], 1
];
var ListDocumentVersionsResult$ = [3, n0, _LDVRi,
    0,
    [_DVo, _NT],
    [() => DocumentVersionList, 0]
];
var ListInventoryEntriesRequest$ = [3, n0, _LIER,
    0,
    [_II, _TN, _Fi, _NT, _MR],
    [0, 0, [() => InventoryFilterList, 0], 0, 1], 2
];
var ListInventoryEntriesResult$ = [3, n0, _LIERi,
    0,
    [_TN, _II, _SV, _CTa, _En, _NT],
    [0, 0, 0, 0, [1, n0, _IIEL, 0, 128 | 0], 0]
];
var ListNodesRequest$ = [3, n0, _LNR,
    0,
    [_SN, _Fi, _NT, _MR],
    [0, [() => NodeFilterList, 0], 0, 1]
];
var ListNodesResult$ = [3, n0, _LNRi,
    0,
    [_Nod, _NT],
    [[() => NodeList, 0], 0]
];
var ListNodesSummaryRequest$ = [3, n0, _LNSR,
    0,
    [_Ag, _SN, _Fi, _NT, _MR],
    [[() => NodeAggregatorList, 0], 0, [() => NodeFilterList, 0], 0, 1], 1
];
var ListNodesSummaryResult$ = [3, n0, _LNSRi,
    0,
    [_Sum, _NT],
    [[1, n0, _NSL, 0, 128 | 0], 0]
];
var ListOpsItemEventsRequest$ = [3, n0, _LOIER,
    0,
    [_Fi, _MR, _NT],
    [() => OpsItemEventFilters, 1, 0]
];
var ListOpsItemEventsResponse$ = [3, n0, _LOIERi,
    0,
    [_NT, _Summ],
    [0, () => OpsItemEventSummaries]
];
var ListOpsItemRelatedItemsRequest$ = [3, n0, _LOIRIR,
    0,
    [_OII, _Fi, _MR, _NT],
    [0, () => OpsItemRelatedItemsFilters, 1, 0]
];
var ListOpsItemRelatedItemsResponse$ = [3, n0, _LOIRIRi,
    0,
    [_NT, _Summ],
    [0, () => OpsItemRelatedItemSummaries]
];
var ListOpsMetadataRequest$ = [3, n0, _LOMR,
    0,
    [_Fi, _MR, _NT],
    [() => OpsMetadataFilterList, 1, 0]
];
var ListOpsMetadataResult$ = [3, n0, _LOMRi,
    0,
    [_OML, _NT],
    [() => OpsMetadataList, 0]
];
var ListResourceComplianceSummariesRequest$ = [3, n0, _LRCSR,
    0,
    [_Fi, _NT, _MR],
    [[() => ComplianceStringFilterList, 0], 0, 1]
];
var ListResourceComplianceSummariesResult$ = [3, n0, _LRCSRi,
    0,
    [_RCSI, _NT],
    [[() => ResourceComplianceSummaryItemList, 0], 0]
];
var ListResourceDataSyncRequest$ = [3, n0, _LRDSR,
    0,
    [_STy, _NT, _MR],
    [0, 0, 1]
];
var ListResourceDataSyncResult$ = [3, n0, _LRDSRi,
    0,
    [_RDSI, _NT],
    [() => ResourceDataSyncItemList, 0]
];
var ListTagsForResourceRequest$ = [3, n0, _LTFRR,
    0,
    [_RT, _RI],
    [0, 0], 2
];
var ListTagsForResourceResult$ = [3, n0, _LTFRRi,
    0,
    [_TLa],
    [() => TagList]
];
var LoggingInfo$ = [3, n0, _LI,
    0,
    [_SBN, _SRe, _SKP],
    [0, 0, 0], 2
];
var MaintenanceWindowAutomationParameters$ = [3, n0, _MWAP,
    0,
    [_DV, _P],
    [0, [2, n0, _APM, 0, 0, 64 | 0]]
];
var MaintenanceWindowExecution$ = [3, n0, _MWE,
    0,
    [_WI, _WEI, _St, _SD, _STt, _ETn],
    [0, 0, 0, 0, 4, 4]
];
var MaintenanceWindowExecutionTaskIdentity$ = [3, n0, _MWETI,
    0,
    [_WEI, _TEI, _St, _SD, _STt, _ETn, _TAa, _TTa, _AC, _TA],
    [0, 0, 0, 0, 4, 4, 0, 0, () => AlarmConfiguration$, () => AlarmStateInformationList]
];
var MaintenanceWindowExecutionTaskInvocationIdentity$ = [3, n0, _MWETII,
    0,
    [_WEI, _TEI, _IInv, _EI, _TTa, _P, _St, _SD, _STt, _ETn, _OI, _WTI],
    [0, 0, 0, 0, 0, [() => MaintenanceWindowExecutionTaskInvocationParameters, 0], 0, 0, 4, 4, [() => OwnerInformation, 0], 0]
];
var MaintenanceWindowFilter$ = [3, n0, _MWF,
    0,
    [_K, _Va],
    [0, 64 | 0]
];
var MaintenanceWindowIdentity$ = [3, n0, _MWI,
    0,
    [_WI, _N, _D, _Ena, _Du, _Cu, _Sc, _STc, _SO, _EDn, _SDt, _NET],
    [0, 0, [() => MaintenanceWindowDescription, 0], 2, 1, 1, 0, 0, 1, 0, 0, 0]
];
var MaintenanceWindowIdentityForTarget$ = [3, n0, _MWIFT,
    0,
    [_WI, _N],
    [0, 0]
];
var MaintenanceWindowLambdaParameters$ = [3, n0, _MWLPa,
    0,
    [_CCl, _Q, _Pay],
    [0, 0, [() => MaintenanceWindowLambdaPayload, 0]]
];
var MaintenanceWindowRunCommandParameters$ = [3, n0, _MWRCP,
    0,
    [_Co, _CWOC, _DH, _DHT, _DV, _NC, _OSBN, _OSKP, _P, _SRA, _TS],
    [0, () => CloudWatchOutputConfig$, 0, 0, 0, () => NotificationConfig$, 0, 0, [() => _Parameters, 0], 0, 1]
];
var MaintenanceWindowStepFunctionsParameters$ = [3, n0, _MWSFP,
    0,
    [_Inp, _N],
    [[() => MaintenanceWindowStepFunctionsInput, 0], 0]
];
var MaintenanceWindowTarget$ = [3, n0, _MWT,
    0,
    [_WI, _WTI, _RT, _Ta, _OI, _N, _D],
    [0, 0, 0, () => Targets, [() => OwnerInformation, 0], 0, [() => MaintenanceWindowDescription, 0]]
];
var MaintenanceWindowTask$ = [3, n0, _MWTa,
    0,
    [_WI, _WTIi, _TAa, _Ty, _Ta, _TPa, _Pr, _LI, _SRA, _MC, _ME, _N, _D, _CB, _AC],
    [0, 0, 0, 0, () => Targets, [() => MaintenanceWindowTaskParameters, 0], 1, () => LoggingInfo$, 0, 0, 0, 0, [() => MaintenanceWindowDescription, 0], 0, () => AlarmConfiguration$]
];
var MaintenanceWindowTaskInvocationParameters$ = [3, n0, _MWTIP,
    0,
    [_RCu, _Aut, _SF, _La],
    [[() => MaintenanceWindowRunCommandParameters$, 0], () => MaintenanceWindowAutomationParameters$, [() => MaintenanceWindowStepFunctionsParameters$, 0], [() => MaintenanceWindowLambdaParameters$, 0]]
];
var MaintenanceWindowTaskParameterValueExpression$ = [3, n0, _MWTPVE,
    8,
    [_Va],
    [[() => MaintenanceWindowTaskParameterValueList, 0]]
];
var MalformedResourcePolicyDocumentException$ = [-3, n0, _MRPDE,
    { [_aQE]: [`MalformedResourcePolicyDocumentException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(MalformedResourcePolicyDocumentException$, MalformedResourcePolicyDocumentException);
var MaxDocumentSizeExceeded$ = [-3, n0, _MDSE,
    { [_aQE]: [`MaxDocumentSizeExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(MaxDocumentSizeExceeded$, MaxDocumentSizeExceeded);
var MetadataValue$ = [3, n0, _MV,
    0,
    [_V],
    [0]
];
var ModifyDocumentPermissionRequest$ = [3, n0, _MDPR,
    0,
    [_N, _PT, _AITA, _AITR, _SDV],
    [0, 0, [() => AccountIdList, 0], [() => AccountIdList, 0], 0], 2
];
var ModifyDocumentPermissionResponse$ = [3, n0, _MDPRo,
    0,
    [],
    []
];
var Node$ = [3, n0, _Node,
    0,
    [_CTa, _I, _Ow, _Reg, _NTo],
    [4, 0, () => NodeOwnerInfo$, 0, [() => NodeType$, 0]]
];
var NodeAggregator$ = [3, n0, _NA,
    0,
    [_ATgg, _TN, _ANt, _Ag],
    [0, 0, 0, [() => NodeAggregatorList, 0]], 3
];
var NodeFilter$ = [3, n0, _NF,
    0,
    [_K, _Va, _Ty],
    [0, [() => NodeFilterValueList, 0], 0], 2
];
var NodeOwnerInfo$ = [3, n0, _NOI,
    0,
    [_AI, _OUI, _OUP],
    [0, 0, 0]
];
var NoLongerSupportedException$ = [-3, n0, _NLSE,
    { [_aQE]: [`NoLongerSupported`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(NoLongerSupportedException$, NoLongerSupportedException);
var NonCompliantSummary$ = [3, n0, _NCS,
    0,
    [_NCC, _SS],
    [1, () => SeveritySummary$]
];
var NotificationConfig$ = [3, n0, _NC,
    0,
    [_NAo, _NE, _NTot],
    [0, 64 | 0, 0]
];
var OpsAggregator$ = [3, n0, _OA,
    0,
    [_ATgg, _TN, _ANt, _Va, _Fi, _Ag],
    [0, 0, 0, 128 | 0, [() => OpsFilterList, 0], [() => OpsAggregatorList, 0]]
];
var OpsEntity$ = [3, n0, _OE,
    0,
    [_I, _Dat],
    [0, () => OpsEntityItemMap]
];
var OpsEntityItem$ = [3, n0, _OEI,
    0,
    [_CTa, _Con],
    [0, [1, n0, _OEIEL, 0, 128 | 0]]
];
var OpsFilter$ = [3, n0, _OF,
    0,
    [_K, _Va, _Ty],
    [0, [() => OpsFilterValueList, 0], 0], 2
];
var OpsItem$ = [3, n0, _OIp,
    0,
    [_CBr, _OIT, _CT, _D, _LMB, _LMT, _No, _Pr, _ROI, _St, _OII, _Ve, _Ti, _Sou, _OD, _Ca, _Se, _AST, _AETc, _PST, _PET, _OIA],
    [0, 0, 4, 0, 0, 4, () => OpsItemNotifications, 1, () => RelatedOpsItems, 0, 0, 0, 0, 0, () => OpsItemOperationalData, 0, 0, 4, 4, 4, 4, 0]
];
var OpsItemAccessDeniedException$ = [-3, n0, _OIADE,
    { [_aQE]: [`OpsItemAccessDeniedException`, 403], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemAccessDeniedException$, OpsItemAccessDeniedException);
var OpsItemAlreadyExistsException$ = [-3, n0, _OIAEE,
    { [_aQE]: [`OpsItemAlreadyExistsException`, 400], [_e]: _c },
    [_M, _OII],
    [0, 0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemAlreadyExistsException$, OpsItemAlreadyExistsException);
var OpsItemConflictException$ = [-3, n0, _OICE,
    { [_aQE]: [`OpsItemConflictException`, 409], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemConflictException$, OpsItemConflictException);
var OpsItemDataValue$ = [3, n0, _OIDV,
    0,
    [_V, _Ty],
    [0, 0]
];
var OpsItemEventFilter$ = [3, n0, _OIEF,
    0,
    [_K, _Va, _Ope],
    [0, 64 | 0, 0], 3
];
var OpsItemEventSummary$ = [3, n0, _OIES,
    0,
    [_OII, _EIv, _Sou, _DTe, _Det, _CBr, _CT],
    [0, 0, 0, 0, 0, () => OpsItemIdentity$, 4]
];
var OpsItemFilter$ = [3, n0, _OIFp,
    0,
    [_K, _Va, _Ope],
    [0, 64 | 0, 0], 3
];
var OpsItemIdentity$ = [3, n0, _OIIp,
    0,
    [_Arn],
    [0]
];
var OpsItemInvalidParameterException$ = [-3, n0, _OIIPE,
    { [_aQE]: [`OpsItemInvalidParameterException`, 400], [_e]: _c },
    [_PNa, _M],
    [64 | 0, 0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemInvalidParameterException$, OpsItemInvalidParameterException);
var OpsItemLimitExceededException$ = [-3, n0, _OILEE,
    { [_aQE]: [`OpsItemLimitExceededException`, 400], [_e]: _c },
    [_RTes, _Li, _LTi, _M],
    [64 | 0, 1, 0, 0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemLimitExceededException$, OpsItemLimitExceededException);
var OpsItemNotFoundException$ = [-3, n0, _OINFE,
    { [_aQE]: [`OpsItemNotFoundException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemNotFoundException$, OpsItemNotFoundException);
var OpsItemNotification$ = [3, n0, _OIN,
    0,
    [_Arn],
    [0]
];
var OpsItemRelatedItemAlreadyExistsException$ = [-3, n0, _OIRIAEE,
    { [_aQE]: [`OpsItemRelatedItemAlreadyExistsException`, 400], [_e]: _c },
    [_M, _RU, _OII],
    [0, 0, 0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemRelatedItemAlreadyExistsException$, OpsItemRelatedItemAlreadyExistsException);
var OpsItemRelatedItemAssociationNotFoundException$ = [-3, n0, _OIRIANFE,
    { [_aQE]: [`OpsItemRelatedItemAssociationNotFoundException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsItemRelatedItemAssociationNotFoundException$, OpsItemRelatedItemAssociationNotFoundException);
var OpsItemRelatedItemsFilter$ = [3, n0, _OIRIF,
    0,
    [_K, _Va, _Ope],
    [0, 64 | 0, 0], 3
];
var OpsItemRelatedItemSummary$ = [3, n0, _OIRIS,
    0,
    [_OII, _AIss, _RT, _AT, _RU, _CBr, _CT, _LMB, _LMT],
    [0, 0, 0, 0, 0, () => OpsItemIdentity$, 4, () => OpsItemIdentity$, 4]
];
var OpsItemSummary$ = [3, n0, _OISp,
    0,
    [_CBr, _CT, _LMB, _LMT, _Pr, _Sou, _St, _OII, _Ti, _OD, _Ca, _Se, _OIT, _AST, _AETc, _PST, _PET],
    [0, 4, 0, 4, 1, 0, 0, 0, 0, () => OpsItemOperationalData, 0, 0, 0, 4, 4, 4, 4]
];
var OpsMetadata$ = [3, n0, _OM,
    0,
    [_RI, _OMA, _LMD, _LMU, _CDr],
    [0, 0, 4, 0, 4]
];
var OpsMetadataAlreadyExistsException$ = [-3, n0, _OMAEE,
    { [_aQE]: [`OpsMetadataAlreadyExistsException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsMetadataAlreadyExistsException$, OpsMetadataAlreadyExistsException);
var OpsMetadataFilter$ = [3, n0, _OMF,
    0,
    [_K, _Va],
    [0, 64 | 0], 2
];
var OpsMetadataInvalidArgumentException$ = [-3, n0, _OMIAE,
    { [_aQE]: [`OpsMetadataInvalidArgumentException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsMetadataInvalidArgumentException$, OpsMetadataInvalidArgumentException);
var OpsMetadataKeyLimitExceededException$ = [-3, n0, _OMKLEE,
    { [_aQE]: [`OpsMetadataKeyLimitExceededException`, 429], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsMetadataKeyLimitExceededException$, OpsMetadataKeyLimitExceededException);
var OpsMetadataLimitExceededException$ = [-3, n0, _OMLEE,
    { [_aQE]: [`OpsMetadataLimitExceededException`, 429], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsMetadataLimitExceededException$, OpsMetadataLimitExceededException);
var OpsMetadataNotFoundException$ = [-3, n0, _OMNFE,
    { [_aQE]: [`OpsMetadataNotFoundException`, 404], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsMetadataNotFoundException$, OpsMetadataNotFoundException);
var OpsMetadataTooManyUpdatesException$ = [-3, n0, _OMTMUE,
    { [_aQE]: [`OpsMetadataTooManyUpdatesException`, 429], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(OpsMetadataTooManyUpdatesException$, OpsMetadataTooManyUpdatesException);
var OpsResultAttribute$ = [3, n0, _ORA,
    0,
    [_TN],
    [0], 1
];
var OutputSource$ = [3, n0, _OS,
    0,
    [_OSI, _OSTu],
    [0, 0]
];
var Parameter$ = [3, n0, _Par,
    0,
    [_N, _Ty, _V, _Ve, _Sel, _SRo, _LMD, _ARN, _DTa],
    [0, 0, [() => PSParameterValue, 0], 1, 0, 0, 4, 0, 0]
];
var ParameterAlreadyExists$ = [-3, n0, _PAE,
    { [_aQE]: [`ParameterAlreadyExists`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ParameterAlreadyExists$, ParameterAlreadyExists);
var ParameterHistory$ = [3, n0, _PHa,
    0,
    [_N, _Ty, _KI, _LMD, _LMU, _D, _V, _APl, _Ve, _L, _Tie, _Po, _DTa],
    [0, 0, 0, 4, 0, 0, [() => PSParameterValue, 0], 0, 1, 64 | 0, 0, () => ParameterPolicyList, 0]
];
var ParameterInlinePolicy$ = [3, n0, _PIP,
    0,
    [_PTo, _PTol, _PSo],
    [0, 0, 0]
];
var ParameterLimitExceeded$ = [-3, n0, _PLE,
    { [_aQE]: [`ParameterLimitExceeded`, 429], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ParameterLimitExceeded$, ParameterLimitExceeded);
var ParameterMaxVersionLimitExceeded$ = [-3, n0, _PMVLE,
    { [_aQE]: [`ParameterMaxVersionLimitExceeded`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ParameterMaxVersionLimitExceeded$, ParameterMaxVersionLimitExceeded);
var ParameterMetadata$ = [3, n0, _PM,
    0,
    [_N, _ARN, _Ty, _KI, _LMD, _LMU, _D, _APl, _Ve, _Tie, _Po, _DTa],
    [0, 0, 0, 0, 4, 0, 0, 0, 1, 0, () => ParameterPolicyList, 0]
];
var ParameterNotFound$ = [-3, n0, _PNF,
    { [_aQE]: [`ParameterNotFound`, 404], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ParameterNotFound$, ParameterNotFound);
var ParameterPatternMismatchException$ = [-3, n0, _PPME,
    { [_aQE]: [`ParameterPatternMismatchException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ParameterPatternMismatchException$, ParameterPatternMismatchException);
var ParametersFilter$ = [3, n0, _PFa,
    0,
    [_K, _Va],
    [0, 64 | 0], 2
];
var ParameterStringFilter$ = [3, n0, _PSF,
    0,
    [_K, _Opt, _Va],
    [0, 0, 64 | 0], 1
];
var ParameterVersionLabelLimitExceeded$ = [-3, n0, _PVLLE,
    { [_aQE]: [`ParameterVersionLabelLimitExceeded`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ParameterVersionLabelLimitExceeded$, ParameterVersionLabelLimitExceeded);
var ParameterVersionNotFound$ = [-3, n0, _PVNF,
    { [_aQE]: [`ParameterVersionNotFound`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ParameterVersionNotFound$, ParameterVersionNotFound);
var ParentStepDetails$ = [3, n0, _PSD,
    0,
    [_SEI, _SNt, _Ac, _It, _IV],
    [0, 0, 0, 1, 0]
];
var Patch$ = [3, n0, _Pat,
    0,
    [_I, _RDe, _Ti, _D, _CU, _Ven, _PFr, _Prod, _Cl, _MSs, _KNb, _MN, _Lan, _AIdv, _BIu, _CVEI, _N, _Ep, _Ve, _Rel, _Arc, _Se, _Rep],
    [0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64 | 0, 64 | 0, 64 | 0, 0, 1, 0, 0, 0, 0, 0]
];
var PatchBaselineIdentity$ = [3, n0, _PBI,
    0,
    [_BI, _BN, _OSp, _BD, _DB],
    [0, 0, 0, 0, 2]
];
var PatchComplianceData$ = [3, n0, _PCD,
    0,
    [_Ti, _KBI, _Cl, _Se, _S, _ITns, _CVEI],
    [0, 0, 0, 0, 0, 4, 0], 6
];
var PatchFilter$ = [3, n0, _PFat,
    0,
    [_K, _Va],
    [0, 64 | 0], 2
];
var PatchFilterGroup$ = [3, n0, _PFG,
    0,
    [_PFatc],
    [() => PatchFilterList], 1
];
var PatchGroupPatchBaselineMapping$ = [3, n0, _PGPBM,
    0,
    [_PG, _BIas],
    [0, () => PatchBaselineIdentity$]
];
var PatchOrchestratorFilter$ = [3, n0, _POF,
    0,
    [_K, _Va],
    [0, 64 | 0]
];
var PatchRule$ = [3, n0, _PR,
    0,
    [_PFG, _CL, _AAD, _AUD, _ENS],
    [() => PatchFilterGroup$, 0, 1, 0, 2], 1
];
var PatchRuleGroup$ = [3, n0, _PRG,
    0,
    [_PRa],
    [() => PatchRuleList], 1
];
var PatchSource$ = [3, n0, _PSat,
    0,
    [_N, _Produ, _Conf],
    [0, 64 | 0, [() => PatchSourceConfiguration, 0]], 3
];
var PatchStatus$ = [3, n0, _PSa,
    0,
    [_DSep, _CL, _ADp],
    [0, 0, 4]
];
var PoliciesLimitExceededException$ = [-3, n0, _PLEE,
    { [_aQE]: [`PoliciesLimitExceededException`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(PoliciesLimitExceededException$, PoliciesLimitExceededException);
var ProgressCounters$ = [3, n0, _PC,
    0,
    [_TSo, _SSu, _FSa, _CSa, _TOS],
    [1, 1, 1, 1, 1]
];
var PutComplianceItemsRequest$ = [3, n0, _PCIR,
    0,
    [_RI, _RT, _CTo, _ES, _Ite, _ICH, _UTp],
    [0, 0, 0, () => ComplianceExecutionSummary$, () => ComplianceItemEntryList, 0, 0], 5
];
var PutComplianceItemsResult$ = [3, n0, _PCIRu,
    0,
    [],
    []
];
var PutInventoryRequest$ = [3, n0, _PIR,
    0,
    [_II, _Ite],
    [0, [() => InventoryItemList, 0]], 2
];
var PutInventoryResult$ = [3, n0, _PIRu,
    0,
    [_M],
    [0]
];
var PutParameterRequest$ = [3, n0, _PPR,
    0,
    [_N, _V, _D, _Ty, _KI, _Ov, _APl, _T, _Tie, _Po, _DTa],
    [0, [() => PSParameterValue, 0], 0, 0, 0, 2, 0, () => TagList, 0, 0, 0], 2
];
var PutParameterResult$ = [3, n0, _PPRu,
    0,
    [_Ve, _Tie],
    [1, 0]
];
var PutResourcePolicyRequest$ = [3, n0, _PRPR,
    0,
    [_RA, _Pol, _PI, _PH],
    [0, 0, 0, 0], 2
];
var PutResourcePolicyResponse$ = [3, n0, _PRPRu,
    0,
    [_PI, _PH],
    [0, 0]
];
var RegisterDefaultPatchBaselineRequest$ = [3, n0, _RDPBR,
    0,
    [_BI],
    [0], 1
];
var RegisterDefaultPatchBaselineResult$ = [3, n0, _RDPBRe,
    0,
    [_BI],
    [0]
];
var RegisterPatchBaselineForPatchGroupRequest$ = [3, n0, _RPBFPGR,
    0,
    [_BI, _PG],
    [0, 0], 2
];
var RegisterPatchBaselineForPatchGroupResult$ = [3, n0, _RPBFPGRe,
    0,
    [_BI, _PG],
    [0, 0]
];
var RegisterTargetWithMaintenanceWindowRequest$ = [3, n0, _RTWMWR,
    0,
    [_WI, _RT, _Ta, _OI, _N, _D, _CTl],
    [0, 0, () => Targets, [() => OwnerInformation, 0], 0, [() => MaintenanceWindowDescription, 0], [0, 4]], 3
];
var RegisterTargetWithMaintenanceWindowResult$ = [3, n0, _RTWMWRe,
    0,
    [_WTI],
    [0]
];
var RegisterTaskWithMaintenanceWindowRequest$ = [3, n0, _RTWMWReg,
    0,
    [_WI, _TAa, _TTa, _Ta, _SRA, _TPa, _TIP, _Pr, _MC, _ME, _LI, _N, _D, _CTl, _CB, _AC],
    [0, 0, 0, () => Targets, 0, [() => MaintenanceWindowTaskParameters, 0], [() => MaintenanceWindowTaskInvocationParameters$, 0], 1, 0, 0, () => LoggingInfo$, 0, [() => MaintenanceWindowDescription, 0], [0, 4], 0, () => AlarmConfiguration$], 3
];
var RegisterTaskWithMaintenanceWindowResult$ = [3, n0, _RTWMWRegi,
    0,
    [_WTIi],
    [0]
];
var RegistrationMetadataItem$ = [3, n0, _RMI,
    0,
    [_K, _V],
    [0, 0], 2
];
var RelatedOpsItem$ = [3, n0, _ROIe,
    0,
    [_OII],
    [0], 1
];
var RemoveTagsFromResourceRequest$ = [3, n0, _RTFRR,
    0,
    [_RT, _RI, _TK],
    [0, 0, 64 | 0], 3
];
var RemoveTagsFromResourceResult$ = [3, n0, _RTFRRe,
    0,
    [],
    []
];
var ResetServiceSettingRequest$ = [3, n0, _RSSR,
    0,
    [_SIe],
    [0], 1
];
var ResetServiceSettingResult$ = [3, n0, _RSSRe,
    0,
    [_SSe],
    [() => ServiceSetting$]
];
var ResolvedTargets$ = [3, n0, _RTe,
    0,
    [_PVar, _Tr],
    [64 | 0, 2]
];
var ResourceComplianceSummaryItem$ = [3, n0, _RCSIe,
    0,
    [_CTo, _RT, _RI, _St, _OSv, _ES, _CSo, _NCS],
    [0, 0, 0, 0, 0, () => ComplianceExecutionSummary$, () => CompliantSummary$, () => NonCompliantSummary$]
];
var ResourceDataSyncAlreadyExistsException$ = [-3, n0, _RDSAEE,
    { [_aQE]: [`ResourceDataSyncAlreadyExists`, 400], [_e]: _c },
    [_SN],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourceDataSyncAlreadyExistsException$, ResourceDataSyncAlreadyExistsException);
var ResourceDataSyncAwsOrganizationsSource$ = [3, n0, _RDSAOS,
    0,
    [_OSTr, _OUr],
    [0, () => ResourceDataSyncOrganizationalUnitList], 1
];
var ResourceDataSyncConflictException$ = [-3, n0, _RDSCE,
    { [_aQE]: [`ResourceDataSyncConflictException`, 409], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourceDataSyncConflictException$, ResourceDataSyncConflictException);
var ResourceDataSyncCountExceededException$ = [-3, n0, _RDSCEE,
    { [_aQE]: [`ResourceDataSyncCountExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourceDataSyncCountExceededException$, ResourceDataSyncCountExceededException);
var ResourceDataSyncDestinationDataSharing$ = [3, n0, _RDSDDS,
    0,
    [_DDST],
    [0]
];
var ResourceDataSyncInvalidConfigurationException$ = [-3, n0, _RDSICE,
    { [_aQE]: [`ResourceDataSyncInvalidConfiguration`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourceDataSyncInvalidConfigurationException$, ResourceDataSyncInvalidConfigurationException);
var ResourceDataSyncItem$ = [3, n0, _RDSIe,
    0,
    [_SN, _STy, _SSy, _SDe, _LST, _LSST, _SLMT, _LS, _SCT, _LSSM],
    [0, 0, () => ResourceDataSyncSourceWithState$, () => ResourceDataSyncS3Destination$, 4, 4, 4, 0, 4, 0]
];
var ResourceDataSyncNotFoundException$ = [-3, n0, _RDSNFE,
    { [_aQE]: [`ResourceDataSyncNotFound`, 404], [_e]: _c },
    [_SN, _STy, _M],
    [0, 0, 0]
];
schema.TypeRegistry.for(n0).registerError(ResourceDataSyncNotFoundException$, ResourceDataSyncNotFoundException);
var ResourceDataSyncOrganizationalUnit$ = [3, n0, _RDSOU,
    0,
    [_OUI],
    [0]
];
var ResourceDataSyncS3Destination$ = [3, n0, _RDSSD,
    0,
    [_BNu, _SFy, _Reg, _Pre, _AWSKMSKARN, _DDS],
    [0, 0, 0, 0, 0, () => ResourceDataSyncDestinationDataSharing$], 3
];
var ResourceDataSyncSource$ = [3, n0, _RDSS,
    0,
    [_STo, _SRou, _AOS, _IFR, _EAODS],
    [0, 64 | 0, () => ResourceDataSyncAwsOrganizationsSource$, 2, 2], 2
];
var ResourceDataSyncSourceWithState$ = [3, n0, _RDSSWS,
    0,
    [_STo, _AOS, _SRou, _IFR, _S, _EAODS],
    [0, () => ResourceDataSyncAwsOrganizationsSource$, 64 | 0, 2, 0, 2]
];
var ResourceInUseException$ = [-3, n0, _RIUE,
    { [_aQE]: [`ResourceInUseException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourceInUseException$, ResourceInUseException);
var ResourceLimitExceededException$ = [-3, n0, _RLEE,
    { [_aQE]: [`ResourceLimitExceededException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourceLimitExceededException$, ResourceLimitExceededException);
var ResourceNotFoundException$ = [-3, n0, _RNFE,
    { [_aQE]: [`ResourceNotFoundException`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourceNotFoundException$, ResourceNotFoundException);
var ResourcePolicyConflictException$ = [-3, n0, _RPCE,
    { [_aQE]: [`ResourcePolicyConflictException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourcePolicyConflictException$, ResourcePolicyConflictException);
var ResourcePolicyInvalidParameterException$ = [-3, n0, _RPIPE,
    { [_aQE]: [`ResourcePolicyInvalidParameterException`, 400], [_e]: _c },
    [_PNa, _M],
    [64 | 0, 0]
];
schema.TypeRegistry.for(n0).registerError(ResourcePolicyInvalidParameterException$, ResourcePolicyInvalidParameterException);
var ResourcePolicyLimitExceededException$ = [-3, n0, _RPLEE,
    { [_aQE]: [`ResourcePolicyLimitExceededException`, 400], [_e]: _c },
    [_Li, _LTi, _M],
    [1, 0, 0]
];
schema.TypeRegistry.for(n0).registerError(ResourcePolicyLimitExceededException$, ResourcePolicyLimitExceededException);
var ResourcePolicyNotFoundException$ = [-3, n0, _RPNFE,
    { [_aQE]: [`ResourcePolicyNotFoundException`, 404], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ResourcePolicyNotFoundException$, ResourcePolicyNotFoundException);
var ResultAttribute$ = [3, n0, _RAes,
    0,
    [_TN],
    [0], 1
];
var ResumeSessionRequest$ = [3, n0, _RSR,
    0,
    [_SIes],
    [0], 1
];
var ResumeSessionResponse$ = [3, n0, _RSRe,
    0,
    [_SIes, _TV, _SU],
    [0, 0, 0]
];
var ReviewInformation$ = [3, n0, _RIe,
    0,
    [_RTev, _St, _Rev],
    [4, 0, 0]
];
var Runbook$ = [3, n0, _Ru,
    0,
    [_DN, _DV, _P, _TPN, _Ta, _TM, _MC, _ME, _TL],
    [0, 0, [2, n0, _APM, 0, 0, 64 | 0], 0, () => Targets, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], 0, 0, () => TargetLocations], 1
];
var S3OutputLocation$ = [3, n0, _SOL,
    0,
    [_OSR, _OSBN, _OSKP],
    [0, 0, 0]
];
var S3OutputUrl$ = [3, n0, _SOUu,
    0,
    [_OU],
    [0]
];
var ScheduledWindowExecution$ = [3, n0, _SWEc,
    0,
    [_WI, _N, _ET],
    [0, 0, 0]
];
var SendAutomationSignalRequest$ = [3, n0, _SASR,
    0,
    [_AEI, _STi, _Pay],
    [0, 0, [2, n0, _APM, 0, 0, 64 | 0]], 2
];
var SendAutomationSignalResult$ = [3, n0, _SASRe,
    0,
    [],
    []
];
var SendCommandRequest$ = [3, n0, _SCR,
    0,
    [_DN, _IIn, _Ta, _DV, _DH, _DHT, _TS, _Co, _P, _OSR, _OSBN, _OSKP, _MC, _ME, _SRA, _NC, _CWOC, _AC],
    [0, 64 | 0, () => Targets, 0, 0, 0, 1, 0, [() => _Parameters, 0], 0, 0, 0, 0, 0, 0, () => NotificationConfig$, () => CloudWatchOutputConfig$, () => AlarmConfiguration$], 1
];
var SendCommandResult$ = [3, n0, _SCRe,
    0,
    [_C],
    [[() => Command$, 0]]
];
var ServiceQuotaExceededException$ = [-3, n0, _SQEE,
    { [_e]: _c },
    [_M, _QC, _SCe, _RI, _RT],
    [0, 0, 0, 0, 0], 3
];
schema.TypeRegistry.for(n0).registerError(ServiceQuotaExceededException$, ServiceQuotaExceededException);
var ServiceSetting$ = [3, n0, _SSe,
    0,
    [_SIe, _SVe, _LMD, _LMU, _ARN, _St],
    [0, 0, 4, 0, 0, 0]
];
var ServiceSettingNotFound$ = [-3, n0, _SSNF,
    { [_aQE]: [`ServiceSettingNotFound`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(ServiceSettingNotFound$, ServiceSettingNotFound);
var Session$ = [3, n0, _Sess,
    0,
    [_SIes, _Tar, _St, _SDt, _EDn, _DN, _Ow, _Rea, _De, _OU, _MSD, _ATc],
    [0, 0, 0, 4, 4, 0, 0, 0, 0, () => SessionManagerOutputUrl$, 0, 0]
];
var SessionFilter$ = [3, n0, _SFe,
    0,
    [_k, _v],
    [0, 0], 2
];
var SessionManagerOutputUrl$ = [3, n0, _SMOU,
    0,
    [_SOUu, _CWOU],
    [0, 0]
];
var SeveritySummary$ = [3, n0, _SS,
    0,
    [_CCr, _HC, _MCe, _LC, _ICn, _UC],
    [1, 1, 1, 1, 1, 1]
];
var StartAccessRequestRequest$ = [3, n0, _SARR,
    0,
    [_Rea, _Ta, _T],
    [0, () => Targets, () => TagList], 2
];
var StartAccessRequestResponse$ = [3, n0, _SARRt,
    0,
    [_ARI],
    [0]
];
var StartAssociationsOnceRequest$ = [3, n0, _SAOR,
    0,
    [_AIsso],
    [64 | 0], 1
];
var StartAssociationsOnceResult$ = [3, n0, _SAORt,
    0,
    [],
    []
];
var StartAutomationExecutionRequest$ = [3, n0, _SAER,
    0,
    [_DN, _DV, _P, _CTl, _Mo, _TPN, _Ta, _TM, _MC, _ME, _TL, _T, _AC, _TLURL],
    [0, 0, [2, n0, _APM, 0, 0, 64 | 0], 0, 0, 0, () => Targets, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], 0, 0, () => TargetLocations, () => TagList, () => AlarmConfiguration$, 0], 1
];
var StartAutomationExecutionResult$ = [3, n0, _SAERt,
    0,
    [_AEI],
    [0]
];
var StartChangeRequestExecutionRequest$ = [3, n0, _SCRER,
    0,
    [_DN, _R, _ST, _DV, _P, _CRN, _CTl, _AA, _T, _SETc, _CDh],
    [0, () => Runbooks, 4, 0, [2, n0, _APM, 0, 0, 64 | 0], 0, 0, 2, () => TagList, 4, 0], 2
];
var StartChangeRequestExecutionResult$ = [3, n0, _SCRERt,
    0,
    [_AEI],
    [0]
];
var StartExecutionPreviewRequest$ = [3, n0, _SEPR,
    0,
    [_DN, _DV, _EIx],
    [0, 0, () => ExecutionInputs$], 1
];
var StartExecutionPreviewResponse$ = [3, n0, _SEPRt,
    0,
    [_EPI],
    [0]
];
var StartSessionRequest$ = [3, n0, _SSR,
    0,
    [_Tar, _DN, _Rea, _P],
    [0, 0, 0, [2, n0, _SMP, 0, 0, 64 | 0]], 1
];
var StartSessionResponse$ = [3, n0, _SSRt,
    0,
    [_SIes, _TV, _SU],
    [0, 0, 0]
];
var StatusUnchanged$ = [-3, n0, _SUt,
    { [_aQE]: [`StatusUnchanged`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(StatusUnchanged$, StatusUnchanged);
var StepExecution$ = [3, n0, _SEte,
    0,
    [_SNt, _Ac, _TS, _OFn, _MA, _EST, _EET, _SSt, _RCe, _Inpu, _Ou, _Res, _FM, _FD, _SEI, _OP, _IE, _NS, _ICs, _VNS, _Ta, _TLar, _TA, _PSD],
    [0, 0, 1, 0, 1, 4, 4, 0, 0, 128 | 0, [2, n0, _APM, 0, 0, 64 | 0], 0, 0, () => FailureDetails$, 0, [2, n0, _APM, 0, 0, 64 | 0], 2, 0, 2, 64 | 0, () => Targets, () => TargetLocation$, () => AlarmStateInformationList, () => ParentStepDetails$]
];
var StepExecutionFilter$ = [3, n0, _SEF,
    0,
    [_K, _Va],
    [0, 64 | 0], 2
];
var StopAutomationExecutionRequest$ = [3, n0, _SAERto,
    0,
    [_AEI, _Ty],
    [0, 0], 1
];
var StopAutomationExecutionResult$ = [3, n0, _SAERtop,
    0,
    [],
    []
];
var SubTypeCountLimitExceededException$ = [-3, n0, _STCLEE,
    { [_aQE]: [`SubTypeCountLimitExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(SubTypeCountLimitExceededException$, SubTypeCountLimitExceededException);
var Tag$ = [3, n0, _Tag,
    0,
    [_K, _V],
    [0, 0], 2
];
var Target$ = [3, n0, _Tar,
    0,
    [_K, _Va],
    [0, 64 | 0]
];
var TargetInUseException$ = [-3, n0, _TIUE,
    { [_aQE]: [`TargetInUseException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(TargetInUseException$, TargetInUseException);
var TargetLocation$ = [3, n0, _TLar,
    0,
    [_Acc, _Re, _TLMC, _TLME, _ERN, _TLAC, _ICOU, _EAx, _Ta, _TMC, _TME],
    [64 | 0, 64 | 0, 0, 0, 0, () => AlarmConfiguration$, 2, 64 | 0, () => Targets, 0, 0]
];
var TargetNotConnected$ = [-3, n0, _TNC,
    { [_aQE]: [`TargetNotConnected`, 430], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(TargetNotConnected$, TargetNotConnected);
var TargetPreview$ = [3, n0, _TPar,
    0,
    [_Cou, _TT],
    [1, 0]
];
var TerminateSessionRequest$ = [3, n0, _TSR,
    0,
    [_SIes],
    [0], 1
];
var TerminateSessionResponse$ = [3, n0, _TSRe,
    0,
    [_SIes],
    [0]
];
var ThrottlingException$ = [-3, n0, _TE,
    { [_e]: _c },
    [_M, _QC, _SCe],
    [0, 0, 0], 1
];
schema.TypeRegistry.for(n0).registerError(ThrottlingException$, ThrottlingException);
var TooManyTagsError$ = [-3, n0, _TMTE,
    { [_aQE]: [`TooManyTagsError`, 400], [_e]: _c },
    [],
    []
];
schema.TypeRegistry.for(n0).registerError(TooManyTagsError$, TooManyTagsError);
var TooManyUpdates$ = [-3, n0, _TMU,
    { [_aQE]: [`TooManyUpdates`, 429], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(TooManyUpdates$, TooManyUpdates);
var TotalSizeLimitExceededException$ = [-3, n0, _TSLEE,
    { [_aQE]: [`TotalSizeLimitExceeded`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(TotalSizeLimitExceededException$, TotalSizeLimitExceededException);
var UnlabelParameterVersionRequest$ = [3, n0, _UPVR,
    0,
    [_N, _PVa, _L],
    [0, 1, 64 | 0], 3
];
var UnlabelParameterVersionResult$ = [3, n0, _UPVRn,
    0,
    [_RLe, _IL],
    [64 | 0, 64 | 0]
];
var UnsupportedCalendarException$ = [-3, n0, _UCE,
    { [_aQE]: [`UnsupportedCalendarException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedCalendarException$, UnsupportedCalendarException);
var UnsupportedFeatureRequiredException$ = [-3, n0, _UFRE,
    { [_aQE]: [`UnsupportedFeatureRequiredException`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedFeatureRequiredException$, UnsupportedFeatureRequiredException);
var UnsupportedInventoryItemContextException$ = [-3, n0, _UIICE,
    { [_aQE]: [`UnsupportedInventoryItemContext`, 400], [_e]: _c },
    [_TN, _M],
    [0, 0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedInventoryItemContextException$, UnsupportedInventoryItemContextException);
var UnsupportedInventorySchemaVersionException$ = [-3, n0, _UISVE,
    { [_aQE]: [`UnsupportedInventorySchemaVersion`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedInventorySchemaVersionException$, UnsupportedInventorySchemaVersionException);
var UnsupportedOperatingSystem$ = [-3, n0, _UOS,
    { [_aQE]: [`UnsupportedOperatingSystem`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedOperatingSystem$, UnsupportedOperatingSystem);
var UnsupportedOperationException$ = [-3, n0, _UOE,
    { [_aQE]: [`UnsupportedOperation`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedOperationException$, UnsupportedOperationException);
var UnsupportedParameterType$ = [-3, n0, _UPT,
    { [_aQE]: [`UnsupportedParameterType`, 400], [_e]: _c },
    [_m],
    [0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedParameterType$, UnsupportedParameterType);
var UnsupportedPlatformType$ = [-3, n0, _UPTn,
    { [_aQE]: [`UnsupportedPlatformType`, 400], [_e]: _c },
    [_M],
    [0]
];
schema.TypeRegistry.for(n0).registerError(UnsupportedPlatformType$, UnsupportedPlatformType);
var UpdateAssociationRequest$ = [3, n0, _UAR,
    0,
    [_AIss, _P, _DV, _SE, _OL, _N, _Ta, _AN, _AV, _ATPN, _ME, _MC, _CS, _SC, _AOACI, _CN, _TL, _SO, _Du, _TM, _AC],
    [0, [() => _Parameters, 0], 0, 0, () => InstanceAssociationOutputLocation$, 0, () => Targets, 0, 0, 0, 0, 0, 0, 0, 2, 64 | 0, () => TargetLocations, 1, 1, [1, n0, _TM, 0, [2, n0, _TMa, 0, 0, 64 | 0]], () => AlarmConfiguration$], 1
];
var UpdateAssociationResult$ = [3, n0, _UARp,
    0,
    [_AD],
    [[() => AssociationDescription$, 0]]
];
var UpdateAssociationStatusRequest$ = [3, n0, _UASR,
    0,
    [_N, _II, _AS],
    [0, 0, () => AssociationStatus$], 3
];
var UpdateAssociationStatusResult$ = [3, n0, _UASRp,
    0,
    [_AD],
    [[() => AssociationDescription$, 0]]
];
var UpdateDocumentDefaultVersionRequest$ = [3, n0, _UDDVR,
    0,
    [_N, _DV],
    [0, 0], 2
];
var UpdateDocumentDefaultVersionResult$ = [3, n0, _UDDVRp,
    0,
    [_D],
    [() => DocumentDefaultVersionDescription$]
];
var UpdateDocumentMetadataRequest$ = [3, n0, _UDMR,
    0,
    [_N, _DRoc, _DV],
    [0, () => DocumentReviews$, 0], 2
];
var UpdateDocumentMetadataResponse$ = [3, n0, _UDMRp,
    0,
    [],
    []
];
var UpdateDocumentRequest$ = [3, n0, _UDR,
    0,
    [_Con, _N, _At, _DNi, _VN, _DV, _DF, _TT],
    [0, 0, () => AttachmentsSourceList, 0, 0, 0, 0, 0], 2
];
var UpdateDocumentResult$ = [3, n0, _UDRp,
    0,
    [_DD],
    [[() => DocumentDescription$, 0]]
];
var UpdateMaintenanceWindowRequest$ = [3, n0, _UMWR,
    0,
    [_WI, _N, _D, _SDt, _EDn, _Sc, _STc, _SO, _Du, _Cu, _AUT, _Ena, _Repl],
    [0, 0, [() => MaintenanceWindowDescription, 0], 0, 0, 0, 0, 1, 1, 1, 2, 2, 2], 1
];
var UpdateMaintenanceWindowResult$ = [3, n0, _UMWRp,
    0,
    [_WI, _N, _D, _SDt, _EDn, _Sc, _STc, _SO, _Du, _Cu, _AUT, _Ena],
    [0, 0, [() => MaintenanceWindowDescription, 0], 0, 0, 0, 0, 1, 1, 1, 2, 2]
];
var UpdateMaintenanceWindowTargetRequest$ = [3, n0, _UMWTR,
    0,
    [_WI, _WTI, _Ta, _OI, _N, _D, _Repl],
    [0, 0, () => Targets, [() => OwnerInformation, 0], 0, [() => MaintenanceWindowDescription, 0], 2], 2
];
var UpdateMaintenanceWindowTargetResult$ = [3, n0, _UMWTRp,
    0,
    [_WI, _WTI, _Ta, _OI, _N, _D],
    [0, 0, () => Targets, [() => OwnerInformation, 0], 0, [() => MaintenanceWindowDescription, 0]]
];
var UpdateMaintenanceWindowTaskRequest$ = [3, n0, _UMWTRpd,
    0,
    [_WI, _WTIi, _Ta, _TAa, _SRA, _TPa, _TIP, _Pr, _MC, _ME, _LI, _N, _D, _Repl, _CB, _AC],
    [0, 0, () => Targets, 0, 0, [() => MaintenanceWindowTaskParameters, 0], [() => MaintenanceWindowTaskInvocationParameters$, 0], 1, 0, 0, () => LoggingInfo$, 0, [() => MaintenanceWindowDescription, 0], 2, 0, () => AlarmConfiguration$], 2
];
var UpdateMaintenanceWindowTaskResult$ = [3, n0, _UMWTRpda,
    0,
    [_WI, _WTIi, _Ta, _TAa, _SRA, _TPa, _TIP, _Pr, _MC, _ME, _LI, _N, _D, _CB, _AC],
    [0, 0, () => Targets, 0, 0, [() => MaintenanceWindowTaskParameters, 0], [() => MaintenanceWindowTaskInvocationParameters$, 0], 1, 0, 0, () => LoggingInfo$, 0, [() => MaintenanceWindowDescription, 0], 0, () => AlarmConfiguration$]
];
var UpdateManagedInstanceRoleRequest$ = [3, n0, _UMIRR,
    0,
    [_II, _IR],
    [0, 0], 2
];
var UpdateManagedInstanceRoleResult$ = [3, n0, _UMIRRp,
    0,
    [],
    []
];
var UpdateOpsItemRequest$ = [3, n0, _UOIR,
    0,
    [_OII, _D, _OD, _ODTD, _No, _Pr, _ROI, _St, _Ti, _Ca, _Se, _AST, _AETc, _PST, _PET, _OIA],
    [0, 0, () => OpsItemOperationalData, 64 | 0, () => OpsItemNotifications, 1, () => RelatedOpsItems, 0, 0, 0, 0, 4, 4, 4, 4, 0], 1
];
var UpdateOpsItemResponse$ = [3, n0, _UOIRp,
    0,
    [],
    []
];
var UpdateOpsMetadataRequest$ = [3, n0, _UOMR,
    0,
    [_OMA, _MTU, _KTD],
    [0, () => MetadataMap, 64 | 0], 1
];
var UpdateOpsMetadataResult$ = [3, n0, _UOMRp,
    0,
    [_OMA],
    [0]
];
var UpdatePatchBaselineRequest$ = [3, n0, _UPBR,
    0,
    [_BI, _N, _GF, _AR, _AP, _APCL, _APENS, _RP, _RPA, _D, _So, _ASUCS, _Repl],
    [0, 0, () => PatchFilterGroup$, () => PatchRuleGroup$, 64 | 0, 0, 2, 64 | 0, 0, 0, [() => PatchSourceList, 0], 0, 2], 1
];
var UpdatePatchBaselineResult$ = [3, n0, _UPBRp,
    0,
    [_BI, _N, _OSp, _GF, _AR, _AP, _APCL, _APENS, _RP, _RPA, _CD, _MD, _D, _So, _ASUCS],
    [0, 0, 0, () => PatchFilterGroup$, () => PatchRuleGroup$, 64 | 0, 0, 2, 64 | 0, 0, 4, 4, 0, [() => PatchSourceList, 0], 0]
];
var UpdateResourceDataSyncRequest$ = [3, n0, _URDSR,
    0,
    [_SN, _STy, _SSy],
    [0, 0, () => ResourceDataSyncSource$], 3
];
var UpdateResourceDataSyncResult$ = [3, n0, _URDSRp,
    0,
    [],
    []
];
var UpdateServiceSettingRequest$ = [3, n0, _USSR,
    0,
    [_SIe, _SVe],
    [0, 0], 2
];
var UpdateServiceSettingResult$ = [3, n0, _USSRp,
    0,
    [],
    []
];
var ValidationException$ = [-3, n0, _VE,
    { [_aQE]: [`ValidationException`, 400], [_e]: _c },
    [_M, _RCea],
    [0, 0]
];
schema.TypeRegistry.for(n0).registerError(ValidationException$, ValidationException);
var SSMServiceException$ = [-3, _sm, "SSMServiceException", 0, [], []];
schema.TypeRegistry.for(_sm).registerError(SSMServiceException$, SSMServiceException);
var AccountIdList = [1, n0, _AIL,
    0, [0,
        { [_xN]: _AI }]
];
var AccountSharingInfoList = [1, n0, _ASIL,
    0, [() => AccountSharingInfo$,
        { [_xN]: _ASI }]
];
var ActivationList = [1, n0, _AL,
    0, () => Activation$
];
var AlarmList = [1, n0, _ALl,
    0, () => Alarm$
];
var AlarmStateInformationList = [1, n0, _ASILl,
    0, () => AlarmStateInformation$
];
var AssociationDescriptionList = [1, n0, _ADL,
    0, [() => AssociationDescription$,
        { [_xN]: _AD }]
];
var AssociationExecutionFilterList = [1, n0, _AEFL,
    0, [() => AssociationExecutionFilter$,
        { [_xN]: _AEF }]
];
var AssociationExecutionsList = [1, n0, _AEL,
    0, [() => AssociationExecution$,
        { [_xN]: _AE }]
];
var AssociationExecutionTargetsFilterList = [1, n0, _AETFL,
    0, [() => AssociationExecutionTargetsFilter$,
        { [_xN]: _AETF }]
];
var AssociationExecutionTargetsList = [1, n0, _AETL,
    0, [() => AssociationExecutionTarget$,
        { [_xN]: _AET }]
];
var AssociationFilterList = [1, n0, _AFL,
    0, [() => AssociationFilter$,
        { [_xN]: _AF }]
];
var AssociationList = [1, n0, _ALs,
    0, [() => Association$,
        { [_xN]: _As }]
];
var AssociationVersionList = [1, n0, _AVL,
    0, [() => AssociationVersionInfo$,
        0]
];
var AttachmentContentList = [1, n0, _ACL,
    0, [() => AttachmentContent$,
        { [_xN]: _ACt }]
];
var AttachmentInformationList = [1, n0, _AILt,
    0, [() => AttachmentInformation$,
        { [_xN]: _AIt }]
];
var AttachmentsSourceList = [1, n0, _ASL,
    0, () => AttachmentsSource$
];
var AutomationExecutionFilterList = [1, n0, _AEFLu,
    0, () => AutomationExecutionFilter$
];
var AutomationExecutionMetadataList = [1, n0, _AEML,
    0, () => AutomationExecutionMetadata$
];
var CommandFilterList = [1, n0, _CFL,
    0, () => CommandFilter$
];
var CommandInvocationList = [1, n0, _CIL,
    0, () => CommandInvocation$
];
var CommandList = [1, n0, _CLo,
    0, [() => Command$,
        0]
];
var CommandPluginList = [1, n0, _CPL,
    0, () => CommandPlugin$
];
var ComplianceItemEntryList = [1, n0, _CIEL,
    0, () => ComplianceItemEntry$
];
var ComplianceItemList = [1, n0, _CILo,
    0, [() => ComplianceItem$,
        { [_xN]: _Item }]
];
var ComplianceStringFilterList = [1, n0, _CSFL,
    0, [() => ComplianceStringFilter$,
        { [_xN]: _CFo }]
];
var ComplianceStringFilterValueList = [1, n0, _CSFVL,
    0, [0,
        { [_xN]: _FVi }]
];
var ComplianceSummaryItemList = [1, n0, _CSIL,
    0, [() => ComplianceSummaryItem$,
        { [_xN]: _Item }]
];
var CreateAssociationBatchRequestEntries = [1, n0, _CABREr,
    0, [() => CreateAssociationBatchRequestEntry$,
        { [_xN]: _en }]
];
var DescribeActivationsFilterList = [1, n0, _DAFL,
    0, () => DescribeActivationsFilter$
];
var DocumentFilterList = [1, n0, _DFL,
    0, [() => DocumentFilter$,
        { [_xN]: _DFo }]
];
var DocumentIdentifierList = [1, n0, _DIL,
    0, [() => DocumentIdentifier$,
        { [_xN]: _DIo }]
];
var DocumentKeyValuesFilterList = [1, n0, _DKVFL,
    0, () => DocumentKeyValuesFilter$
];
var DocumentParameterList = [1, n0, _DPLo,
    0, [() => DocumentParameter$,
        { [_xN]: _DPo }]
];
var DocumentRequiresList = [1, n0, _DRL,
    0, () => DocumentRequires$
];
var DocumentReviewCommentList = [1, n0, _DRCL,
    0, () => DocumentReviewCommentSource$
];
var DocumentReviewerResponseList = [1, n0, _DRRL,
    0, () => DocumentReviewerResponseSource$
];
var DocumentVersionList = [1, n0, _DVL,
    0, () => DocumentVersionInfo$
];
var EffectivePatchList = [1, n0, _EPL,
    0, () => EffectivePatch$
];
var FailedCreateAssociationList = [1, n0, _FCAL,
    0, [() => FailedCreateAssociation$,
        { [_xN]: _FCAE }]
];
var GetResourcePoliciesResponseEntries = [1, n0, _GRPREe,
    0, () => GetResourcePoliciesResponseEntry$
];
var InstanceAssociationList = [1, n0, _IAL,
    0, () => InstanceAssociation$
];
var InstanceAssociationStatusInfos = [1, n0, _IASI,
    0, () => InstanceAssociationStatusInfo$
];
var InstanceInformationFilterList = [1, n0, _IIFL,
    0, [() => InstanceInformationFilter$,
        { [_xN]: _IIF }]
];
var InstanceInformationFilterValueSet = [1, n0, _IIFVS,
    0, [0,
        { [_xN]: _IIFV }]
];
var InstanceInformationList = [1, n0, _IIL,
    0, [() => InstanceInformation$,
        { [_xN]: _IInst }]
];
var InstanceInformationStringFilterList = [1, n0, _IISFL,
    0, [() => InstanceInformationStringFilter$,
        { [_xN]: _IISF }]
];
var InstancePatchStateFilterList = [1, n0, _IPSFL,
    0, () => InstancePatchStateFilter$
];
var InstancePatchStateList = [1, n0, _IPSL,
    0, [() => InstancePatchState$,
        0]
];
var InstancePatchStatesList = [1, n0, _IPSLn,
    0, [() => InstancePatchState$,
        0]
];
var InstanceProperties = [1, n0, _IPn,
    0, [() => InstanceProperty$,
        { [_xN]: _IPns }]
];
var InstancePropertyFilterList = [1, n0, _IPFL,
    0, [() => InstancePropertyFilter$,
        { [_xN]: _IPF }]
];
var InstancePropertyFilterValueSet = [1, n0, _IPFVS,
    0, [0,
        { [_xN]: _IPFV }]
];
var InstancePropertyStringFilterList = [1, n0, _IPSFLn,
    0, [() => InstancePropertyStringFilter$,
        { [_xN]: _IPSFn }]
];
var InventoryAggregatorList = [1, n0, _IALn,
    0, [() => InventoryAggregator$,
        { [_xN]: _Agg }]
];
var InventoryDeletionsList = [1, n0, _IDL,
    0, () => InventoryDeletionStatusItem$
];
var InventoryDeletionSummaryItems = [1, n0, _IDSInv,
    0, () => InventoryDeletionSummaryItem$
];
var InventoryFilterList = [1, n0, _IFL,
    0, [() => InventoryFilter$,
        { [_xN]: _IFn }]
];
var InventoryFilterValueList = [1, n0, _IFVL,
    0, [0,
        { [_xN]: _FVi }]
];
var InventoryGroupList = [1, n0, _IGL,
    0, [() => InventoryGroup$,
        { [_xN]: _IG }]
];
var InventoryItemAttributeList = [1, n0, _IIAL,
    0, [() => InventoryItemAttribute$,
        { [_xN]: _Attr }]
];
var InventoryItemList = [1, n0, _IILn,
    0, [() => InventoryItem$,
        { [_xN]: _Item }]
];
var InventoryItemSchemaResultList = [1, n0, _IISRL,
    0, [() => InventoryItemSchema$,
        0]
];
var InventoryResultEntityList = [1, n0, _IREL,
    0, [() => InventoryResultEntity$,
        { [_xN]: _Entit }]
];
var MaintenanceWindowExecutionList = [1, n0, _MWEL,
    0, () => MaintenanceWindowExecution$
];
var MaintenanceWindowExecutionTaskIdentityList = [1, n0, _MWETIL,
    0, () => MaintenanceWindowExecutionTaskIdentity$
];
var MaintenanceWindowExecutionTaskInvocationIdentityList = [1, n0, _MWETIIL,
    0, [() => MaintenanceWindowExecutionTaskInvocationIdentity$,
        0]
];
var MaintenanceWindowFilterList = [1, n0, _MWFL,
    0, () => MaintenanceWindowFilter$
];
var MaintenanceWindowIdentityList = [1, n0, _MWIL,
    0, [() => MaintenanceWindowIdentity$,
        0]
];
var MaintenanceWindowsForTargetList = [1, n0, _MWFTL,
    0, () => MaintenanceWindowIdentityForTarget$
];
var MaintenanceWindowTargetList = [1, n0, _MWTL,
    0, [() => MaintenanceWindowTarget$,
        0]
];
var MaintenanceWindowTaskList = [1, n0, _MWTLa,
    0, [() => MaintenanceWindowTask$,
        0]
];
var MaintenanceWindowTaskParametersList = [1, n0, _MWTPL,
    8, [() => MaintenanceWindowTaskParameters,
        0]
];
var MaintenanceWindowTaskParameterValueList = [1, n0, _MWTPVL,
    8, [() => MaintenanceWindowTaskParameterValue,
        0]
];
var NodeAggregatorList = [1, n0, _NAL,
    0, [() => NodeAggregator$,
        { [_xN]: _NA }]
];
var NodeFilterList = [1, n0, _NFL,
    0, [() => NodeFilter$,
        { [_xN]: _NF }]
];
var NodeFilterValueList = [1, n0, _NFVL,
    0, [0,
        { [_xN]: _FVi }]
];
var NodeList = [1, n0, _NL,
    0, [() => Node$,
        0]
];
var OpsAggregatorList = [1, n0, _OAL,
    0, [() => OpsAggregator$,
        { [_xN]: _Agg }]
];
var OpsEntityList = [1, n0, _OEL,
    0, [() => OpsEntity$,
        { [_xN]: _Entit }]
];
var OpsFilterList = [1, n0, _OFL,
    0, [() => OpsFilter$,
        { [_xN]: _OF }]
];
var OpsFilterValueList = [1, n0, _OFVL,
    0, [0,
        { [_xN]: _FVi }]
];
var OpsItemEventFilters = [1, n0, _OIEFp,
    0, () => OpsItemEventFilter$
];
var OpsItemEventSummaries = [1, n0, _OIESp,
    0, () => OpsItemEventSummary$
];
var OpsItemFilters = [1, n0, _OIF,
    0, () => OpsItemFilter$
];
var OpsItemNotifications = [1, n0, _OINp,
    0, () => OpsItemNotification$
];
var OpsItemRelatedItemsFilters = [1, n0, _OIRIFp,
    0, () => OpsItemRelatedItemsFilter$
];
var OpsItemRelatedItemSummaries = [1, n0, _OIRISp,
    0, () => OpsItemRelatedItemSummary$
];
var OpsItemSummaries = [1, n0, _OIS,
    0, () => OpsItemSummary$
];
var OpsMetadataFilterList = [1, n0, _OMFL,
    0, () => OpsMetadataFilter$
];
var OpsMetadataList = [1, n0, _OML,
    0, () => OpsMetadata$
];
var OpsResultAttributeList = [1, n0, _ORAL,
    0, [() => OpsResultAttribute$,
        { [_xN]: _ORA }]
];
var ParameterHistoryList = [1, n0, _PHL,
    0, [() => ParameterHistory$,
        0]
];
var ParameterList = [1, n0, _PL,
    0, [() => Parameter$,
        0]
];
var ParameterMetadataList = [1, n0, _PML,
    0, () => ParameterMetadata$
];
var ParameterPolicyList = [1, n0, _PPLa,
    0, () => ParameterInlinePolicy$
];
var ParametersFilterList = [1, n0, _PFL,
    0, () => ParametersFilter$
];
var ParameterStringFilterList = [1, n0, _PSFL,
    0, () => ParameterStringFilter$
];
var PatchBaselineIdentityList = [1, n0, _PBIL,
    0, () => PatchBaselineIdentity$
];
var PatchComplianceDataList = [1, n0, _PCDL,
    0, () => PatchComplianceData$
];
var PatchFilterList = [1, n0, _PFLa,
    0, () => PatchFilter$
];
var PatchGroupPatchBaselineMappingList = [1, n0, _PGPBML,
    0, () => PatchGroupPatchBaselineMapping$
];
var PatchList = [1, n0, _PLa,
    0, () => Patch$
];
var PatchOrchestratorFilterList = [1, n0, _POFL,
    0, () => PatchOrchestratorFilter$
];
var PatchRuleList = [1, n0, _PRL,
    0, () => PatchRule$
];
var PatchSourceList = [1, n0, _PSL,
    0, [() => PatchSource$,
        0]
];
var PlatformTypeList = [1, n0, _PTL,
    0, [0,
        { [_xN]: _PTla }]
];
var RegistrationMetadataList = [1, n0, _RML,
    0, () => RegistrationMetadataItem$
];
var RelatedOpsItems = [1, n0, _ROI,
    0, () => RelatedOpsItem$
];
var ResourceComplianceSummaryItemList = [1, n0, _RCSIL,
    0, [() => ResourceComplianceSummaryItem$,
        { [_xN]: _Item }]
];
var ResourceDataSyncItemList = [1, n0, _RDSIL,
    0, () => ResourceDataSyncItem$
];
var ResourceDataSyncOrganizationalUnitList = [1, n0, _RDSOUL,
    0, () => ResourceDataSyncOrganizationalUnit$
];
var ResultAttributeList = [1, n0, _RAL,
    0, [() => ResultAttribute$,
        { [_xN]: _RAes }]
];
var ReviewInformationList = [1, n0, _RIL,
    0, [() => ReviewInformation$,
        { [_xN]: _RIe }]
];
var Runbooks = [1, n0, _R,
    0, () => Runbook$
];
var ScheduledWindowExecutionList = [1, n0, _SWEL,
    0, () => ScheduledWindowExecution$
];
var SessionFilterList = [1, n0, _SFL,
    0, () => SessionFilter$
];
var SessionList = [1, n0, _SLe,
    0, () => Session$
];
var StepExecutionFilterList = [1, n0, _SEFL,
    0, () => StepExecutionFilter$
];
var StepExecutionList = [1, n0, _SEL,
    0, () => StepExecution$
];
var TagList = [1, n0, _TLa,
    0, () => Tag$
];
var TargetLocations = [1, n0, _TL,
    0, () => TargetLocation$
];
var TargetPreviewList = [1, n0, _TPL,
    0, () => TargetPreview$
];
var Targets = [1, n0, _Ta,
    0, () => Target$
];
var InventoryResultItemMap = [2, n0, _IRIM,
    0, 0, () => InventoryResultItem$
];
var MaintenanceWindowTaskParameters = [2, n0, _MWTP,
    8, [0,
        0],
    [() => MaintenanceWindowTaskParameterValueExpression$,
        0]
];
var MetadataMap = [2, n0, _MM,
    0, 0, () => MetadataValue$
];
var OpsEntityItemMap = [2, n0, _OEIM,
    0, 0, () => OpsEntityItem$
];
var OpsItemOperationalData = [2, n0, _OIOD,
    0, 0, () => OpsItemDataValue$
];
var _Parameters = [2, n0, _P,
    8, 0, 64 | 0
];
var ExecutionInputs$ = [4, n0, _EIx,
    0,
    [_Aut],
    [() => AutomationExecutionInputs$]
];
var ExecutionPreview$ = [4, n0, _EPx,
    0,
    [_Aut],
    [() => AutomationExecutionPreview$]
];
var NodeType$ = [4, n0, _NTo,
    0,
    [_Ins],
    [[() => InstanceInfo$, 0]]
];
var AddTagsToResource$ = [9, n0, _ATTR,
    0, () => AddTagsToResourceRequest$, () => AddTagsToResourceResult$
];
var AssociateOpsItemRelatedItem$ = [9, n0, _AOIRI,
    0, () => AssociateOpsItemRelatedItemRequest$, () => AssociateOpsItemRelatedItemResponse$
];
var CancelCommand$ = [9, n0, _CCa,
    0, () => CancelCommandRequest$, () => CancelCommandResult$
];
var CancelMaintenanceWindowExecution$ = [9, n0, _CMWE,
    0, () => CancelMaintenanceWindowExecutionRequest$, () => CancelMaintenanceWindowExecutionResult$
];
var CreateActivation$ = [9, n0, _CAr,
    0, () => CreateActivationRequest$, () => CreateActivationResult$
];
var CreateAssociation$ = [9, n0, _CAre,
    0, () => CreateAssociationRequest$, () => CreateAssociationResult$
];
var CreateAssociationBatch$ = [9, n0, _CAB,
    0, () => CreateAssociationBatchRequest$, () => CreateAssociationBatchResult$
];
var CreateDocument$ = [9, n0, _CDre,
    0, () => CreateDocumentRequest$, () => CreateDocumentResult$
];
var CreateMaintenanceWindow$ = [9, n0, _CMW,
    0, () => CreateMaintenanceWindowRequest$, () => CreateMaintenanceWindowResult$
];
var CreateOpsItem$ = [9, n0, _COI,
    0, () => CreateOpsItemRequest$, () => CreateOpsItemResponse$
];
var CreateOpsMetadata$ = [9, n0, _COM,
    0, () => CreateOpsMetadataRequest$, () => CreateOpsMetadataResult$
];
var CreatePatchBaseline$ = [9, n0, _CPB,
    0, () => CreatePatchBaselineRequest$, () => CreatePatchBaselineResult$
];
var CreateResourceDataSync$ = [9, n0, _CRDS,
    0, () => CreateResourceDataSyncRequest$, () => CreateResourceDataSyncResult$
];
var DeleteActivation$ = [9, n0, _DA,
    0, () => DeleteActivationRequest$, () => DeleteActivationResult$
];
var DeleteAssociation$ = [9, n0, _DAe,
    0, () => DeleteAssociationRequest$, () => DeleteAssociationResult$
];
var DeleteDocument$ = [9, n0, _DDe,
    0, () => DeleteDocumentRequest$, () => DeleteDocumentResult$
];
var DeleteInventory$ = [9, n0, _DIe,
    0, () => DeleteInventoryRequest$, () => DeleteInventoryResult$
];
var DeleteMaintenanceWindow$ = [9, n0, _DMW,
    0, () => DeleteMaintenanceWindowRequest$, () => DeleteMaintenanceWindowResult$
];
var DeleteOpsItem$ = [9, n0, _DOI,
    0, () => DeleteOpsItemRequest$, () => DeleteOpsItemResponse$
];
var DeleteOpsMetadata$ = [9, n0, _DOM,
    0, () => DeleteOpsMetadataRequest$, () => DeleteOpsMetadataResult$
];
var DeleteParameter$ = [9, n0, _DPe,
    0, () => DeleteParameterRequest$, () => DeleteParameterResult$
];
var DeleteParameters$ = [9, n0, _DPel,
    0, () => DeleteParametersRequest$, () => DeleteParametersResult$
];
var DeletePatchBaseline$ = [9, n0, _DPB,
    0, () => DeletePatchBaselineRequest$, () => DeletePatchBaselineResult$
];
var DeleteResourceDataSync$ = [9, n0, _DRDS,
    0, () => DeleteResourceDataSyncRequest$, () => DeleteResourceDataSyncResult$
];
var DeleteResourcePolicy$ = [9, n0, _DRP,
    0, () => DeleteResourcePolicyRequest$, () => DeleteResourcePolicyResponse$
];
var DeregisterManagedInstance$ = [9, n0, _DMI,
    0, () => DeregisterManagedInstanceRequest$, () => DeregisterManagedInstanceResult$
];
var DeregisterPatchBaselineForPatchGroup$ = [9, n0, _DPBFPG,
    0, () => DeregisterPatchBaselineForPatchGroupRequest$, () => DeregisterPatchBaselineForPatchGroupResult$
];
var DeregisterTargetFromMaintenanceWindow$ = [9, n0, _DTFMW,
    0, () => DeregisterTargetFromMaintenanceWindowRequest$, () => DeregisterTargetFromMaintenanceWindowResult$
];
var DeregisterTaskFromMaintenanceWindow$ = [9, n0, _DTFMWe,
    0, () => DeregisterTaskFromMaintenanceWindowRequest$, () => DeregisterTaskFromMaintenanceWindowResult$
];
var DescribeActivations$ = [9, n0, _DAes,
    0, () => DescribeActivationsRequest$, () => DescribeActivationsResult$
];
var DescribeAssociation$ = [9, n0, _DAesc,
    0, () => DescribeAssociationRequest$, () => DescribeAssociationResult$
];
var DescribeAssociationExecutions$ = [9, n0, _DAEe,
    0, () => DescribeAssociationExecutionsRequest$, () => DescribeAssociationExecutionsResult$
];
var DescribeAssociationExecutionTargets$ = [9, n0, _DAET,
    0, () => DescribeAssociationExecutionTargetsRequest$, () => DescribeAssociationExecutionTargetsResult$
];
var DescribeAutomationExecutions$ = [9, n0, _DAEes,
    0, () => DescribeAutomationExecutionsRequest$, () => DescribeAutomationExecutionsResult$
];
var DescribeAutomationStepExecutions$ = [9, n0, _DASE,
    0, () => DescribeAutomationStepExecutionsRequest$, () => DescribeAutomationStepExecutionsResult$
];
var DescribeAvailablePatches$ = [9, n0, _DAP,
    0, () => DescribeAvailablePatchesRequest$, () => DescribeAvailablePatchesResult$
];
var DescribeDocument$ = [9, n0, _DDes,
    0, () => DescribeDocumentRequest$, () => DescribeDocumentResult$
];
var DescribeDocumentPermission$ = [9, n0, _DDP,
    0, () => DescribeDocumentPermissionRequest$, () => DescribeDocumentPermissionResponse$
];
var DescribeEffectiveInstanceAssociations$ = [9, n0, _DEIA,
    0, () => DescribeEffectiveInstanceAssociationsRequest$, () => DescribeEffectiveInstanceAssociationsResult$
];
var DescribeEffectivePatchesForPatchBaseline$ = [9, n0, _DEPFPB,
    0, () => DescribeEffectivePatchesForPatchBaselineRequest$, () => DescribeEffectivePatchesForPatchBaselineResult$
];
var DescribeInstanceAssociationsStatus$ = [9, n0, _DIAS,
    0, () => DescribeInstanceAssociationsStatusRequest$, () => DescribeInstanceAssociationsStatusResult$
];
var DescribeInstanceInformation$ = [9, n0, _DIIe,
    0, () => DescribeInstanceInformationRequest$, () => DescribeInstanceInformationResult$
];
var DescribeInstancePatches$ = [9, n0, _DIP,
    0, () => DescribeInstancePatchesRequest$, () => DescribeInstancePatchesResult$
];
var DescribeInstancePatchStates$ = [9, n0, _DIPS,
    0, () => DescribeInstancePatchStatesRequest$, () => DescribeInstancePatchStatesResult$
];
var DescribeInstancePatchStatesForPatchGroup$ = [9, n0, _DIPSFPG,
    0, () => DescribeInstancePatchStatesForPatchGroupRequest$, () => DescribeInstancePatchStatesForPatchGroupResult$
];
var DescribeInstanceProperties$ = [9, n0, _DIPe,
    0, () => DescribeInstancePropertiesRequest$, () => DescribeInstancePropertiesResult$
];
var DescribeInventoryDeletions$ = [9, n0, _DID,
    0, () => DescribeInventoryDeletionsRequest$, () => DescribeInventoryDeletionsResult$
];
var DescribeMaintenanceWindowExecutions$ = [9, n0, _DMWE,
    0, () => DescribeMaintenanceWindowExecutionsRequest$, () => DescribeMaintenanceWindowExecutionsResult$
];
var DescribeMaintenanceWindowExecutionTaskInvocations$ = [9, n0, _DMWETI,
    0, () => DescribeMaintenanceWindowExecutionTaskInvocationsRequest$, () => DescribeMaintenanceWindowExecutionTaskInvocationsResult$
];
var DescribeMaintenanceWindowExecutionTasks$ = [9, n0, _DMWET,
    0, () => DescribeMaintenanceWindowExecutionTasksRequest$, () => DescribeMaintenanceWindowExecutionTasksResult$
];
var DescribeMaintenanceWindows$ = [9, n0, _DMWe,
    0, () => DescribeMaintenanceWindowsRequest$, () => DescribeMaintenanceWindowsResult$
];
var DescribeMaintenanceWindowSchedule$ = [9, n0, _DMWS,
    0, () => DescribeMaintenanceWindowScheduleRequest$, () => DescribeMaintenanceWindowScheduleResult$
];
var DescribeMaintenanceWindowsForTarget$ = [9, n0, _DMWFT,
    0, () => DescribeMaintenanceWindowsForTargetRequest$, () => DescribeMaintenanceWindowsForTargetResult$
];
var DescribeMaintenanceWindowTargets$ = [9, n0, _DMWT,
    0, () => DescribeMaintenanceWindowTargetsRequest$, () => DescribeMaintenanceWindowTargetsResult$
];
var DescribeMaintenanceWindowTasks$ = [9, n0, _DMWTe,
    0, () => DescribeMaintenanceWindowTasksRequest$, () => DescribeMaintenanceWindowTasksResult$
];
var DescribeOpsItems$ = [9, n0, _DOIe,
    0, () => DescribeOpsItemsRequest$, () => DescribeOpsItemsResponse$
];
var DescribeParameters$ = [9, n0, _DPes,
    0, () => DescribeParametersRequest$, () => DescribeParametersResult$
];
var DescribePatchBaselines$ = [9, n0, _DPBe,
    0, () => DescribePatchBaselinesRequest$, () => DescribePatchBaselinesResult$
];
var DescribePatchGroups$ = [9, n0, _DPG,
    0, () => DescribePatchGroupsRequest$, () => DescribePatchGroupsResult$
];
var DescribePatchGroupState$ = [9, n0, _DPGS,
    0, () => DescribePatchGroupStateRequest$, () => DescribePatchGroupStateResult$
];
var DescribePatchProperties$ = [9, n0, _DPP,
    0, () => DescribePatchPropertiesRequest$, () => DescribePatchPropertiesResult$
];
var DescribeSessions$ = [9, n0, _DSes,
    0, () => DescribeSessionsRequest$, () => DescribeSessionsResponse$
];
var DisassociateOpsItemRelatedItem$ = [9, n0, _DOIRI,
    0, () => DisassociateOpsItemRelatedItemRequest$, () => DisassociateOpsItemRelatedItemResponse$
];
var GetAccessToken$ = [9, n0, _GAT,
    0, () => GetAccessTokenRequest$, () => GetAccessTokenResponse$
];
var GetAutomationExecution$ = [9, n0, _GAE,
    0, () => GetAutomationExecutionRequest$, () => GetAutomationExecutionResult$
];
var GetCalendarState$ = [9, n0, _GCS,
    0, () => GetCalendarStateRequest$, () => GetCalendarStateResponse$
];
var GetCommandInvocation$ = [9, n0, _GCI,
    0, () => GetCommandInvocationRequest$, () => GetCommandInvocationResult$
];
var GetConnectionStatus$ = [9, n0, _GCSe,
    0, () => GetConnectionStatusRequest$, () => GetConnectionStatusResponse$
];
var GetDefaultPatchBaseline$ = [9, n0, _GDPB,
    0, () => GetDefaultPatchBaselineRequest$, () => GetDefaultPatchBaselineResult$
];
var GetDeployablePatchSnapshotForInstance$ = [9, n0, _GDPSFI,
    0, () => GetDeployablePatchSnapshotForInstanceRequest$, () => GetDeployablePatchSnapshotForInstanceResult$
];
var GetDocument$ = [9, n0, _GD,
    0, () => GetDocumentRequest$, () => GetDocumentResult$
];
var GetExecutionPreview$ = [9, n0, _GEP,
    0, () => GetExecutionPreviewRequest$, () => GetExecutionPreviewResponse$
];
var GetInventory$ = [9, n0, _GI,
    0, () => GetInventoryRequest$, () => GetInventoryResult$
];
var GetInventorySchema$ = [9, n0, _GIS,
    0, () => GetInventorySchemaRequest$, () => GetInventorySchemaResult$
];
var GetMaintenanceWindow$ = [9, n0, _GMW,
    0, () => GetMaintenanceWindowRequest$, () => GetMaintenanceWindowResult$
];
var GetMaintenanceWindowExecution$ = [9, n0, _GMWE,
    0, () => GetMaintenanceWindowExecutionRequest$, () => GetMaintenanceWindowExecutionResult$
];
var GetMaintenanceWindowExecutionTask$ = [9, n0, _GMWET,
    0, () => GetMaintenanceWindowExecutionTaskRequest$, () => GetMaintenanceWindowExecutionTaskResult$
];
var GetMaintenanceWindowExecutionTaskInvocation$ = [9, n0, _GMWETI,
    0, () => GetMaintenanceWindowExecutionTaskInvocationRequest$, () => GetMaintenanceWindowExecutionTaskInvocationResult$
];
var GetMaintenanceWindowTask$ = [9, n0, _GMWT,
    0, () => GetMaintenanceWindowTaskRequest$, () => GetMaintenanceWindowTaskResult$
];
var GetOpsItem$ = [9, n0, _GOI,
    0, () => GetOpsItemRequest$, () => GetOpsItemResponse$
];
var GetOpsMetadata$ = [9, n0, _GOM,
    0, () => GetOpsMetadataRequest$, () => GetOpsMetadataResult$
];
var GetOpsSummary$ = [9, n0, _GOS,
    0, () => GetOpsSummaryRequest$, () => GetOpsSummaryResult$
];
var GetParameter$ = [9, n0, _GP,
    0, () => GetParameterRequest$, () => GetParameterResult$
];
var GetParameterHistory$ = [9, n0, _GPH,
    0, () => GetParameterHistoryRequest$, () => GetParameterHistoryResult$
];
var GetParameters$ = [9, n0, _GPe,
    0, () => GetParametersRequest$, () => GetParametersResult$
];
var GetParametersByPath$ = [9, n0, _GPBP,
    0, () => GetParametersByPathRequest$, () => GetParametersByPathResult$
];
var GetPatchBaseline$ = [9, n0, _GPB,
    0, () => GetPatchBaselineRequest$, () => GetPatchBaselineResult$
];
var GetPatchBaselineForPatchGroup$ = [9, n0, _GPBFPG,
    0, () => GetPatchBaselineForPatchGroupRequest$, () => GetPatchBaselineForPatchGroupResult$
];
var GetResourcePolicies$ = [9, n0, _GRP,
    0, () => GetResourcePoliciesRequest$, () => GetResourcePoliciesResponse$
];
var GetServiceSetting$ = [9, n0, _GSS,
    0, () => GetServiceSettingRequest$, () => GetServiceSettingResult$
];
var LabelParameterVersion$ = [9, n0, _LPV,
    0, () => LabelParameterVersionRequest$, () => LabelParameterVersionResult$
];
var ListAssociations$ = [9, n0, _LA,
    0, () => ListAssociationsRequest$, () => ListAssociationsResult$
];
var ListAssociationVersions$ = [9, n0, _LAV,
    0, () => ListAssociationVersionsRequest$, () => ListAssociationVersionsResult$
];
var ListCommandInvocations$ = [9, n0, _LCI,
    0, () => ListCommandInvocationsRequest$, () => ListCommandInvocationsResult$
];
var ListCommands$ = [9, n0, _LCi,
    0, () => ListCommandsRequest$, () => ListCommandsResult$
];
var ListComplianceItems$ = [9, n0, _LCIi,
    0, () => ListComplianceItemsRequest$, () => ListComplianceItemsResult$
];
var ListComplianceSummaries$ = [9, n0, _LCS,
    0, () => ListComplianceSummariesRequest$, () => ListComplianceSummariesResult$
];
var ListDocumentMetadataHistory$ = [9, n0, _LDMH,
    0, () => ListDocumentMetadataHistoryRequest$, () => ListDocumentMetadataHistoryResponse$
];
var ListDocuments$ = [9, n0, _LD,
    0, () => ListDocumentsRequest$, () => ListDocumentsResult$
];
var ListDocumentVersions$ = [9, n0, _LDV,
    0, () => ListDocumentVersionsRequest$, () => ListDocumentVersionsResult$
];
var ListInventoryEntries$ = [9, n0, _LIE,
    0, () => ListInventoryEntriesRequest$, () => ListInventoryEntriesResult$
];
var ListNodes$ = [9, n0, _LN,
    0, () => ListNodesRequest$, () => ListNodesResult$
];
var ListNodesSummary$ = [9, n0, _LNS,
    0, () => ListNodesSummaryRequest$, () => ListNodesSummaryResult$
];
var ListOpsItemEvents$ = [9, n0, _LOIE,
    0, () => ListOpsItemEventsRequest$, () => ListOpsItemEventsResponse$
];
var ListOpsItemRelatedItems$ = [9, n0, _LOIRI,
    0, () => ListOpsItemRelatedItemsRequest$, () => ListOpsItemRelatedItemsResponse$
];
var ListOpsMetadata$ = [9, n0, _LOM,
    0, () => ListOpsMetadataRequest$, () => ListOpsMetadataResult$
];
var ListResourceComplianceSummaries$ = [9, n0, _LRCS,
    0, () => ListResourceComplianceSummariesRequest$, () => ListResourceComplianceSummariesResult$
];
var ListResourceDataSync$ = [9, n0, _LRDS,
    0, () => ListResourceDataSyncRequest$, () => ListResourceDataSyncResult$
];
var ListTagsForResource$ = [9, n0, _LTFR,
    0, () => ListTagsForResourceRequest$, () => ListTagsForResourceResult$
];
var ModifyDocumentPermission$ = [9, n0, _MDP,
    0, () => ModifyDocumentPermissionRequest$, () => ModifyDocumentPermissionResponse$
];
var PutComplianceItems$ = [9, n0, _PCI,
    0, () => PutComplianceItemsRequest$, () => PutComplianceItemsResult$
];
var PutInventory$ = [9, n0, _PIu,
    0, () => PutInventoryRequest$, () => PutInventoryResult$
];
var PutParameter$ = [9, n0, _PP,
    0, () => PutParameterRequest$, () => PutParameterResult$
];
var PutResourcePolicy$ = [9, n0, _PRP,
    0, () => PutResourcePolicyRequest$, () => PutResourcePolicyResponse$
];
var RegisterDefaultPatchBaseline$ = [9, n0, _RDPB,
    0, () => RegisterDefaultPatchBaselineRequest$, () => RegisterDefaultPatchBaselineResult$
];
var RegisterPatchBaselineForPatchGroup$ = [9, n0, _RPBFPG,
    0, () => RegisterPatchBaselineForPatchGroupRequest$, () => RegisterPatchBaselineForPatchGroupResult$
];
var RegisterTargetWithMaintenanceWindow$ = [9, n0, _RTWMW,
    0, () => RegisterTargetWithMaintenanceWindowRequest$, () => RegisterTargetWithMaintenanceWindowResult$
];
var RegisterTaskWithMaintenanceWindow$ = [9, n0, _RTWMWe,
    0, () => RegisterTaskWithMaintenanceWindowRequest$, () => RegisterTaskWithMaintenanceWindowResult$
];
var RemoveTagsFromResource$ = [9, n0, _RTFR,
    0, () => RemoveTagsFromResourceRequest$, () => RemoveTagsFromResourceResult$
];
var ResetServiceSetting$ = [9, n0, _RSS,
    0, () => ResetServiceSettingRequest$, () => ResetServiceSettingResult$
];
var ResumeSession$ = [9, n0, _RSe,
    0, () => ResumeSessionRequest$, () => ResumeSessionResponse$
];
var SendAutomationSignal$ = [9, n0, _SAS,
    0, () => SendAutomationSignalRequest$, () => SendAutomationSignalResult$
];
var SendCommand$ = [9, n0, _SCen,
    0, () => SendCommandRequest$, () => SendCommandResult$
];
var StartAccessRequest$ = [9, n0, _SAR,
    0, () => StartAccessRequestRequest$, () => StartAccessRequestResponse$
];
var StartAssociationsOnce$ = [9, n0, _SAO,
    0, () => StartAssociationsOnceRequest$, () => StartAssociationsOnceResult$
];
var StartAutomationExecution$ = [9, n0, _SAE,
    0, () => StartAutomationExecutionRequest$, () => StartAutomationExecutionResult$
];
var StartChangeRequestExecution$ = [9, n0, _SCRE,
    0, () => StartChangeRequestExecutionRequest$, () => StartChangeRequestExecutionResult$
];
var StartExecutionPreview$ = [9, n0, _SEP,
    0, () => StartExecutionPreviewRequest$, () => StartExecutionPreviewResponse$
];
var StartSession$ = [9, n0, _SSta,
    0, () => StartSessionRequest$, () => StartSessionResponse$
];
var StopAutomationExecution$ = [9, n0, _SAEt,
    0, () => StopAutomationExecutionRequest$, () => StopAutomationExecutionResult$
];
var TerminateSession$ = [9, n0, _TSe,
    0, () => TerminateSessionRequest$, () => TerminateSessionResponse$
];
var UnlabelParameterVersion$ = [9, n0, _UPV,
    0, () => UnlabelParameterVersionRequest$, () => UnlabelParameterVersionResult$
];
var UpdateAssociation$ = [9, n0, _UA,
    0, () => UpdateAssociationRequest$, () => UpdateAssociationResult$
];
var UpdateAssociationStatus$ = [9, n0, _UAS,
    0, () => UpdateAssociationStatusRequest$, () => UpdateAssociationStatusResult$
];
var UpdateDocument$ = [9, n0, _UD,
    0, () => UpdateDocumentRequest$, () => UpdateDocumentResult$
];
var UpdateDocumentDefaultVersion$ = [9, n0, _UDDV,
    0, () => UpdateDocumentDefaultVersionRequest$, () => UpdateDocumentDefaultVersionResult$
];
var UpdateDocumentMetadata$ = [9, n0, _UDM,
    0, () => UpdateDocumentMetadataRequest$, () => UpdateDocumentMetadataResponse$
];
var UpdateMaintenanceWindow$ = [9, n0, _UMW,
    0, () => UpdateMaintenanceWindowRequest$, () => UpdateMaintenanceWindowResult$
];
var UpdateMaintenanceWindowTarget$ = [9, n0, _UMWT,
    0, () => UpdateMaintenanceWindowTargetRequest$, () => UpdateMaintenanceWindowTargetResult$
];
var UpdateMaintenanceWindowTask$ = [9, n0, _UMWTp,
    0, () => UpdateMaintenanceWindowTaskRequest$, () => UpdateMaintenanceWindowTaskResult$
];
var UpdateManagedInstanceRole$ = [9, n0, _UMIR,
    0, () => UpdateManagedInstanceRoleRequest$, () => UpdateManagedInstanceRoleResult$
];
var UpdateOpsItem$ = [9, n0, _UOI,
    0, () => UpdateOpsItemRequest$, () => UpdateOpsItemResponse$
];
var UpdateOpsMetadata$ = [9, n0, _UOM,
    0, () => UpdateOpsMetadataRequest$, () => UpdateOpsMetadataResult$
];
var UpdatePatchBaseline$ = [9, n0, _UPB,
    0, () => UpdatePatchBaselineRequest$, () => UpdatePatchBaselineResult$
];
var UpdateResourceDataSync$ = [9, n0, _URDS,
    0, () => UpdateResourceDataSyncRequest$, () => UpdateResourceDataSyncResult$
];
var UpdateServiceSetting$ = [9, n0, _USS,
    0, () => UpdateServiceSettingRequest$, () => UpdateServiceSettingResult$
];

class AddTagsToResourceCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "AddTagsToResource", {})
    .n("SSMClient", "AddTagsToResourceCommand")
    .sc(AddTagsToResource$)
    .build() {
}

class AssociateOpsItemRelatedItemCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "AssociateOpsItemRelatedItem", {})
    .n("SSMClient", "AssociateOpsItemRelatedItemCommand")
    .sc(AssociateOpsItemRelatedItem$)
    .build() {
}

class CancelCommandCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CancelCommand", {})
    .n("SSMClient", "CancelCommandCommand")
    .sc(CancelCommand$)
    .build() {
}

class CancelMaintenanceWindowExecutionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CancelMaintenanceWindowExecution", {})
    .n("SSMClient", "CancelMaintenanceWindowExecutionCommand")
    .sc(CancelMaintenanceWindowExecution$)
    .build() {
}

class CreateActivationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateActivation", {})
    .n("SSMClient", "CreateActivationCommand")
    .sc(CreateActivation$)
    .build() {
}

class CreateAssociationBatchCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateAssociationBatch", {})
    .n("SSMClient", "CreateAssociationBatchCommand")
    .sc(CreateAssociationBatch$)
    .build() {
}

class CreateAssociationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateAssociation", {})
    .n("SSMClient", "CreateAssociationCommand")
    .sc(CreateAssociation$)
    .build() {
}

class CreateDocumentCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateDocument", {})
    .n("SSMClient", "CreateDocumentCommand")
    .sc(CreateDocument$)
    .build() {
}

class CreateMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateMaintenanceWindow", {})
    .n("SSMClient", "CreateMaintenanceWindowCommand")
    .sc(CreateMaintenanceWindow$)
    .build() {
}

class CreateOpsItemCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateOpsItem", {})
    .n("SSMClient", "CreateOpsItemCommand")
    .sc(CreateOpsItem$)
    .build() {
}

class CreateOpsMetadataCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateOpsMetadata", {})
    .n("SSMClient", "CreateOpsMetadataCommand")
    .sc(CreateOpsMetadata$)
    .build() {
}

class CreatePatchBaselineCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreatePatchBaseline", {})
    .n("SSMClient", "CreatePatchBaselineCommand")
    .sc(CreatePatchBaseline$)
    .build() {
}

class CreateResourceDataSyncCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "CreateResourceDataSync", {})
    .n("SSMClient", "CreateResourceDataSyncCommand")
    .sc(CreateResourceDataSync$)
    .build() {
}

class DeleteActivationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteActivation", {})
    .n("SSMClient", "DeleteActivationCommand")
    .sc(DeleteActivation$)
    .build() {
}

class DeleteAssociationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteAssociation", {})
    .n("SSMClient", "DeleteAssociationCommand")
    .sc(DeleteAssociation$)
    .build() {
}

class DeleteDocumentCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteDocument", {})
    .n("SSMClient", "DeleteDocumentCommand")
    .sc(DeleteDocument$)
    .build() {
}

class DeleteInventoryCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteInventory", {})
    .n("SSMClient", "DeleteInventoryCommand")
    .sc(DeleteInventory$)
    .build() {
}

class DeleteMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteMaintenanceWindow", {})
    .n("SSMClient", "DeleteMaintenanceWindowCommand")
    .sc(DeleteMaintenanceWindow$)
    .build() {
}

class DeleteOpsItemCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteOpsItem", {})
    .n("SSMClient", "DeleteOpsItemCommand")
    .sc(DeleteOpsItem$)
    .build() {
}

class DeleteOpsMetadataCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteOpsMetadata", {})
    .n("SSMClient", "DeleteOpsMetadataCommand")
    .sc(DeleteOpsMetadata$)
    .build() {
}

class DeleteParameterCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteParameter", {})
    .n("SSMClient", "DeleteParameterCommand")
    .sc(DeleteParameter$)
    .build() {
}

class DeleteParametersCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteParameters", {})
    .n("SSMClient", "DeleteParametersCommand")
    .sc(DeleteParameters$)
    .build() {
}

class DeletePatchBaselineCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeletePatchBaseline", {})
    .n("SSMClient", "DeletePatchBaselineCommand")
    .sc(DeletePatchBaseline$)
    .build() {
}

class DeleteResourceDataSyncCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteResourceDataSync", {})
    .n("SSMClient", "DeleteResourceDataSyncCommand")
    .sc(DeleteResourceDataSync$)
    .build() {
}

class DeleteResourcePolicyCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeleteResourcePolicy", {})
    .n("SSMClient", "DeleteResourcePolicyCommand")
    .sc(DeleteResourcePolicy$)
    .build() {
}

class DeregisterManagedInstanceCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeregisterManagedInstance", {})
    .n("SSMClient", "DeregisterManagedInstanceCommand")
    .sc(DeregisterManagedInstance$)
    .build() {
}

class DeregisterPatchBaselineForPatchGroupCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeregisterPatchBaselineForPatchGroup", {})
    .n("SSMClient", "DeregisterPatchBaselineForPatchGroupCommand")
    .sc(DeregisterPatchBaselineForPatchGroup$)
    .build() {
}

class DeregisterTargetFromMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeregisterTargetFromMaintenanceWindow", {})
    .n("SSMClient", "DeregisterTargetFromMaintenanceWindowCommand")
    .sc(DeregisterTargetFromMaintenanceWindow$)
    .build() {
}

class DeregisterTaskFromMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DeregisterTaskFromMaintenanceWindow", {})
    .n("SSMClient", "DeregisterTaskFromMaintenanceWindowCommand")
    .sc(DeregisterTaskFromMaintenanceWindow$)
    .build() {
}

class DescribeActivationsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeActivations", {})
    .n("SSMClient", "DescribeActivationsCommand")
    .sc(DescribeActivations$)
    .build() {
}

class DescribeAssociationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeAssociation", {})
    .n("SSMClient", "DescribeAssociationCommand")
    .sc(DescribeAssociation$)
    .build() {
}

class DescribeAssociationExecutionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeAssociationExecutions", {})
    .n("SSMClient", "DescribeAssociationExecutionsCommand")
    .sc(DescribeAssociationExecutions$)
    .build() {
}

class DescribeAssociationExecutionTargetsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeAssociationExecutionTargets", {})
    .n("SSMClient", "DescribeAssociationExecutionTargetsCommand")
    .sc(DescribeAssociationExecutionTargets$)
    .build() {
}

class DescribeAutomationExecutionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeAutomationExecutions", {})
    .n("SSMClient", "DescribeAutomationExecutionsCommand")
    .sc(DescribeAutomationExecutions$)
    .build() {
}

class DescribeAutomationStepExecutionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeAutomationStepExecutions", {})
    .n("SSMClient", "DescribeAutomationStepExecutionsCommand")
    .sc(DescribeAutomationStepExecutions$)
    .build() {
}

class DescribeAvailablePatchesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeAvailablePatches", {})
    .n("SSMClient", "DescribeAvailablePatchesCommand")
    .sc(DescribeAvailablePatches$)
    .build() {
}

class DescribeDocumentCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeDocument", {})
    .n("SSMClient", "DescribeDocumentCommand")
    .sc(DescribeDocument$)
    .build() {
}

class DescribeDocumentPermissionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeDocumentPermission", {})
    .n("SSMClient", "DescribeDocumentPermissionCommand")
    .sc(DescribeDocumentPermission$)
    .build() {
}

class DescribeEffectiveInstanceAssociationsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeEffectiveInstanceAssociations", {})
    .n("SSMClient", "DescribeEffectiveInstanceAssociationsCommand")
    .sc(DescribeEffectiveInstanceAssociations$)
    .build() {
}

class DescribeEffectivePatchesForPatchBaselineCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeEffectivePatchesForPatchBaseline", {})
    .n("SSMClient", "DescribeEffectivePatchesForPatchBaselineCommand")
    .sc(DescribeEffectivePatchesForPatchBaseline$)
    .build() {
}

class DescribeInstanceAssociationsStatusCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeInstanceAssociationsStatus", {})
    .n("SSMClient", "DescribeInstanceAssociationsStatusCommand")
    .sc(DescribeInstanceAssociationsStatus$)
    .build() {
}

class DescribeInstanceInformationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeInstanceInformation", {})
    .n("SSMClient", "DescribeInstanceInformationCommand")
    .sc(DescribeInstanceInformation$)
    .build() {
}

class DescribeInstancePatchesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeInstancePatches", {})
    .n("SSMClient", "DescribeInstancePatchesCommand")
    .sc(DescribeInstancePatches$)
    .build() {
}

class DescribeInstancePatchStatesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeInstancePatchStates", {})
    .n("SSMClient", "DescribeInstancePatchStatesCommand")
    .sc(DescribeInstancePatchStates$)
    .build() {
}

class DescribeInstancePatchStatesForPatchGroupCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeInstancePatchStatesForPatchGroup", {})
    .n("SSMClient", "DescribeInstancePatchStatesForPatchGroupCommand")
    .sc(DescribeInstancePatchStatesForPatchGroup$)
    .build() {
}

class DescribeInstancePropertiesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeInstanceProperties", {})
    .n("SSMClient", "DescribeInstancePropertiesCommand")
    .sc(DescribeInstanceProperties$)
    .build() {
}

class DescribeInventoryDeletionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeInventoryDeletions", {})
    .n("SSMClient", "DescribeInventoryDeletionsCommand")
    .sc(DescribeInventoryDeletions$)
    .build() {
}

class DescribeMaintenanceWindowExecutionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindowExecutions", {})
    .n("SSMClient", "DescribeMaintenanceWindowExecutionsCommand")
    .sc(DescribeMaintenanceWindowExecutions$)
    .build() {
}

class DescribeMaintenanceWindowExecutionTaskInvocationsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindowExecutionTaskInvocations", {})
    .n("SSMClient", "DescribeMaintenanceWindowExecutionTaskInvocationsCommand")
    .sc(DescribeMaintenanceWindowExecutionTaskInvocations$)
    .build() {
}

class DescribeMaintenanceWindowExecutionTasksCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindowExecutionTasks", {})
    .n("SSMClient", "DescribeMaintenanceWindowExecutionTasksCommand")
    .sc(DescribeMaintenanceWindowExecutionTasks$)
    .build() {
}

class DescribeMaintenanceWindowScheduleCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindowSchedule", {})
    .n("SSMClient", "DescribeMaintenanceWindowScheduleCommand")
    .sc(DescribeMaintenanceWindowSchedule$)
    .build() {
}

class DescribeMaintenanceWindowsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindows", {})
    .n("SSMClient", "DescribeMaintenanceWindowsCommand")
    .sc(DescribeMaintenanceWindows$)
    .build() {
}

class DescribeMaintenanceWindowsForTargetCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindowsForTarget", {})
    .n("SSMClient", "DescribeMaintenanceWindowsForTargetCommand")
    .sc(DescribeMaintenanceWindowsForTarget$)
    .build() {
}

class DescribeMaintenanceWindowTargetsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindowTargets", {})
    .n("SSMClient", "DescribeMaintenanceWindowTargetsCommand")
    .sc(DescribeMaintenanceWindowTargets$)
    .build() {
}

class DescribeMaintenanceWindowTasksCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeMaintenanceWindowTasks", {})
    .n("SSMClient", "DescribeMaintenanceWindowTasksCommand")
    .sc(DescribeMaintenanceWindowTasks$)
    .build() {
}

class DescribeOpsItemsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeOpsItems", {})
    .n("SSMClient", "DescribeOpsItemsCommand")
    .sc(DescribeOpsItems$)
    .build() {
}

class DescribeParametersCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeParameters", {})
    .n("SSMClient", "DescribeParametersCommand")
    .sc(DescribeParameters$)
    .build() {
}

class DescribePatchBaselinesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribePatchBaselines", {})
    .n("SSMClient", "DescribePatchBaselinesCommand")
    .sc(DescribePatchBaselines$)
    .build() {
}

class DescribePatchGroupsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribePatchGroups", {})
    .n("SSMClient", "DescribePatchGroupsCommand")
    .sc(DescribePatchGroups$)
    .build() {
}

class DescribePatchGroupStateCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribePatchGroupState", {})
    .n("SSMClient", "DescribePatchGroupStateCommand")
    .sc(DescribePatchGroupState$)
    .build() {
}

class DescribePatchPropertiesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribePatchProperties", {})
    .n("SSMClient", "DescribePatchPropertiesCommand")
    .sc(DescribePatchProperties$)
    .build() {
}

class DescribeSessionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DescribeSessions", {})
    .n("SSMClient", "DescribeSessionsCommand")
    .sc(DescribeSessions$)
    .build() {
}

class DisassociateOpsItemRelatedItemCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "DisassociateOpsItemRelatedItem", {})
    .n("SSMClient", "DisassociateOpsItemRelatedItemCommand")
    .sc(DisassociateOpsItemRelatedItem$)
    .build() {
}

class GetAccessTokenCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetAccessToken", {})
    .n("SSMClient", "GetAccessTokenCommand")
    .sc(GetAccessToken$)
    .build() {
}

class GetAutomationExecutionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetAutomationExecution", {})
    .n("SSMClient", "GetAutomationExecutionCommand")
    .sc(GetAutomationExecution$)
    .build() {
}

class GetCalendarStateCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetCalendarState", {})
    .n("SSMClient", "GetCalendarStateCommand")
    .sc(GetCalendarState$)
    .build() {
}

class GetCommandInvocationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetCommandInvocation", {})
    .n("SSMClient", "GetCommandInvocationCommand")
    .sc(GetCommandInvocation$)
    .build() {
}

class GetConnectionStatusCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetConnectionStatus", {})
    .n("SSMClient", "GetConnectionStatusCommand")
    .sc(GetConnectionStatus$)
    .build() {
}

class GetDefaultPatchBaselineCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetDefaultPatchBaseline", {})
    .n("SSMClient", "GetDefaultPatchBaselineCommand")
    .sc(GetDefaultPatchBaseline$)
    .build() {
}

class GetDeployablePatchSnapshotForInstanceCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetDeployablePatchSnapshotForInstance", {})
    .n("SSMClient", "GetDeployablePatchSnapshotForInstanceCommand")
    .sc(GetDeployablePatchSnapshotForInstance$)
    .build() {
}

class GetDocumentCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetDocument", {})
    .n("SSMClient", "GetDocumentCommand")
    .sc(GetDocument$)
    .build() {
}

class GetExecutionPreviewCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetExecutionPreview", {})
    .n("SSMClient", "GetExecutionPreviewCommand")
    .sc(GetExecutionPreview$)
    .build() {
}

class GetInventoryCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetInventory", {})
    .n("SSMClient", "GetInventoryCommand")
    .sc(GetInventory$)
    .build() {
}

class GetInventorySchemaCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetInventorySchema", {})
    .n("SSMClient", "GetInventorySchemaCommand")
    .sc(GetInventorySchema$)
    .build() {
}

class GetMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetMaintenanceWindow", {})
    .n("SSMClient", "GetMaintenanceWindowCommand")
    .sc(GetMaintenanceWindow$)
    .build() {
}

class GetMaintenanceWindowExecutionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetMaintenanceWindowExecution", {})
    .n("SSMClient", "GetMaintenanceWindowExecutionCommand")
    .sc(GetMaintenanceWindowExecution$)
    .build() {
}

class GetMaintenanceWindowExecutionTaskCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetMaintenanceWindowExecutionTask", {})
    .n("SSMClient", "GetMaintenanceWindowExecutionTaskCommand")
    .sc(GetMaintenanceWindowExecutionTask$)
    .build() {
}

class GetMaintenanceWindowExecutionTaskInvocationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetMaintenanceWindowExecutionTaskInvocation", {})
    .n("SSMClient", "GetMaintenanceWindowExecutionTaskInvocationCommand")
    .sc(GetMaintenanceWindowExecutionTaskInvocation$)
    .build() {
}

class GetMaintenanceWindowTaskCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetMaintenanceWindowTask", {})
    .n("SSMClient", "GetMaintenanceWindowTaskCommand")
    .sc(GetMaintenanceWindowTask$)
    .build() {
}

class GetOpsItemCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetOpsItem", {})
    .n("SSMClient", "GetOpsItemCommand")
    .sc(GetOpsItem$)
    .build() {
}

class GetOpsMetadataCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetOpsMetadata", {})
    .n("SSMClient", "GetOpsMetadataCommand")
    .sc(GetOpsMetadata$)
    .build() {
}

class GetOpsSummaryCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetOpsSummary", {})
    .n("SSMClient", "GetOpsSummaryCommand")
    .sc(GetOpsSummary$)
    .build() {
}

class GetParameterCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetParameter", {})
    .n("SSMClient", "GetParameterCommand")
    .sc(GetParameter$)
    .build() {
}

class GetParameterHistoryCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetParameterHistory", {})
    .n("SSMClient", "GetParameterHistoryCommand")
    .sc(GetParameterHistory$)
    .build() {
}

class GetParametersByPathCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetParametersByPath", {})
    .n("SSMClient", "GetParametersByPathCommand")
    .sc(GetParametersByPath$)
    .build() {
}

class GetParametersCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetParameters", {})
    .n("SSMClient", "GetParametersCommand")
    .sc(GetParameters$)
    .build() {
}

class GetPatchBaselineCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetPatchBaseline", {})
    .n("SSMClient", "GetPatchBaselineCommand")
    .sc(GetPatchBaseline$)
    .build() {
}

class GetPatchBaselineForPatchGroupCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetPatchBaselineForPatchGroup", {})
    .n("SSMClient", "GetPatchBaselineForPatchGroupCommand")
    .sc(GetPatchBaselineForPatchGroup$)
    .build() {
}

class GetResourcePoliciesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetResourcePolicies", {})
    .n("SSMClient", "GetResourcePoliciesCommand")
    .sc(GetResourcePolicies$)
    .build() {
}

class GetServiceSettingCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "GetServiceSetting", {})
    .n("SSMClient", "GetServiceSettingCommand")
    .sc(GetServiceSetting$)
    .build() {
}

class LabelParameterVersionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "LabelParameterVersion", {})
    .n("SSMClient", "LabelParameterVersionCommand")
    .sc(LabelParameterVersion$)
    .build() {
}

class ListAssociationsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListAssociations", {})
    .n("SSMClient", "ListAssociationsCommand")
    .sc(ListAssociations$)
    .build() {
}

class ListAssociationVersionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListAssociationVersions", {})
    .n("SSMClient", "ListAssociationVersionsCommand")
    .sc(ListAssociationVersions$)
    .build() {
}

class ListCommandInvocationsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListCommandInvocations", {})
    .n("SSMClient", "ListCommandInvocationsCommand")
    .sc(ListCommandInvocations$)
    .build() {
}

class ListCommandsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListCommands", {})
    .n("SSMClient", "ListCommandsCommand")
    .sc(ListCommands$)
    .build() {
}

class ListComplianceItemsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListComplianceItems", {})
    .n("SSMClient", "ListComplianceItemsCommand")
    .sc(ListComplianceItems$)
    .build() {
}

class ListComplianceSummariesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListComplianceSummaries", {})
    .n("SSMClient", "ListComplianceSummariesCommand")
    .sc(ListComplianceSummaries$)
    .build() {
}

class ListDocumentMetadataHistoryCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListDocumentMetadataHistory", {})
    .n("SSMClient", "ListDocumentMetadataHistoryCommand")
    .sc(ListDocumentMetadataHistory$)
    .build() {
}

class ListDocumentsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListDocuments", {})
    .n("SSMClient", "ListDocumentsCommand")
    .sc(ListDocuments$)
    .build() {
}

class ListDocumentVersionsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListDocumentVersions", {})
    .n("SSMClient", "ListDocumentVersionsCommand")
    .sc(ListDocumentVersions$)
    .build() {
}

class ListInventoryEntriesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListInventoryEntries", {})
    .n("SSMClient", "ListInventoryEntriesCommand")
    .sc(ListInventoryEntries$)
    .build() {
}

class ListNodesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListNodes", {})
    .n("SSMClient", "ListNodesCommand")
    .sc(ListNodes$)
    .build() {
}

class ListNodesSummaryCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListNodesSummary", {})
    .n("SSMClient", "ListNodesSummaryCommand")
    .sc(ListNodesSummary$)
    .build() {
}

class ListOpsItemEventsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListOpsItemEvents", {})
    .n("SSMClient", "ListOpsItemEventsCommand")
    .sc(ListOpsItemEvents$)
    .build() {
}

class ListOpsItemRelatedItemsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListOpsItemRelatedItems", {})
    .n("SSMClient", "ListOpsItemRelatedItemsCommand")
    .sc(ListOpsItemRelatedItems$)
    .build() {
}

class ListOpsMetadataCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListOpsMetadata", {})
    .n("SSMClient", "ListOpsMetadataCommand")
    .sc(ListOpsMetadata$)
    .build() {
}

class ListResourceComplianceSummariesCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListResourceComplianceSummaries", {})
    .n("SSMClient", "ListResourceComplianceSummariesCommand")
    .sc(ListResourceComplianceSummaries$)
    .build() {
}

class ListResourceDataSyncCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListResourceDataSync", {})
    .n("SSMClient", "ListResourceDataSyncCommand")
    .sc(ListResourceDataSync$)
    .build() {
}

class ListTagsForResourceCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ListTagsForResource", {})
    .n("SSMClient", "ListTagsForResourceCommand")
    .sc(ListTagsForResource$)
    .build() {
}

class ModifyDocumentPermissionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ModifyDocumentPermission", {})
    .n("SSMClient", "ModifyDocumentPermissionCommand")
    .sc(ModifyDocumentPermission$)
    .build() {
}

class PutComplianceItemsCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "PutComplianceItems", {})
    .n("SSMClient", "PutComplianceItemsCommand")
    .sc(PutComplianceItems$)
    .build() {
}

class PutInventoryCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "PutInventory", {})
    .n("SSMClient", "PutInventoryCommand")
    .sc(PutInventory$)
    .build() {
}

class PutParameterCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "PutParameter", {})
    .n("SSMClient", "PutParameterCommand")
    .sc(PutParameter$)
    .build() {
}

class PutResourcePolicyCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "PutResourcePolicy", {})
    .n("SSMClient", "PutResourcePolicyCommand")
    .sc(PutResourcePolicy$)
    .build() {
}

class RegisterDefaultPatchBaselineCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "RegisterDefaultPatchBaseline", {})
    .n("SSMClient", "RegisterDefaultPatchBaselineCommand")
    .sc(RegisterDefaultPatchBaseline$)
    .build() {
}

class RegisterPatchBaselineForPatchGroupCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "RegisterPatchBaselineForPatchGroup", {})
    .n("SSMClient", "RegisterPatchBaselineForPatchGroupCommand")
    .sc(RegisterPatchBaselineForPatchGroup$)
    .build() {
}

class RegisterTargetWithMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "RegisterTargetWithMaintenanceWindow", {})
    .n("SSMClient", "RegisterTargetWithMaintenanceWindowCommand")
    .sc(RegisterTargetWithMaintenanceWindow$)
    .build() {
}

class RegisterTaskWithMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "RegisterTaskWithMaintenanceWindow", {})
    .n("SSMClient", "RegisterTaskWithMaintenanceWindowCommand")
    .sc(RegisterTaskWithMaintenanceWindow$)
    .build() {
}

class RemoveTagsFromResourceCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "RemoveTagsFromResource", {})
    .n("SSMClient", "RemoveTagsFromResourceCommand")
    .sc(RemoveTagsFromResource$)
    .build() {
}

class ResetServiceSettingCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ResetServiceSetting", {})
    .n("SSMClient", "ResetServiceSettingCommand")
    .sc(ResetServiceSetting$)
    .build() {
}

class ResumeSessionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "ResumeSession", {})
    .n("SSMClient", "ResumeSessionCommand")
    .sc(ResumeSession$)
    .build() {
}

class SendAutomationSignalCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "SendAutomationSignal", {})
    .n("SSMClient", "SendAutomationSignalCommand")
    .sc(SendAutomationSignal$)
    .build() {
}

class SendCommandCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "SendCommand", {})
    .n("SSMClient", "SendCommandCommand")
    .sc(SendCommand$)
    .build() {
}

class StartAccessRequestCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "StartAccessRequest", {})
    .n("SSMClient", "StartAccessRequestCommand")
    .sc(StartAccessRequest$)
    .build() {
}

class StartAssociationsOnceCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "StartAssociationsOnce", {})
    .n("SSMClient", "StartAssociationsOnceCommand")
    .sc(StartAssociationsOnce$)
    .build() {
}

class StartAutomationExecutionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "StartAutomationExecution", {})
    .n("SSMClient", "StartAutomationExecutionCommand")
    .sc(StartAutomationExecution$)
    .build() {
}

class StartChangeRequestExecutionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "StartChangeRequestExecution", {})
    .n("SSMClient", "StartChangeRequestExecutionCommand")
    .sc(StartChangeRequestExecution$)
    .build() {
}

class StartExecutionPreviewCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "StartExecutionPreview", {})
    .n("SSMClient", "StartExecutionPreviewCommand")
    .sc(StartExecutionPreview$)
    .build() {
}

class StartSessionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "StartSession", {})
    .n("SSMClient", "StartSessionCommand")
    .sc(StartSession$)
    .build() {
}

class StopAutomationExecutionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "StopAutomationExecution", {})
    .n("SSMClient", "StopAutomationExecutionCommand")
    .sc(StopAutomationExecution$)
    .build() {
}

class TerminateSessionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "TerminateSession", {})
    .n("SSMClient", "TerminateSessionCommand")
    .sc(TerminateSession$)
    .build() {
}

class UnlabelParameterVersionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UnlabelParameterVersion", {})
    .n("SSMClient", "UnlabelParameterVersionCommand")
    .sc(UnlabelParameterVersion$)
    .build() {
}

class UpdateAssociationCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateAssociation", {})
    .n("SSMClient", "UpdateAssociationCommand")
    .sc(UpdateAssociation$)
    .build() {
}

class UpdateAssociationStatusCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateAssociationStatus", {})
    .n("SSMClient", "UpdateAssociationStatusCommand")
    .sc(UpdateAssociationStatus$)
    .build() {
}

class UpdateDocumentCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateDocument", {})
    .n("SSMClient", "UpdateDocumentCommand")
    .sc(UpdateDocument$)
    .build() {
}

class UpdateDocumentDefaultVersionCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateDocumentDefaultVersion", {})
    .n("SSMClient", "UpdateDocumentDefaultVersionCommand")
    .sc(UpdateDocumentDefaultVersion$)
    .build() {
}

class UpdateDocumentMetadataCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateDocumentMetadata", {})
    .n("SSMClient", "UpdateDocumentMetadataCommand")
    .sc(UpdateDocumentMetadata$)
    .build() {
}

class UpdateMaintenanceWindowCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateMaintenanceWindow", {})
    .n("SSMClient", "UpdateMaintenanceWindowCommand")
    .sc(UpdateMaintenanceWindow$)
    .build() {
}

class UpdateMaintenanceWindowTargetCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateMaintenanceWindowTarget", {})
    .n("SSMClient", "UpdateMaintenanceWindowTargetCommand")
    .sc(UpdateMaintenanceWindowTarget$)
    .build() {
}

class UpdateMaintenanceWindowTaskCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateMaintenanceWindowTask", {})
    .n("SSMClient", "UpdateMaintenanceWindowTaskCommand")
    .sc(UpdateMaintenanceWindowTask$)
    .build() {
}

class UpdateManagedInstanceRoleCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateManagedInstanceRole", {})
    .n("SSMClient", "UpdateManagedInstanceRoleCommand")
    .sc(UpdateManagedInstanceRole$)
    .build() {
}

class UpdateOpsItemCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateOpsItem", {})
    .n("SSMClient", "UpdateOpsItemCommand")
    .sc(UpdateOpsItem$)
    .build() {
}

class UpdateOpsMetadataCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateOpsMetadata", {})
    .n("SSMClient", "UpdateOpsMetadataCommand")
    .sc(UpdateOpsMetadata$)
    .build() {
}

class UpdatePatchBaselineCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdatePatchBaseline", {})
    .n("SSMClient", "UpdatePatchBaselineCommand")
    .sc(UpdatePatchBaseline$)
    .build() {
}

class UpdateResourceDataSyncCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateResourceDataSync", {})
    .n("SSMClient", "UpdateResourceDataSyncCommand")
    .sc(UpdateResourceDataSync$)
    .build() {
}

class UpdateServiceSettingCommand extends smithyClient.Command
    .classBuilder()
    .ep(commonParams)
    .m(function (Command, cs, config, o) {
    return [middlewareEndpoint.getEndpointPlugin(config, Command.getEndpointParameterInstructions())];
})
    .s("AmazonSSM", "UpdateServiceSetting", {})
    .n("SSMClient", "UpdateServiceSettingCommand")
    .sc(UpdateServiceSetting$)
    .build() {
}

const commands = {
    AddTagsToResourceCommand,
    AssociateOpsItemRelatedItemCommand,
    CancelCommandCommand,
    CancelMaintenanceWindowExecutionCommand,
    CreateActivationCommand,
    CreateAssociationCommand,
    CreateAssociationBatchCommand,
    CreateDocumentCommand,
    CreateMaintenanceWindowCommand,
    CreateOpsItemCommand,
    CreateOpsMetadataCommand,
    CreatePatchBaselineCommand,
    CreateResourceDataSyncCommand,
    DeleteActivationCommand,
    DeleteAssociationCommand,
    DeleteDocumentCommand,
    DeleteInventoryCommand,
    DeleteMaintenanceWindowCommand,
    DeleteOpsItemCommand,
    DeleteOpsMetadataCommand,
    DeleteParameterCommand,
    DeleteParametersCommand,
    DeletePatchBaselineCommand,
    DeleteResourceDataSyncCommand,
    DeleteResourcePolicyCommand,
    DeregisterManagedInstanceCommand,
    DeregisterPatchBaselineForPatchGroupCommand,
    DeregisterTargetFromMaintenanceWindowCommand,
    DeregisterTaskFromMaintenanceWindowCommand,
    DescribeActivationsCommand,
    DescribeAssociationCommand,
    DescribeAssociationExecutionsCommand,
    DescribeAssociationExecutionTargetsCommand,
    DescribeAutomationExecutionsCommand,
    DescribeAutomationStepExecutionsCommand,
    DescribeAvailablePatchesCommand,
    DescribeDocumentCommand,
    DescribeDocumentPermissionCommand,
    DescribeEffectiveInstanceAssociationsCommand,
    DescribeEffectivePatchesForPatchBaselineCommand,
    DescribeInstanceAssociationsStatusCommand,
    DescribeInstanceInformationCommand,
    DescribeInstancePatchesCommand,
    DescribeInstancePatchStatesCommand,
    DescribeInstancePatchStatesForPatchGroupCommand,
    DescribeInstancePropertiesCommand,
    DescribeInventoryDeletionsCommand,
    DescribeMaintenanceWindowExecutionsCommand,
    DescribeMaintenanceWindowExecutionTaskInvocationsCommand,
    DescribeMaintenanceWindowExecutionTasksCommand,
    DescribeMaintenanceWindowsCommand,
    DescribeMaintenanceWindowScheduleCommand,
    DescribeMaintenanceWindowsForTargetCommand,
    DescribeMaintenanceWindowTargetsCommand,
    DescribeMaintenanceWindowTasksCommand,
    DescribeOpsItemsCommand,
    DescribeParametersCommand,
    DescribePatchBaselinesCommand,
    DescribePatchGroupsCommand,
    DescribePatchGroupStateCommand,
    DescribePatchPropertiesCommand,
    DescribeSessionsCommand,
    DisassociateOpsItemRelatedItemCommand,
    GetAccessTokenCommand,
    GetAutomationExecutionCommand,
    GetCalendarStateCommand,
    GetCommandInvocationCommand,
    GetConnectionStatusCommand,
    GetDefaultPatchBaselineCommand,
    GetDeployablePatchSnapshotForInstanceCommand,
    GetDocumentCommand,
    GetExecutionPreviewCommand,
    GetInventoryCommand,
    GetInventorySchemaCommand,
    GetMaintenanceWindowCommand,
    GetMaintenanceWindowExecutionCommand,
    GetMaintenanceWindowExecutionTaskCommand,
    GetMaintenanceWindowExecutionTaskInvocationCommand,
    GetMaintenanceWindowTaskCommand,
    GetOpsItemCommand,
    GetOpsMetadataCommand,
    GetOpsSummaryCommand,
    GetParameterCommand,
    GetParameterHistoryCommand,
    GetParametersCommand,
    GetParametersByPathCommand,
    GetPatchBaselineCommand,
    GetPatchBaselineForPatchGroupCommand,
    GetResourcePoliciesCommand,
    GetServiceSettingCommand,
    LabelParameterVersionCommand,
    ListAssociationsCommand,
    ListAssociationVersionsCommand,
    ListCommandInvocationsCommand,
    ListCommandsCommand,
    ListComplianceItemsCommand,
    ListComplianceSummariesCommand,
    ListDocumentMetadataHistoryCommand,
    ListDocumentsCommand,
    ListDocumentVersionsCommand,
    ListInventoryEntriesCommand,
    ListNodesCommand,
    ListNodesSummaryCommand,
    ListOpsItemEventsCommand,
    ListOpsItemRelatedItemsCommand,
    ListOpsMetadataCommand,
    ListResourceComplianceSummariesCommand,
    ListResourceDataSyncCommand,
    ListTagsForResourceCommand,
    ModifyDocumentPermissionCommand,
    PutComplianceItemsCommand,
    PutInventoryCommand,
    PutParameterCommand,
    PutResourcePolicyCommand,
    RegisterDefaultPatchBaselineCommand,
    RegisterPatchBaselineForPatchGroupCommand,
    RegisterTargetWithMaintenanceWindowCommand,
    RegisterTaskWithMaintenanceWindowCommand,
    RemoveTagsFromResourceCommand,
    ResetServiceSettingCommand,
    ResumeSessionCommand,
    SendAutomationSignalCommand,
    SendCommandCommand,
    StartAccessRequestCommand,
    StartAssociationsOnceCommand,
    StartAutomationExecutionCommand,
    StartChangeRequestExecutionCommand,
    StartExecutionPreviewCommand,
    StartSessionCommand,
    StopAutomationExecutionCommand,
    TerminateSessionCommand,
    UnlabelParameterVersionCommand,
    UpdateAssociationCommand,
    UpdateAssociationStatusCommand,
    UpdateDocumentCommand,
    UpdateDocumentDefaultVersionCommand,
    UpdateDocumentMetadataCommand,
    UpdateMaintenanceWindowCommand,
    UpdateMaintenanceWindowTargetCommand,
    UpdateMaintenanceWindowTaskCommand,
    UpdateManagedInstanceRoleCommand,
    UpdateOpsItemCommand,
    UpdateOpsMetadataCommand,
    UpdatePatchBaselineCommand,
    UpdateResourceDataSyncCommand,
    UpdateServiceSettingCommand,
};
class SSM extends SSMClient {
}
smithyClient.createAggregatedClient(commands, SSM);

const paginateDescribeActivations = core.createPaginator(SSMClient, DescribeActivationsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeAssociationExecutions = core.createPaginator(SSMClient, DescribeAssociationExecutionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeAssociationExecutionTargets = core.createPaginator(SSMClient, DescribeAssociationExecutionTargetsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeAutomationExecutions = core.createPaginator(SSMClient, DescribeAutomationExecutionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeAutomationStepExecutions = core.createPaginator(SSMClient, DescribeAutomationStepExecutionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeAvailablePatches = core.createPaginator(SSMClient, DescribeAvailablePatchesCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeEffectiveInstanceAssociations = core.createPaginator(SSMClient, DescribeEffectiveInstanceAssociationsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeEffectivePatchesForPatchBaseline = core.createPaginator(SSMClient, DescribeEffectivePatchesForPatchBaselineCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeInstanceAssociationsStatus = core.createPaginator(SSMClient, DescribeInstanceAssociationsStatusCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeInstanceInformation = core.createPaginator(SSMClient, DescribeInstanceInformationCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeInstancePatches = core.createPaginator(SSMClient, DescribeInstancePatchesCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeInstancePatchStates = core.createPaginator(SSMClient, DescribeInstancePatchStatesCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeInstancePatchStatesForPatchGroup = core.createPaginator(SSMClient, DescribeInstancePatchStatesForPatchGroupCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeInstanceProperties = core.createPaginator(SSMClient, DescribeInstancePropertiesCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeInventoryDeletions = core.createPaginator(SSMClient, DescribeInventoryDeletionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindowExecutions = core.createPaginator(SSMClient, DescribeMaintenanceWindowExecutionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindowExecutionTaskInvocations = core.createPaginator(SSMClient, DescribeMaintenanceWindowExecutionTaskInvocationsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindowExecutionTasks = core.createPaginator(SSMClient, DescribeMaintenanceWindowExecutionTasksCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindows = core.createPaginator(SSMClient, DescribeMaintenanceWindowsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindowSchedule = core.createPaginator(SSMClient, DescribeMaintenanceWindowScheduleCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindowsForTarget = core.createPaginator(SSMClient, DescribeMaintenanceWindowsForTargetCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindowTargets = core.createPaginator(SSMClient, DescribeMaintenanceWindowTargetsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeMaintenanceWindowTasks = core.createPaginator(SSMClient, DescribeMaintenanceWindowTasksCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeOpsItems = core.createPaginator(SSMClient, DescribeOpsItemsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeParameters = core.createPaginator(SSMClient, DescribeParametersCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribePatchBaselines = core.createPaginator(SSMClient, DescribePatchBaselinesCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribePatchGroups = core.createPaginator(SSMClient, DescribePatchGroupsCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribePatchProperties = core.createPaginator(SSMClient, DescribePatchPropertiesCommand, "NextToken", "NextToken", "MaxResults");

const paginateDescribeSessions = core.createPaginator(SSMClient, DescribeSessionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateGetInventory = core.createPaginator(SSMClient, GetInventoryCommand, "NextToken", "NextToken", "MaxResults");

const paginateGetInventorySchema = core.createPaginator(SSMClient, GetInventorySchemaCommand, "NextToken", "NextToken", "MaxResults");

const paginateGetOpsSummary = core.createPaginator(SSMClient, GetOpsSummaryCommand, "NextToken", "NextToken", "MaxResults");

const paginateGetParameterHistory = core.createPaginator(SSMClient, GetParameterHistoryCommand, "NextToken", "NextToken", "MaxResults");

const paginateGetParametersByPath = core.createPaginator(SSMClient, GetParametersByPathCommand, "NextToken", "NextToken", "MaxResults");

const paginateGetResourcePolicies = core.createPaginator(SSMClient, GetResourcePoliciesCommand, "NextToken", "NextToken", "MaxResults");

const paginateListAssociations = core.createPaginator(SSMClient, ListAssociationsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListAssociationVersions = core.createPaginator(SSMClient, ListAssociationVersionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListCommandInvocations = core.createPaginator(SSMClient, ListCommandInvocationsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListCommands = core.createPaginator(SSMClient, ListCommandsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListComplianceItems = core.createPaginator(SSMClient, ListComplianceItemsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListComplianceSummaries = core.createPaginator(SSMClient, ListComplianceSummariesCommand, "NextToken", "NextToken", "MaxResults");

const paginateListDocuments = core.createPaginator(SSMClient, ListDocumentsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListDocumentVersions = core.createPaginator(SSMClient, ListDocumentVersionsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListNodes = core.createPaginator(SSMClient, ListNodesCommand, "NextToken", "NextToken", "MaxResults");

const paginateListNodesSummary = core.createPaginator(SSMClient, ListNodesSummaryCommand, "NextToken", "NextToken", "MaxResults");

const paginateListOpsItemEvents = core.createPaginator(SSMClient, ListOpsItemEventsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListOpsItemRelatedItems = core.createPaginator(SSMClient, ListOpsItemRelatedItemsCommand, "NextToken", "NextToken", "MaxResults");

const paginateListOpsMetadata = core.createPaginator(SSMClient, ListOpsMetadataCommand, "NextToken", "NextToken", "MaxResults");

const paginateListResourceComplianceSummaries = core.createPaginator(SSMClient, ListResourceComplianceSummariesCommand, "NextToken", "NextToken", "MaxResults");

const paginateListResourceDataSync = core.createPaginator(SSMClient, ListResourceDataSyncCommand, "NextToken", "NextToken", "MaxResults");

const checkState = async (client, input) => {
    let reason;
    try {
        let result = await client.send(new GetCommandInvocationCommand(input));
        reason = result;
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "Pending") {
                return { state: utilWaiter.WaiterState.RETRY, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "InProgress") {
                return { state: utilWaiter.WaiterState.RETRY, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "Delayed") {
                return { state: utilWaiter.WaiterState.RETRY, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "Success") {
                return { state: utilWaiter.WaiterState.SUCCESS, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "Cancelled") {
                return { state: utilWaiter.WaiterState.FAILURE, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "TimedOut") {
                return { state: utilWaiter.WaiterState.FAILURE, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "Failed") {
                return { state: utilWaiter.WaiterState.FAILURE, reason };
            }
        }
        catch (e) { }
        try {
            const returnComparator = () => {
                return result.Status;
            };
            if (returnComparator() === "Cancelling") {
                return { state: utilWaiter.WaiterState.FAILURE, reason };
            }
        }
        catch (e) { }
    }
    catch (exception) {
        reason = exception;
        if (exception.name && exception.name == "InvocationDoesNotExist") {
            return { state: utilWaiter.WaiterState.RETRY, reason };
        }
    }
    return { state: utilWaiter.WaiterState.RETRY, reason };
};
const waitForCommandExecuted = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    return utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState);
};
const waitUntilCommandExecuted = async (params, input) => {
    const serviceDefaults = { minDelay: 5, maxDelay: 120 };
    const result = await utilWaiter.createWaiter({ ...serviceDefaults, ...params }, input, checkState);
    return utilWaiter.checkExceptions(result);
};

const AccessRequestStatus = {
    APPROVED: "Approved",
    EXPIRED: "Expired",
    PENDING: "Pending",
    REJECTED: "Rejected",
    REVOKED: "Revoked",
};
const AccessType = {
    JUSTINTIME: "JustInTime",
    STANDARD: "Standard",
};
const ResourceTypeForTagging = {
    ASSOCIATION: "Association",
    AUTOMATION: "Automation",
    DOCUMENT: "Document",
    MAINTENANCE_WINDOW: "MaintenanceWindow",
    MANAGED_INSTANCE: "ManagedInstance",
    OPSMETADATA: "OpsMetadata",
    OPS_ITEM: "OpsItem",
    PARAMETER: "Parameter",
    PATCH_BASELINE: "PatchBaseline",
};
const ExternalAlarmState = {
    ALARM: "ALARM",
    UNKNOWN: "UNKNOWN",
};
const AssociationComplianceSeverity = {
    Critical: "CRITICAL",
    High: "HIGH",
    Low: "LOW",
    Medium: "MEDIUM",
    Unspecified: "UNSPECIFIED",
};
const AssociationSyncCompliance = {
    Auto: "AUTO",
    Manual: "MANUAL",
};
const AssociationStatusName = {
    Failed: "Failed",
    Pending: "Pending",
    Success: "Success",
};
const Fault = {
    Client: "Client",
    Server: "Server",
    Unknown: "Unknown",
};
const AttachmentsSourceKey = {
    AttachmentReference: "AttachmentReference",
    S3FileUrl: "S3FileUrl",
    SourceUrl: "SourceUrl",
};
const DocumentFormat = {
    JSON: "JSON",
    TEXT: "TEXT",
    YAML: "YAML",
};
const DocumentType = {
    ApplicationConfiguration: "ApplicationConfiguration",
    ApplicationConfigurationSchema: "ApplicationConfigurationSchema",
    AutoApprovalPolicy: "AutoApprovalPolicy",
    Automation: "Automation",
    ChangeCalendar: "ChangeCalendar",
    ChangeTemplate: "Automation.ChangeTemplate",
    CloudFormation: "CloudFormation",
    Command: "Command",
    ConformancePackTemplate: "ConformancePackTemplate",
    DeploymentStrategy: "DeploymentStrategy",
    ManualApprovalPolicy: "ManualApprovalPolicy",
    Package: "Package",
    Policy: "Policy",
    ProblemAnalysis: "ProblemAnalysis",
    ProblemAnalysisTemplate: "ProblemAnalysisTemplate",
    QuickSetup: "QuickSetup",
    Session: "Session",
};
const DocumentHashType = {
    SHA1: "Sha1",
    SHA256: "Sha256",
};
const DocumentParameterType = {
    String: "String",
    StringList: "StringList",
};
const PlatformType = {
    LINUX: "Linux",
    MACOS: "MacOS",
    WINDOWS: "Windows",
};
const ReviewStatus = {
    APPROVED: "APPROVED",
    NOT_REVIEWED: "NOT_REVIEWED",
    PENDING: "PENDING",
    REJECTED: "REJECTED",
};
const DocumentStatus = {
    Active: "Active",
    Creating: "Creating",
    Deleting: "Deleting",
    Failed: "Failed",
    Updating: "Updating",
};
const OpsItemDataType = {
    SEARCHABLE_STRING: "SearchableString",
    STRING: "String",
};
const PatchComplianceLevel = {
    Critical: "CRITICAL",
    High: "HIGH",
    Informational: "INFORMATIONAL",
    Low: "LOW",
    Medium: "MEDIUM",
    Unspecified: "UNSPECIFIED",
};
const PatchFilterKey = {
    AdvisoryId: "ADVISORY_ID",
    Arch: "ARCH",
    BugzillaId: "BUGZILLA_ID",
    CVEId: "CVE_ID",
    Classification: "CLASSIFICATION",
    Epoch: "EPOCH",
    MsrcSeverity: "MSRC_SEVERITY",
    Name: "NAME",
    PatchId: "PATCH_ID",
    PatchSet: "PATCH_SET",
    Priority: "PRIORITY",
    Product: "PRODUCT",
    ProductFamily: "PRODUCT_FAMILY",
    Release: "RELEASE",
    Repository: "REPOSITORY",
    Section: "SECTION",
    Security: "SECURITY",
    Severity: "SEVERITY",
    Version: "VERSION",
};
const PatchComplianceStatus = {
    Compliant: "COMPLIANT",
    NonCompliant: "NON_COMPLIANT",
};
const OperatingSystem = {
    AlmaLinux: "ALMA_LINUX",
    AmazonLinux: "AMAZON_LINUX",
    AmazonLinux2: "AMAZON_LINUX_2",
    AmazonLinux2022: "AMAZON_LINUX_2022",
    AmazonLinux2023: "AMAZON_LINUX_2023",
    CentOS: "CENTOS",
    Debian: "DEBIAN",
    MacOS: "MACOS",
    OracleLinux: "ORACLE_LINUX",
    Raspbian: "RASPBIAN",
    RedhatEnterpriseLinux: "REDHAT_ENTERPRISE_LINUX",
    Rocky_Linux: "ROCKY_LINUX",
    Suse: "SUSE",
    Ubuntu: "UBUNTU",
    Windows: "WINDOWS",
};
const PatchAction = {
    AllowAsDependency: "ALLOW_AS_DEPENDENCY",
    Block: "BLOCK",
};
const ResourceDataSyncS3Format = {
    JSON_SERDE: "JsonSerDe",
};
const InventorySchemaDeleteOption = {
    DELETE_SCHEMA: "DeleteSchema",
    DISABLE_SCHEMA: "DisableSchema",
};
const DescribeActivationsFilterKeys = {
    ACTIVATION_IDS: "ActivationIds",
    DEFAULT_INSTANCE_NAME: "DefaultInstanceName",
    IAM_ROLE: "IamRole",
};
const AssociationExecutionFilterKey = {
    CreatedTime: "CreatedTime",
    ExecutionId: "ExecutionId",
    Status: "Status",
};
const AssociationFilterOperatorType = {
    Equal: "EQUAL",
    GreaterThan: "GREATER_THAN",
    LessThan: "LESS_THAN",
};
const AssociationExecutionTargetsFilterKey = {
    ResourceId: "ResourceId",
    ResourceType: "ResourceType",
    Status: "Status",
};
const AutomationExecutionFilterKey = {
    AUTOMATION_SUBTYPE: "AutomationSubtype",
    AUTOMATION_TYPE: "AutomationType",
    CURRENT_ACTION: "CurrentAction",
    DOCUMENT_NAME_PREFIX: "DocumentNamePrefix",
    EXECUTION_ID: "ExecutionId",
    EXECUTION_STATUS: "ExecutionStatus",
    OPS_ITEM_ID: "OpsItemId",
    PARENT_EXECUTION_ID: "ParentExecutionId",
    START_TIME_AFTER: "StartTimeAfter",
    START_TIME_BEFORE: "StartTimeBefore",
    TAG_KEY: "TagKey",
    TARGET_RESOURCE_GROUP: "TargetResourceGroup",
};
const AutomationExecutionStatus = {
    APPROVED: "Approved",
    CANCELLED: "Cancelled",
    CANCELLING: "Cancelling",
    CHANGE_CALENDAR_OVERRIDE_APPROVED: "ChangeCalendarOverrideApproved",
    CHANGE_CALENDAR_OVERRIDE_REJECTED: "ChangeCalendarOverrideRejected",
    COMPLETED_WITH_FAILURE: "CompletedWithFailure",
    COMPLETED_WITH_SUCCESS: "CompletedWithSuccess",
    EXITED: "Exited",
    FAILED: "Failed",
    INPROGRESS: "InProgress",
    PENDING: "Pending",
    PENDING_APPROVAL: "PendingApproval",
    PENDING_CHANGE_CALENDAR_OVERRIDE: "PendingChangeCalendarOverride",
    REJECTED: "Rejected",
    RUNBOOK_INPROGRESS: "RunbookInProgress",
    SCHEDULED: "Scheduled",
    SUCCESS: "Success",
    TIMEDOUT: "TimedOut",
    WAITING: "Waiting",
};
const AutomationSubtype = {
    AccessRequest: "AccessRequest",
    ChangeRequest: "ChangeRequest",
};
const AutomationType = {
    CrossAccount: "CrossAccount",
    Local: "Local",
};
const ExecutionMode = {
    Auto: "Auto",
    Interactive: "Interactive",
};
const StepExecutionFilterKey = {
    ACTION: "Action",
    PARENT_STEP_EXECUTION_ID: "ParentStepExecutionId",
    PARENT_STEP_ITERATION: "ParentStepIteration",
    PARENT_STEP_ITERATOR_VALUE: "ParentStepIteratorValue",
    START_TIME_AFTER: "StartTimeAfter",
    START_TIME_BEFORE: "StartTimeBefore",
    STEP_EXECUTION_ID: "StepExecutionId",
    STEP_EXECUTION_STATUS: "StepExecutionStatus",
    STEP_NAME: "StepName",
};
const DocumentPermissionType = {
    SHARE: "Share",
};
const PatchDeploymentStatus = {
    Approved: "APPROVED",
    ExplicitApproved: "EXPLICIT_APPROVED",
    ExplicitRejected: "EXPLICIT_REJECTED",
    PendingApproval: "PENDING_APPROVAL",
};
const InstanceInformationFilterKey = {
    ACTIVATION_IDS: "ActivationIds",
    AGENT_VERSION: "AgentVersion",
    ASSOCIATION_STATUS: "AssociationStatus",
    IAM_ROLE: "IamRole",
    INSTANCE_IDS: "InstanceIds",
    PING_STATUS: "PingStatus",
    PLATFORM_TYPES: "PlatformTypes",
    RESOURCE_TYPE: "ResourceType",
};
const PingStatus = {
    CONNECTION_LOST: "ConnectionLost",
    INACTIVE: "Inactive",
    ONLINE: "Online",
};
const ResourceType = {
    EC2_INSTANCE: "EC2Instance",
    MANAGED_INSTANCE: "ManagedInstance",
};
const SourceType = {
    AWS_EC2_INSTANCE: "AWS::EC2::Instance",
    AWS_IOT_THING: "AWS::IoT::Thing",
    AWS_SSM_MANAGEDINSTANCE: "AWS::SSM::ManagedInstance",
};
const PatchComplianceDataState = {
    AvailableSecurityUpdate: "AVAILABLE_SECURITY_UPDATE",
    Failed: "FAILED",
    Installed: "INSTALLED",
    InstalledOther: "INSTALLED_OTHER",
    InstalledPendingReboot: "INSTALLED_PENDING_REBOOT",
    InstalledRejected: "INSTALLED_REJECTED",
    Missing: "MISSING",
    NotApplicable: "NOT_APPLICABLE",
};
const PatchOperationType = {
    INSTALL: "Install",
    SCAN: "Scan",
};
const RebootOption = {
    NO_REBOOT: "NoReboot",
    REBOOT_IF_NEEDED: "RebootIfNeeded",
};
const InstancePatchStateOperatorType = {
    EQUAL: "Equal",
    GREATER_THAN: "GreaterThan",
    LESS_THAN: "LessThan",
    NOT_EQUAL: "NotEqual",
};
const InstancePropertyFilterOperator = {
    BEGIN_WITH: "BeginWith",
    EQUAL: "Equal",
    GREATER_THAN: "GreaterThan",
    LESS_THAN: "LessThan",
    NOT_EQUAL: "NotEqual",
};
const InstancePropertyFilterKey = {
    ACTIVATION_IDS: "ActivationIds",
    AGENT_VERSION: "AgentVersion",
    ASSOCIATION_STATUS: "AssociationStatus",
    DOCUMENT_NAME: "DocumentName",
    IAM_ROLE: "IamRole",
    INSTANCE_IDS: "InstanceIds",
    PING_STATUS: "PingStatus",
    PLATFORM_TYPES: "PlatformTypes",
    RESOURCE_TYPE: "ResourceType",
};
const InventoryDeletionStatus = {
    COMPLETE: "Complete",
    IN_PROGRESS: "InProgress",
};
const MaintenanceWindowExecutionStatus = {
    Cancelled: "CANCELLED",
    Cancelling: "CANCELLING",
    Failed: "FAILED",
    InProgress: "IN_PROGRESS",
    Pending: "PENDING",
    SkippedOverlapping: "SKIPPED_OVERLAPPING",
    Success: "SUCCESS",
    TimedOut: "TIMED_OUT",
};
const MaintenanceWindowTaskType = {
    Automation: "AUTOMATION",
    Lambda: "LAMBDA",
    RunCommand: "RUN_COMMAND",
    StepFunctions: "STEP_FUNCTIONS",
};
const MaintenanceWindowResourceType = {
    Instance: "INSTANCE",
    ResourceGroup: "RESOURCE_GROUP",
};
const MaintenanceWindowTaskCutoffBehavior = {
    CancelTask: "CANCEL_TASK",
    ContinueTask: "CONTINUE_TASK",
};
const OpsItemFilterKey = {
    ACCESS_REQUEST_APPROVER_ARN: "AccessRequestByApproverArn",
    ACCESS_REQUEST_APPROVER_ID: "AccessRequestByApproverId",
    ACCESS_REQUEST_IS_REPLICA: "AccessRequestByIsReplica",
    ACCESS_REQUEST_REQUESTER_ARN: "AccessRequestByRequesterArn",
    ACCESS_REQUEST_REQUESTER_ID: "AccessRequestByRequesterId",
    ACCESS_REQUEST_SOURCE_ACCOUNT_ID: "AccessRequestBySourceAccountId",
    ACCESS_REQUEST_SOURCE_OPS_ITEM_ID: "AccessRequestBySourceOpsItemId",
    ACCESS_REQUEST_SOURCE_REGION: "AccessRequestBySourceRegion",
    ACCESS_REQUEST_TARGET_RESOURCE_ID: "AccessRequestByTargetResourceId",
    ACCOUNT_ID: "AccountId",
    ACTUAL_END_TIME: "ActualEndTime",
    ACTUAL_START_TIME: "ActualStartTime",
    AUTOMATION_ID: "AutomationId",
    CATEGORY: "Category",
    CHANGE_REQUEST_APPROVER_ARN: "ChangeRequestByApproverArn",
    CHANGE_REQUEST_APPROVER_NAME: "ChangeRequestByApproverName",
    CHANGE_REQUEST_REQUESTER_ARN: "ChangeRequestByRequesterArn",
    CHANGE_REQUEST_REQUESTER_NAME: "ChangeRequestByRequesterName",
    CHANGE_REQUEST_TARGETS_RESOURCE_GROUP: "ChangeRequestByTargetsResourceGroup",
    CHANGE_REQUEST_TEMPLATE: "ChangeRequestByTemplate",
    CREATED_BY: "CreatedBy",
    CREATED_TIME: "CreatedTime",
    INSIGHT_TYPE: "InsightByType",
    LAST_MODIFIED_TIME: "LastModifiedTime",
    OPERATIONAL_DATA: "OperationalData",
    OPERATIONAL_DATA_KEY: "OperationalDataKey",
    OPERATIONAL_DATA_VALUE: "OperationalDataValue",
    OPSITEM_ID: "OpsItemId",
    OPSITEM_TYPE: "OpsItemType",
    PLANNED_END_TIME: "PlannedEndTime",
    PLANNED_START_TIME: "PlannedStartTime",
    PRIORITY: "Priority",
    RESOURCE_ID: "ResourceId",
    SEVERITY: "Severity",
    SOURCE: "Source",
    STATUS: "Status",
    TITLE: "Title",
};
const OpsItemFilterOperator = {
    CONTAINS: "Contains",
    EQUAL: "Equal",
    GREATER_THAN: "GreaterThan",
    LESS_THAN: "LessThan",
};
const OpsItemStatus = {
    APPROVED: "Approved",
    CANCELLED: "Cancelled",
    CANCELLING: "Cancelling",
    CHANGE_CALENDAR_OVERRIDE_APPROVED: "ChangeCalendarOverrideApproved",
    CHANGE_CALENDAR_OVERRIDE_REJECTED: "ChangeCalendarOverrideRejected",
    CLOSED: "Closed",
    COMPLETED_WITH_FAILURE: "CompletedWithFailure",
    COMPLETED_WITH_SUCCESS: "CompletedWithSuccess",
    FAILED: "Failed",
    IN_PROGRESS: "InProgress",
    OPEN: "Open",
    PENDING: "Pending",
    PENDING_APPROVAL: "PendingApproval",
    PENDING_CHANGE_CALENDAR_OVERRIDE: "PendingChangeCalendarOverride",
    REJECTED: "Rejected",
    RESOLVED: "Resolved",
    REVOKED: "Revoked",
    RUNBOOK_IN_PROGRESS: "RunbookInProgress",
    SCHEDULED: "Scheduled",
    TIMED_OUT: "TimedOut",
};
const ParametersFilterKey = {
    KEY_ID: "KeyId",
    NAME: "Name",
    TYPE: "Type",
};
const ParameterTier = {
    ADVANCED: "Advanced",
    INTELLIGENT_TIERING: "Intelligent-Tiering",
    STANDARD: "Standard",
};
const ParameterType = {
    SECURE_STRING: "SecureString",
    STRING: "String",
    STRING_LIST: "StringList",
};
const PatchSet = {
    Application: "APPLICATION",
    Os: "OS",
};
const PatchProperty = {
    PatchClassification: "CLASSIFICATION",
    PatchMsrcSeverity: "MSRC_SEVERITY",
    PatchPriority: "PRIORITY",
    PatchProductFamily: "PRODUCT_FAMILY",
    PatchSeverity: "SEVERITY",
    Product: "PRODUCT",
};
const SessionFilterKey = {
    ACCESS_TYPE: "AccessType",
    INVOKED_AFTER: "InvokedAfter",
    INVOKED_BEFORE: "InvokedBefore",
    OWNER: "Owner",
    SESSION_ID: "SessionId",
    STATUS: "Status",
    TARGET_ID: "Target",
};
const SessionState = {
    ACTIVE: "Active",
    HISTORY: "History",
};
const SessionStatus = {
    CONNECTED: "Connected",
    CONNECTING: "Connecting",
    DISCONNECTED: "Disconnected",
    FAILED: "Failed",
    TERMINATED: "Terminated",
    TERMINATING: "Terminating",
};
const CalendarState = {
    CLOSED: "CLOSED",
    OPEN: "OPEN",
};
const CommandInvocationStatus = {
    CANCELLED: "Cancelled",
    CANCELLING: "Cancelling",
    DELAYED: "Delayed",
    FAILED: "Failed",
    IN_PROGRESS: "InProgress",
    PENDING: "Pending",
    SUCCESS: "Success",
    TIMED_OUT: "TimedOut",
};
const ConnectionStatus = {
    CONNECTED: "connected",
    NOT_CONNECTED: "notconnected",
};
const AttachmentHashType = {
    SHA256: "Sha256",
};
const ImpactType = {
    MUTATING: "Mutating",
    NON_MUTATING: "NonMutating",
    UNDETERMINED: "Undetermined",
};
const ExecutionPreviewStatus = {
    FAILED: "Failed",
    IN_PROGRESS: "InProgress",
    PENDING: "Pending",
    SUCCESS: "Success",
};
const InventoryQueryOperatorType = {
    BEGIN_WITH: "BeginWith",
    EQUAL: "Equal",
    EXISTS: "Exists",
    GREATER_THAN: "GreaterThan",
    LESS_THAN: "LessThan",
    NOT_EQUAL: "NotEqual",
};
const InventoryAttributeDataType = {
    NUMBER: "number",
    STRING: "string",
};
const NotificationEvent = {
    ALL: "All",
    CANCELLED: "Cancelled",
    FAILED: "Failed",
    IN_PROGRESS: "InProgress",
    SUCCESS: "Success",
    TIMED_OUT: "TimedOut",
};
const NotificationType = {
    Command: "Command",
    Invocation: "Invocation",
};
const OpsFilterOperatorType = {
    BEGIN_WITH: "BeginWith",
    EQUAL: "Equal",
    EXISTS: "Exists",
    GREATER_THAN: "GreaterThan",
    LESS_THAN: "LessThan",
    NOT_EQUAL: "NotEqual",
};
const AssociationFilterKey = {
    AssociationId: "AssociationId",
    AssociationName: "AssociationName",
    InstanceId: "InstanceId",
    LastExecutedAfter: "LastExecutedAfter",
    LastExecutedBefore: "LastExecutedBefore",
    Name: "Name",
    ResourceGroupName: "ResourceGroupName",
    Status: "AssociationStatusName",
};
const CommandFilterKey = {
    DOCUMENT_NAME: "DocumentName",
    EXECUTION_STAGE: "ExecutionStage",
    INVOKED_AFTER: "InvokedAfter",
    INVOKED_BEFORE: "InvokedBefore",
    STATUS: "Status",
};
const CommandPluginStatus = {
    CANCELLED: "Cancelled",
    FAILED: "Failed",
    IN_PROGRESS: "InProgress",
    PENDING: "Pending",
    SUCCESS: "Success",
    TIMED_OUT: "TimedOut",
};
const CommandStatus = {
    CANCELLED: "Cancelled",
    CANCELLING: "Cancelling",
    FAILED: "Failed",
    IN_PROGRESS: "InProgress",
    PENDING: "Pending",
    SUCCESS: "Success",
    TIMED_OUT: "TimedOut",
};
const ComplianceQueryOperatorType = {
    BeginWith: "BEGIN_WITH",
    Equal: "EQUAL",
    GreaterThan: "GREATER_THAN",
    LessThan: "LESS_THAN",
    NotEqual: "NOT_EQUAL",
};
const ComplianceSeverity = {
    Critical: "CRITICAL",
    High: "HIGH",
    Informational: "INFORMATIONAL",
    Low: "LOW",
    Medium: "MEDIUM",
    Unspecified: "UNSPECIFIED",
};
const ComplianceStatus = {
    Compliant: "COMPLIANT",
    NonCompliant: "NON_COMPLIANT",
};
const DocumentMetadataEnum = {
    DocumentReviews: "DocumentReviews",
};
const DocumentReviewCommentType = {
    Comment: "Comment",
};
const DocumentFilterKey = {
    DocumentType: "DocumentType",
    Name: "Name",
    Owner: "Owner",
    PlatformTypes: "PlatformTypes",
};
const NodeFilterKey = {
    ACCOUNT_ID: "AccountId",
    AGENT_TYPE: "AgentType",
    AGENT_VERSION: "AgentVersion",
    COMPUTER_NAME: "ComputerName",
    INSTANCE_ID: "InstanceId",
    INSTANCE_STATUS: "InstanceStatus",
    IP_ADDRESS: "IpAddress",
    MANAGED_STATUS: "ManagedStatus",
    ORGANIZATIONAL_UNIT_ID: "OrganizationalUnitId",
    ORGANIZATIONAL_UNIT_PATH: "OrganizationalUnitPath",
    PLATFORM_NAME: "PlatformName",
    PLATFORM_TYPE: "PlatformType",
    PLATFORM_VERSION: "PlatformVersion",
    REGION: "Region",
    RESOURCE_TYPE: "ResourceType",
};
const NodeFilterOperatorType = {
    BEGIN_WITH: "BeginWith",
    EQUAL: "Equal",
    NOT_EQUAL: "NotEqual",
};
const ManagedStatus = {
    ALL: "All",
    MANAGED: "Managed",
    UNMANAGED: "Unmanaged",
};
const NodeAggregatorType = {
    COUNT: "Count",
};
const NodeAttributeName = {
    AGENT_VERSION: "AgentVersion",
    PLATFORM_NAME: "PlatformName",
    PLATFORM_TYPE: "PlatformType",
    PLATFORM_VERSION: "PlatformVersion",
    REGION: "Region",
    RESOURCE_TYPE: "ResourceType",
};
const NodeTypeName = {
    INSTANCE: "Instance",
};
const OpsItemEventFilterKey = {
    OPSITEM_ID: "OpsItemId",
};
const OpsItemEventFilterOperator = {
    EQUAL: "Equal",
};
const OpsItemRelatedItemsFilterKey = {
    ASSOCIATION_ID: "AssociationId",
    RESOURCE_TYPE: "ResourceType",
    RESOURCE_URI: "ResourceUri",
};
const OpsItemRelatedItemsFilterOperator = {
    EQUAL: "Equal",
};
const LastResourceDataSyncStatus = {
    FAILED: "Failed",
    INPROGRESS: "InProgress",
    SUCCESSFUL: "Successful",
};
const ComplianceUploadType = {
    Complete: "COMPLETE",
    Partial: "PARTIAL",
};
const SignalType = {
    APPROVE: "Approve",
    REJECT: "Reject",
    RESUME: "Resume",
    REVOKE: "Revoke",
    START_STEP: "StartStep",
    STOP_STEP: "StopStep",
};
const StopType = {
    CANCEL: "Cancel",
    COMPLETE: "Complete",
};
const DocumentReviewAction = {
    Approve: "Approve",
    Reject: "Reject",
    SendForReview: "SendForReview",
    UpdateReview: "UpdateReview",
};

Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function () { return smithyClient.Command; }
}));
Object.defineProperty(exports, "__Client", ({
    enumerable: true,
    get: function () { return smithyClient.Client; }
}));
exports.AccessDeniedException = AccessDeniedException;
exports.AccessDeniedException$ = AccessDeniedException$;
exports.AccessRequestStatus = AccessRequestStatus;
exports.AccessType = AccessType;
exports.AccountSharingInfo$ = AccountSharingInfo$;
exports.Activation$ = Activation$;
exports.AddTagsToResource$ = AddTagsToResource$;
exports.AddTagsToResourceCommand = AddTagsToResourceCommand;
exports.AddTagsToResourceRequest$ = AddTagsToResourceRequest$;
exports.AddTagsToResourceResult$ = AddTagsToResourceResult$;
exports.Alarm$ = Alarm$;
exports.AlarmConfiguration$ = AlarmConfiguration$;
exports.AlarmStateInformation$ = AlarmStateInformation$;
exports.AlreadyExistsException = AlreadyExistsException;
exports.AlreadyExistsException$ = AlreadyExistsException$;
exports.AssociateOpsItemRelatedItem$ = AssociateOpsItemRelatedItem$;
exports.AssociateOpsItemRelatedItemCommand = AssociateOpsItemRelatedItemCommand;
exports.AssociateOpsItemRelatedItemRequest$ = AssociateOpsItemRelatedItemRequest$;
exports.AssociateOpsItemRelatedItemResponse$ = AssociateOpsItemRelatedItemResponse$;
exports.AssociatedInstances = AssociatedInstances;
exports.AssociatedInstances$ = AssociatedInstances$;
exports.Association$ = Association$;
exports.AssociationAlreadyExists = AssociationAlreadyExists;
exports.AssociationAlreadyExists$ = AssociationAlreadyExists$;
exports.AssociationComplianceSeverity = AssociationComplianceSeverity;
exports.AssociationDescription$ = AssociationDescription$;
exports.AssociationDoesNotExist = AssociationDoesNotExist;
exports.AssociationDoesNotExist$ = AssociationDoesNotExist$;
exports.AssociationExecution$ = AssociationExecution$;
exports.AssociationExecutionDoesNotExist = AssociationExecutionDoesNotExist;
exports.AssociationExecutionDoesNotExist$ = AssociationExecutionDoesNotExist$;
exports.AssociationExecutionFilter$ = AssociationExecutionFilter$;
exports.AssociationExecutionFilterKey = AssociationExecutionFilterKey;
exports.AssociationExecutionTarget$ = AssociationExecutionTarget$;
exports.AssociationExecutionTargetsFilter$ = AssociationExecutionTargetsFilter$;
exports.AssociationExecutionTargetsFilterKey = AssociationExecutionTargetsFilterKey;
exports.AssociationFilter$ = AssociationFilter$;
exports.AssociationFilterKey = AssociationFilterKey;
exports.AssociationFilterOperatorType = AssociationFilterOperatorType;
exports.AssociationLimitExceeded = AssociationLimitExceeded;
exports.AssociationLimitExceeded$ = AssociationLimitExceeded$;
exports.AssociationOverview$ = AssociationOverview$;
exports.AssociationStatus$ = AssociationStatus$;
exports.AssociationStatusName = AssociationStatusName;
exports.AssociationSyncCompliance = AssociationSyncCompliance;
exports.AssociationVersionInfo$ = AssociationVersionInfo$;
exports.AssociationVersionLimitExceeded = AssociationVersionLimitExceeded;
exports.AssociationVersionLimitExceeded$ = AssociationVersionLimitExceeded$;
exports.AttachmentContent$ = AttachmentContent$;
exports.AttachmentHashType = AttachmentHashType;
exports.AttachmentInformation$ = AttachmentInformation$;
exports.AttachmentsSource$ = AttachmentsSource$;
exports.AttachmentsSourceKey = AttachmentsSourceKey;
exports.AutomationDefinitionNotApprovedException = AutomationDefinitionNotApprovedException;
exports.AutomationDefinitionNotApprovedException$ = AutomationDefinitionNotApprovedException$;
exports.AutomationDefinitionNotFoundException = AutomationDefinitionNotFoundException;
exports.AutomationDefinitionNotFoundException$ = AutomationDefinitionNotFoundException$;
exports.AutomationDefinitionVersionNotFoundException = AutomationDefinitionVersionNotFoundException;
exports.AutomationDefinitionVersionNotFoundException$ = AutomationDefinitionVersionNotFoundException$;
exports.AutomationExecution$ = AutomationExecution$;
exports.AutomationExecutionFilter$ = AutomationExecutionFilter$;
exports.AutomationExecutionFilterKey = AutomationExecutionFilterKey;
exports.AutomationExecutionInputs$ = AutomationExecutionInputs$;
exports.AutomationExecutionLimitExceededException = AutomationExecutionLimitExceededException;
exports.AutomationExecutionLimitExceededException$ = AutomationExecutionLimitExceededException$;
exports.AutomationExecutionMetadata$ = AutomationExecutionMetadata$;
exports.AutomationExecutionNotFoundException = AutomationExecutionNotFoundException;
exports.AutomationExecutionNotFoundException$ = AutomationExecutionNotFoundException$;
exports.AutomationExecutionPreview$ = AutomationExecutionPreview$;
exports.AutomationExecutionStatus = AutomationExecutionStatus;
exports.AutomationStepNotFoundException = AutomationStepNotFoundException;
exports.AutomationStepNotFoundException$ = AutomationStepNotFoundException$;
exports.AutomationSubtype = AutomationSubtype;
exports.AutomationType = AutomationType;
exports.BaselineOverride$ = BaselineOverride$;
exports.CalendarState = CalendarState;
exports.CancelCommand$ = CancelCommand$;
exports.CancelCommandCommand = CancelCommandCommand;
exports.CancelCommandRequest$ = CancelCommandRequest$;
exports.CancelCommandResult$ = CancelCommandResult$;
exports.CancelMaintenanceWindowExecution$ = CancelMaintenanceWindowExecution$;
exports.CancelMaintenanceWindowExecutionCommand = CancelMaintenanceWindowExecutionCommand;
exports.CancelMaintenanceWindowExecutionRequest$ = CancelMaintenanceWindowExecutionRequest$;
exports.CancelMaintenanceWindowExecutionResult$ = CancelMaintenanceWindowExecutionResult$;
exports.CloudWatchOutputConfig$ = CloudWatchOutputConfig$;
exports.Command$ = Command$;
exports.CommandFilter$ = CommandFilter$;
exports.CommandFilterKey = CommandFilterKey;
exports.CommandInvocation$ = CommandInvocation$;
exports.CommandInvocationStatus = CommandInvocationStatus;
exports.CommandPlugin$ = CommandPlugin$;
exports.CommandPluginStatus = CommandPluginStatus;
exports.CommandStatus = CommandStatus;
exports.ComplianceExecutionSummary$ = ComplianceExecutionSummary$;
exports.ComplianceItem$ = ComplianceItem$;
exports.ComplianceItemEntry$ = ComplianceItemEntry$;
exports.ComplianceQueryOperatorType = ComplianceQueryOperatorType;
exports.ComplianceSeverity = ComplianceSeverity;
exports.ComplianceStatus = ComplianceStatus;
exports.ComplianceStringFilter$ = ComplianceStringFilter$;
exports.ComplianceSummaryItem$ = ComplianceSummaryItem$;
exports.ComplianceTypeCountLimitExceededException = ComplianceTypeCountLimitExceededException;
exports.ComplianceTypeCountLimitExceededException$ = ComplianceTypeCountLimitExceededException$;
exports.ComplianceUploadType = ComplianceUploadType;
exports.CompliantSummary$ = CompliantSummary$;
exports.ConnectionStatus = ConnectionStatus;
exports.CreateActivation$ = CreateActivation$;
exports.CreateActivationCommand = CreateActivationCommand;
exports.CreateActivationRequest$ = CreateActivationRequest$;
exports.CreateActivationResult$ = CreateActivationResult$;
exports.CreateAssociation$ = CreateAssociation$;
exports.CreateAssociationBatch$ = CreateAssociationBatch$;
exports.CreateAssociationBatchCommand = CreateAssociationBatchCommand;
exports.CreateAssociationBatchRequest$ = CreateAssociationBatchRequest$;
exports.CreateAssociationBatchRequestEntry$ = CreateAssociationBatchRequestEntry$;
exports.CreateAssociationBatchResult$ = CreateAssociationBatchResult$;
exports.CreateAssociationCommand = CreateAssociationCommand;
exports.CreateAssociationRequest$ = CreateAssociationRequest$;
exports.CreateAssociationResult$ = CreateAssociationResult$;
exports.CreateDocument$ = CreateDocument$;
exports.CreateDocumentCommand = CreateDocumentCommand;
exports.CreateDocumentRequest$ = CreateDocumentRequest$;
exports.CreateDocumentResult$ = CreateDocumentResult$;
exports.CreateMaintenanceWindow$ = CreateMaintenanceWindow$;
exports.CreateMaintenanceWindowCommand = CreateMaintenanceWindowCommand;
exports.CreateMaintenanceWindowRequest$ = CreateMaintenanceWindowRequest$;
exports.CreateMaintenanceWindowResult$ = CreateMaintenanceWindowResult$;
exports.CreateOpsItem$ = CreateOpsItem$;
exports.CreateOpsItemCommand = CreateOpsItemCommand;
exports.CreateOpsItemRequest$ = CreateOpsItemRequest$;
exports.CreateOpsItemResponse$ = CreateOpsItemResponse$;
exports.CreateOpsMetadata$ = CreateOpsMetadata$;
exports.CreateOpsMetadataCommand = CreateOpsMetadataCommand;
exports.CreateOpsMetadataRequest$ = CreateOpsMetadataRequest$;
exports.CreateOpsMetadataResult$ = CreateOpsMetadataResult$;
exports.CreatePatchBaseline$ = CreatePatchBaseline$;
exports.CreatePatchBaselineCommand = CreatePatchBaselineCommand;
exports.CreatePatchBaselineRequest$ = CreatePatchBaselineRequest$;
exports.CreatePatchBaselineResult$ = CreatePatchBaselineResult$;
exports.CreateResourceDataSync$ = CreateResourceDataSync$;
exports.CreateResourceDataSyncCommand = CreateResourceDataSyncCommand;
exports.CreateResourceDataSyncRequest$ = CreateResourceDataSyncRequest$;
exports.CreateResourceDataSyncResult$ = CreateResourceDataSyncResult$;
exports.Credentials$ = Credentials$;
exports.CustomSchemaCountLimitExceededException = CustomSchemaCountLimitExceededException;
exports.CustomSchemaCountLimitExceededException$ = CustomSchemaCountLimitExceededException$;
exports.DeleteActivation$ = DeleteActivation$;
exports.DeleteActivationCommand = DeleteActivationCommand;
exports.DeleteActivationRequest$ = DeleteActivationRequest$;
exports.DeleteActivationResult$ = DeleteActivationResult$;
exports.DeleteAssociation$ = DeleteAssociation$;
exports.DeleteAssociationCommand = DeleteAssociationCommand;
exports.DeleteAssociationRequest$ = DeleteAssociationRequest$;
exports.DeleteAssociationResult$ = DeleteAssociationResult$;
exports.DeleteDocument$ = DeleteDocument$;
exports.DeleteDocumentCommand = DeleteDocumentCommand;
exports.DeleteDocumentRequest$ = DeleteDocumentRequest$;
exports.DeleteDocumentResult$ = DeleteDocumentResult$;
exports.DeleteInventory$ = DeleteInventory$;
exports.DeleteInventoryCommand = DeleteInventoryCommand;
exports.DeleteInventoryRequest$ = DeleteInventoryRequest$;
exports.DeleteInventoryResult$ = DeleteInventoryResult$;
exports.DeleteMaintenanceWindow$ = DeleteMaintenanceWindow$;
exports.DeleteMaintenanceWindowCommand = DeleteMaintenanceWindowCommand;
exports.DeleteMaintenanceWindowRequest$ = DeleteMaintenanceWindowRequest$;
exports.DeleteMaintenanceWindowResult$ = DeleteMaintenanceWindowResult$;
exports.DeleteOpsItem$ = DeleteOpsItem$;
exports.DeleteOpsItemCommand = DeleteOpsItemCommand;
exports.DeleteOpsItemRequest$ = DeleteOpsItemRequest$;
exports.DeleteOpsItemResponse$ = DeleteOpsItemResponse$;
exports.DeleteOpsMetadata$ = DeleteOpsMetadata$;
exports.DeleteOpsMetadataCommand = DeleteOpsMetadataCommand;
exports.DeleteOpsMetadataRequest$ = DeleteOpsMetadataRequest$;
exports.DeleteOpsMetadataResult$ = DeleteOpsMetadataResult$;
exports.DeleteParameter$ = DeleteParameter$;
exports.DeleteParameterCommand = DeleteParameterCommand;
exports.DeleteParameterRequest$ = DeleteParameterRequest$;
exports.DeleteParameterResult$ = DeleteParameterResult$;
exports.DeleteParameters$ = DeleteParameters$;
exports.DeleteParametersCommand = DeleteParametersCommand;
exports.DeleteParametersRequest$ = DeleteParametersRequest$;
exports.DeleteParametersResult$ = DeleteParametersResult$;
exports.DeletePatchBaseline$ = DeletePatchBaseline$;
exports.DeletePatchBaselineCommand = DeletePatchBaselineCommand;
exports.DeletePatchBaselineRequest$ = DeletePatchBaselineRequest$;
exports.DeletePatchBaselineResult$ = DeletePatchBaselineResult$;
exports.DeleteResourceDataSync$ = DeleteResourceDataSync$;
exports.DeleteResourceDataSyncCommand = DeleteResourceDataSyncCommand;
exports.DeleteResourceDataSyncRequest$ = DeleteResourceDataSyncRequest$;
exports.DeleteResourceDataSyncResult$ = DeleteResourceDataSyncResult$;
exports.DeleteResourcePolicy$ = DeleteResourcePolicy$;
exports.DeleteResourcePolicyCommand = DeleteResourcePolicyCommand;
exports.DeleteResourcePolicyRequest$ = DeleteResourcePolicyRequest$;
exports.DeleteResourcePolicyResponse$ = DeleteResourcePolicyResponse$;
exports.DeregisterManagedInstance$ = DeregisterManagedInstance$;
exports.DeregisterManagedInstanceCommand = DeregisterManagedInstanceCommand;
exports.DeregisterManagedInstanceRequest$ = DeregisterManagedInstanceRequest$;
exports.DeregisterManagedInstanceResult$ = DeregisterManagedInstanceResult$;
exports.DeregisterPatchBaselineForPatchGroup$ = DeregisterPatchBaselineForPatchGroup$;
exports.DeregisterPatchBaselineForPatchGroupCommand = DeregisterPatchBaselineForPatchGroupCommand;
exports.DeregisterPatchBaselineForPatchGroupRequest$ = DeregisterPatchBaselineForPatchGroupRequest$;
exports.DeregisterPatchBaselineForPatchGroupResult$ = DeregisterPatchBaselineForPatchGroupResult$;
exports.DeregisterTargetFromMaintenanceWindow$ = DeregisterTargetFromMaintenanceWindow$;
exports.DeregisterTargetFromMaintenanceWindowCommand = DeregisterTargetFromMaintenanceWindowCommand;
exports.DeregisterTargetFromMaintenanceWindowRequest$ = DeregisterTargetFromMaintenanceWindowRequest$;
exports.DeregisterTargetFromMaintenanceWindowResult$ = DeregisterTargetFromMaintenanceWindowResult$;
exports.DeregisterTaskFromMaintenanceWindow$ = DeregisterTaskFromMaintenanceWindow$;
exports.DeregisterTaskFromMaintenanceWindowCommand = DeregisterTaskFromMaintenanceWindowCommand;
exports.DeregisterTaskFromMaintenanceWindowRequest$ = DeregisterTaskFromMaintenanceWindowRequest$;
exports.DeregisterTaskFromMaintenanceWindowResult$ = DeregisterTaskFromMaintenanceWindowResult$;
exports.DescribeActivations$ = DescribeActivations$;
exports.DescribeActivationsCommand = DescribeActivationsCommand;
exports.DescribeActivationsFilter$ = DescribeActivationsFilter$;
exports.DescribeActivationsFilterKeys = DescribeActivationsFilterKeys;
exports.DescribeActivationsRequest$ = DescribeActivationsRequest$;
exports.DescribeActivationsResult$ = DescribeActivationsResult$;
exports.DescribeAssociation$ = DescribeAssociation$;
exports.DescribeAssociationCommand = DescribeAssociationCommand;
exports.DescribeAssociationExecutionTargets$ = DescribeAssociationExecutionTargets$;
exports.DescribeAssociationExecutionTargetsCommand = DescribeAssociationExecutionTargetsCommand;
exports.DescribeAssociationExecutionTargetsRequest$ = DescribeAssociationExecutionTargetsRequest$;
exports.DescribeAssociationExecutionTargetsResult$ = DescribeAssociationExecutionTargetsResult$;
exports.DescribeAssociationExecutions$ = DescribeAssociationExecutions$;
exports.DescribeAssociationExecutionsCommand = DescribeAssociationExecutionsCommand;
exports.DescribeAssociationExecutionsRequest$ = DescribeAssociationExecutionsRequest$;
exports.DescribeAssociationExecutionsResult$ = DescribeAssociationExecutionsResult$;
exports.DescribeAssociationRequest$ = DescribeAssociationRequest$;
exports.DescribeAssociationResult$ = DescribeAssociationResult$;
exports.DescribeAutomationExecutions$ = DescribeAutomationExecutions$;
exports.DescribeAutomationExecutionsCommand = DescribeAutomationExecutionsCommand;
exports.DescribeAutomationExecutionsRequest$ = DescribeAutomationExecutionsRequest$;
exports.DescribeAutomationExecutionsResult$ = DescribeAutomationExecutionsResult$;
exports.DescribeAutomationStepExecutions$ = DescribeAutomationStepExecutions$;
exports.DescribeAutomationStepExecutionsCommand = DescribeAutomationStepExecutionsCommand;
exports.DescribeAutomationStepExecutionsRequest$ = DescribeAutomationStepExecutionsRequest$;
exports.DescribeAutomationStepExecutionsResult$ = DescribeAutomationStepExecutionsResult$;
exports.DescribeAvailablePatches$ = DescribeAvailablePatches$;
exports.DescribeAvailablePatchesCommand = DescribeAvailablePatchesCommand;
exports.DescribeAvailablePatchesRequest$ = DescribeAvailablePatchesRequest$;
exports.DescribeAvailablePatchesResult$ = DescribeAvailablePatchesResult$;
exports.DescribeDocument$ = DescribeDocument$;
exports.DescribeDocumentCommand = DescribeDocumentCommand;
exports.DescribeDocumentPermission$ = DescribeDocumentPermission$;
exports.DescribeDocumentPermissionCommand = DescribeDocumentPermissionCommand;
exports.DescribeDocumentPermissionRequest$ = DescribeDocumentPermissionRequest$;
exports.DescribeDocumentPermissionResponse$ = DescribeDocumentPermissionResponse$;
exports.DescribeDocumentRequest$ = DescribeDocumentRequest$;
exports.DescribeDocumentResult$ = DescribeDocumentResult$;
exports.DescribeEffectiveInstanceAssociations$ = DescribeEffectiveInstanceAssociations$;
exports.DescribeEffectiveInstanceAssociationsCommand = DescribeEffectiveInstanceAssociationsCommand;
exports.DescribeEffectiveInstanceAssociationsRequest$ = DescribeEffectiveInstanceAssociationsRequest$;
exports.DescribeEffectiveInstanceAssociationsResult$ = DescribeEffectiveInstanceAssociationsResult$;
exports.DescribeEffectivePatchesForPatchBaseline$ = DescribeEffectivePatchesForPatchBaseline$;
exports.DescribeEffectivePatchesForPatchBaselineCommand = DescribeEffectivePatchesForPatchBaselineCommand;
exports.DescribeEffectivePatchesForPatchBaselineRequest$ = DescribeEffectivePatchesForPatchBaselineRequest$;
exports.DescribeEffectivePatchesForPatchBaselineResult$ = DescribeEffectivePatchesForPatchBaselineResult$;
exports.DescribeInstanceAssociationsStatus$ = DescribeInstanceAssociationsStatus$;
exports.DescribeInstanceAssociationsStatusCommand = DescribeInstanceAssociationsStatusCommand;
exports.DescribeInstanceAssociationsStatusRequest$ = DescribeInstanceAssociationsStatusRequest$;
exports.DescribeInstanceAssociationsStatusResult$ = DescribeInstanceAssociationsStatusResult$;
exports.DescribeInstanceInformation$ = DescribeInstanceInformation$;
exports.DescribeInstanceInformationCommand = DescribeInstanceInformationCommand;
exports.DescribeInstanceInformationRequest$ = DescribeInstanceInformationRequest$;
exports.DescribeInstanceInformationResult$ = DescribeInstanceInformationResult$;
exports.DescribeInstancePatchStates$ = DescribeInstancePatchStates$;
exports.DescribeInstancePatchStatesCommand = DescribeInstancePatchStatesCommand;
exports.DescribeInstancePatchStatesForPatchGroup$ = DescribeInstancePatchStatesForPatchGroup$;
exports.DescribeInstancePatchStatesForPatchGroupCommand = DescribeInstancePatchStatesForPatchGroupCommand;
exports.DescribeInstancePatchStatesForPatchGroupRequest$ = DescribeInstancePatchStatesForPatchGroupRequest$;
exports.DescribeInstancePatchStatesForPatchGroupResult$ = DescribeInstancePatchStatesForPatchGroupResult$;
exports.DescribeInstancePatchStatesRequest$ = DescribeInstancePatchStatesRequest$;
exports.DescribeInstancePatchStatesResult$ = DescribeInstancePatchStatesResult$;
exports.DescribeInstancePatches$ = DescribeInstancePatches$;
exports.DescribeInstancePatchesCommand = DescribeInstancePatchesCommand;
exports.DescribeInstancePatchesRequest$ = DescribeInstancePatchesRequest$;
exports.DescribeInstancePatchesResult$ = DescribeInstancePatchesResult$;
exports.DescribeInstanceProperties$ = DescribeInstanceProperties$;
exports.DescribeInstancePropertiesCommand = DescribeInstancePropertiesCommand;
exports.DescribeInstancePropertiesRequest$ = DescribeInstancePropertiesRequest$;
exports.DescribeInstancePropertiesResult$ = DescribeInstancePropertiesResult$;
exports.DescribeInventoryDeletions$ = DescribeInventoryDeletions$;
exports.DescribeInventoryDeletionsCommand = DescribeInventoryDeletionsCommand;
exports.DescribeInventoryDeletionsRequest$ = DescribeInventoryDeletionsRequest$;
exports.DescribeInventoryDeletionsResult$ = DescribeInventoryDeletionsResult$;
exports.DescribeMaintenanceWindowExecutionTaskInvocations$ = DescribeMaintenanceWindowExecutionTaskInvocations$;
exports.DescribeMaintenanceWindowExecutionTaskInvocationsCommand = DescribeMaintenanceWindowExecutionTaskInvocationsCommand;
exports.DescribeMaintenanceWindowExecutionTaskInvocationsRequest$ = DescribeMaintenanceWindowExecutionTaskInvocationsRequest$;
exports.DescribeMaintenanceWindowExecutionTaskInvocationsResult$ = DescribeMaintenanceWindowExecutionTaskInvocationsResult$;
exports.DescribeMaintenanceWindowExecutionTasks$ = DescribeMaintenanceWindowExecutionTasks$;
exports.DescribeMaintenanceWindowExecutionTasksCommand = DescribeMaintenanceWindowExecutionTasksCommand;
exports.DescribeMaintenanceWindowExecutionTasksRequest$ = DescribeMaintenanceWindowExecutionTasksRequest$;
exports.DescribeMaintenanceWindowExecutionTasksResult$ = DescribeMaintenanceWindowExecutionTasksResult$;
exports.DescribeMaintenanceWindowExecutions$ = DescribeMaintenanceWindowExecutions$;
exports.DescribeMaintenanceWindowExecutionsCommand = DescribeMaintenanceWindowExecutionsCommand;
exports.DescribeMaintenanceWindowExecutionsRequest$ = DescribeMaintenanceWindowExecutionsRequest$;
exports.DescribeMaintenanceWindowExecutionsResult$ = DescribeMaintenanceWindowExecutionsResult$;
exports.DescribeMaintenanceWindowSchedule$ = DescribeMaintenanceWindowSchedule$;
exports.DescribeMaintenanceWindowScheduleCommand = DescribeMaintenanceWindowScheduleCommand;
exports.DescribeMaintenanceWindowScheduleRequest$ = DescribeMaintenanceWindowScheduleRequest$;
exports.DescribeMaintenanceWindowScheduleResult$ = DescribeMaintenanceWindowScheduleResult$;
exports.DescribeMaintenanceWindowTargets$ = DescribeMaintenanceWindowTargets$;
exports.DescribeMaintenanceWindowTargetsCommand = DescribeMaintenanceWindowTargetsCommand;
exports.DescribeMaintenanceWindowTargetsRequest$ = DescribeMaintenanceWindowTargetsRequest$;
exports.DescribeMaintenanceWindowTargetsResult$ = DescribeMaintenanceWindowTargetsResult$;
exports.DescribeMaintenanceWindowTasks$ = DescribeMaintenanceWindowTasks$;
exports.DescribeMaintenanceWindowTasksCommand = DescribeMaintenanceWindowTasksCommand;
exports.DescribeMaintenanceWindowTasksRequest$ = DescribeMaintenanceWindowTasksRequest$;
exports.DescribeMaintenanceWindowTasksResult$ = DescribeMaintenanceWindowTasksResult$;
exports.DescribeMaintenanceWindows$ = DescribeMaintenanceWindows$;
exports.DescribeMaintenanceWindowsCommand = DescribeMaintenanceWindowsCommand;
exports.DescribeMaintenanceWindowsForTarget$ = DescribeMaintenanceWindowsForTarget$;
exports.DescribeMaintenanceWindowsForTargetCommand = DescribeMaintenanceWindowsForTargetCommand;
exports.DescribeMaintenanceWindowsForTargetRequest$ = DescribeMaintenanceWindowsForTargetRequest$;
exports.DescribeMaintenanceWindowsForTargetResult$ = DescribeMaintenanceWindowsForTargetResult$;
exports.DescribeMaintenanceWindowsRequest$ = DescribeMaintenanceWindowsRequest$;
exports.DescribeMaintenanceWindowsResult$ = DescribeMaintenanceWindowsResult$;
exports.DescribeOpsItems$ = DescribeOpsItems$;
exports.DescribeOpsItemsCommand = DescribeOpsItemsCommand;
exports.DescribeOpsItemsRequest$ = DescribeOpsItemsRequest$;
exports.DescribeOpsItemsResponse$ = DescribeOpsItemsResponse$;
exports.DescribeParameters$ = DescribeParameters$;
exports.DescribeParametersCommand = DescribeParametersCommand;
exports.DescribeParametersRequest$ = DescribeParametersRequest$;
exports.DescribeParametersResult$ = DescribeParametersResult$;
exports.DescribePatchBaselines$ = DescribePatchBaselines$;
exports.DescribePatchBaselinesCommand = DescribePatchBaselinesCommand;
exports.DescribePatchBaselinesRequest$ = DescribePatchBaselinesRequest$;
exports.DescribePatchBaselinesResult$ = DescribePatchBaselinesResult$;
exports.DescribePatchGroupState$ = DescribePatchGroupState$;
exports.DescribePatchGroupStateCommand = DescribePatchGroupStateCommand;
exports.DescribePatchGroupStateRequest$ = DescribePatchGroupStateRequest$;
exports.DescribePatchGroupStateResult$ = DescribePatchGroupStateResult$;
exports.DescribePatchGroups$ = DescribePatchGroups$;
exports.DescribePatchGroupsCommand = DescribePatchGroupsCommand;
exports.DescribePatchGroupsRequest$ = DescribePatchGroupsRequest$;
exports.DescribePatchGroupsResult$ = DescribePatchGroupsResult$;
exports.DescribePatchProperties$ = DescribePatchProperties$;
exports.DescribePatchPropertiesCommand = DescribePatchPropertiesCommand;
exports.DescribePatchPropertiesRequest$ = DescribePatchPropertiesRequest$;
exports.DescribePatchPropertiesResult$ = DescribePatchPropertiesResult$;
exports.DescribeSessions$ = DescribeSessions$;
exports.DescribeSessionsCommand = DescribeSessionsCommand;
exports.DescribeSessionsRequest$ = DescribeSessionsRequest$;
exports.DescribeSessionsResponse$ = DescribeSessionsResponse$;
exports.DisassociateOpsItemRelatedItem$ = DisassociateOpsItemRelatedItem$;
exports.DisassociateOpsItemRelatedItemCommand = DisassociateOpsItemRelatedItemCommand;
exports.DisassociateOpsItemRelatedItemRequest$ = DisassociateOpsItemRelatedItemRequest$;
exports.DisassociateOpsItemRelatedItemResponse$ = DisassociateOpsItemRelatedItemResponse$;
exports.DocumentAlreadyExists = DocumentAlreadyExists;
exports.DocumentAlreadyExists$ = DocumentAlreadyExists$;
exports.DocumentDefaultVersionDescription$ = DocumentDefaultVersionDescription$;
exports.DocumentDescription$ = DocumentDescription$;
exports.DocumentFilter$ = DocumentFilter$;
exports.DocumentFilterKey = DocumentFilterKey;
exports.DocumentFormat = DocumentFormat;
exports.DocumentHashType = DocumentHashType;
exports.DocumentIdentifier$ = DocumentIdentifier$;
exports.DocumentKeyValuesFilter$ = DocumentKeyValuesFilter$;
exports.DocumentLimitExceeded = DocumentLimitExceeded;
exports.DocumentLimitExceeded$ = DocumentLimitExceeded$;
exports.DocumentMetadataEnum = DocumentMetadataEnum;
exports.DocumentMetadataResponseInfo$ = DocumentMetadataResponseInfo$;
exports.DocumentParameter$ = DocumentParameter$;
exports.DocumentParameterType = DocumentParameterType;
exports.DocumentPermissionLimit = DocumentPermissionLimit;
exports.DocumentPermissionLimit$ = DocumentPermissionLimit$;
exports.DocumentPermissionType = DocumentPermissionType;
exports.DocumentRequires$ = DocumentRequires$;
exports.DocumentReviewAction = DocumentReviewAction;
exports.DocumentReviewCommentSource$ = DocumentReviewCommentSource$;
exports.DocumentReviewCommentType = DocumentReviewCommentType;
exports.DocumentReviewerResponseSource$ = DocumentReviewerResponseSource$;
exports.DocumentReviews$ = DocumentReviews$;
exports.DocumentStatus = DocumentStatus;
exports.DocumentType = DocumentType;
exports.DocumentVersionInfo$ = DocumentVersionInfo$;
exports.DocumentVersionLimitExceeded = DocumentVersionLimitExceeded;
exports.DocumentVersionLimitExceeded$ = DocumentVersionLimitExceeded$;
exports.DoesNotExistException = DoesNotExistException;
exports.DoesNotExistException$ = DoesNotExistException$;
exports.DuplicateDocumentContent = DuplicateDocumentContent;
exports.DuplicateDocumentContent$ = DuplicateDocumentContent$;
exports.DuplicateDocumentVersionName = DuplicateDocumentVersionName;
exports.DuplicateDocumentVersionName$ = DuplicateDocumentVersionName$;
exports.DuplicateInstanceId = DuplicateInstanceId;
exports.DuplicateInstanceId$ = DuplicateInstanceId$;
exports.EffectivePatch$ = EffectivePatch$;
exports.ExecutionInputs$ = ExecutionInputs$;
exports.ExecutionMode = ExecutionMode;
exports.ExecutionPreview$ = ExecutionPreview$;
exports.ExecutionPreviewStatus = ExecutionPreviewStatus;
exports.ExternalAlarmState = ExternalAlarmState;
exports.FailedCreateAssociation$ = FailedCreateAssociation$;
exports.FailureDetails$ = FailureDetails$;
exports.Fault = Fault;
exports.FeatureNotAvailableException = FeatureNotAvailableException;
exports.FeatureNotAvailableException$ = FeatureNotAvailableException$;
exports.GetAccessToken$ = GetAccessToken$;
exports.GetAccessTokenCommand = GetAccessTokenCommand;
exports.GetAccessTokenRequest$ = GetAccessTokenRequest$;
exports.GetAccessTokenResponse$ = GetAccessTokenResponse$;
exports.GetAutomationExecution$ = GetAutomationExecution$;
exports.GetAutomationExecutionCommand = GetAutomationExecutionCommand;
exports.GetAutomationExecutionRequest$ = GetAutomationExecutionRequest$;
exports.GetAutomationExecutionResult$ = GetAutomationExecutionResult$;
exports.GetCalendarState$ = GetCalendarState$;
exports.GetCalendarStateCommand = GetCalendarStateCommand;
exports.GetCalendarStateRequest$ = GetCalendarStateRequest$;
exports.GetCalendarStateResponse$ = GetCalendarStateResponse$;
exports.GetCommandInvocation$ = GetCommandInvocation$;
exports.GetCommandInvocationCommand = GetCommandInvocationCommand;
exports.GetCommandInvocationRequest$ = GetCommandInvocationRequest$;
exports.GetCommandInvocationResult$ = GetCommandInvocationResult$;
exports.GetConnectionStatus$ = GetConnectionStatus$;
exports.GetConnectionStatusCommand = GetConnectionStatusCommand;
exports.GetConnectionStatusRequest$ = GetConnectionStatusRequest$;
exports.GetConnectionStatusResponse$ = GetConnectionStatusResponse$;
exports.GetDefaultPatchBaseline$ = GetDefaultPatchBaseline$;
exports.GetDefaultPatchBaselineCommand = GetDefaultPatchBaselineCommand;
exports.GetDefaultPatchBaselineRequest$ = GetDefaultPatchBaselineRequest$;
exports.GetDefaultPatchBaselineResult$ = GetDefaultPatchBaselineResult$;
exports.GetDeployablePatchSnapshotForInstance$ = GetDeployablePatchSnapshotForInstance$;
exports.GetDeployablePatchSnapshotForInstanceCommand = GetDeployablePatchSnapshotForInstanceCommand;
exports.GetDeployablePatchSnapshotForInstanceRequest$ = GetDeployablePatchSnapshotForInstanceRequest$;
exports.GetDeployablePatchSnapshotForInstanceResult$ = GetDeployablePatchSnapshotForInstanceResult$;
exports.GetDocument$ = GetDocument$;
exports.GetDocumentCommand = GetDocumentCommand;
exports.GetDocumentRequest$ = GetDocumentRequest$;
exports.GetDocumentResult$ = GetDocumentResult$;
exports.GetExecutionPreview$ = GetExecutionPreview$;
exports.GetExecutionPreviewCommand = GetExecutionPreviewCommand;
exports.GetExecutionPreviewRequest$ = GetExecutionPreviewRequest$;
exports.GetExecutionPreviewResponse$ = GetExecutionPreviewResponse$;
exports.GetInventory$ = GetInventory$;
exports.GetInventoryCommand = GetInventoryCommand;
exports.GetInventoryRequest$ = GetInventoryRequest$;
exports.GetInventoryResult$ = GetInventoryResult$;
exports.GetInventorySchema$ = GetInventorySchema$;
exports.GetInventorySchemaCommand = GetInventorySchemaCommand;
exports.GetInventorySchemaRequest$ = GetInventorySchemaRequest$;
exports.GetInventorySchemaResult$ = GetInventorySchemaResult$;
exports.GetMaintenanceWindow$ = GetMaintenanceWindow$;
exports.GetMaintenanceWindowCommand = GetMaintenanceWindowCommand;
exports.GetMaintenanceWindowExecution$ = GetMaintenanceWindowExecution$;
exports.GetMaintenanceWindowExecutionCommand = GetMaintenanceWindowExecutionCommand;
exports.GetMaintenanceWindowExecutionRequest$ = GetMaintenanceWindowExecutionRequest$;
exports.GetMaintenanceWindowExecutionResult$ = GetMaintenanceWindowExecutionResult$;
exports.GetMaintenanceWindowExecutionTask$ = GetMaintenanceWindowExecutionTask$;
exports.GetMaintenanceWindowExecutionTaskCommand = GetMaintenanceWindowExecutionTaskCommand;
exports.GetMaintenanceWindowExecutionTaskInvocation$ = GetMaintenanceWindowExecutionTaskInvocation$;
exports.GetMaintenanceWindowExecutionTaskInvocationCommand = GetMaintenanceWindowExecutionTaskInvocationCommand;
exports.GetMaintenanceWindowExecutionTaskInvocationRequest$ = GetMaintenanceWindowExecutionTaskInvocationRequest$;
exports.GetMaintenanceWindowExecutionTaskInvocationResult$ = GetMaintenanceWindowExecutionTaskInvocationResult$;
exports.GetMaintenanceWindowExecutionTaskRequest$ = GetMaintenanceWindowExecutionTaskRequest$;
exports.GetMaintenanceWindowExecutionTaskResult$ = GetMaintenanceWindowExecutionTaskResult$;
exports.GetMaintenanceWindowRequest$ = GetMaintenanceWindowRequest$;
exports.GetMaintenanceWindowResult$ = GetMaintenanceWindowResult$;
exports.GetMaintenanceWindowTask$ = GetMaintenanceWindowTask$;
exports.GetMaintenanceWindowTaskCommand = GetMaintenanceWindowTaskCommand;
exports.GetMaintenanceWindowTaskRequest$ = GetMaintenanceWindowTaskRequest$;
exports.GetMaintenanceWindowTaskResult$ = GetMaintenanceWindowTaskResult$;
exports.GetOpsItem$ = GetOpsItem$;
exports.GetOpsItemCommand = GetOpsItemCommand;
exports.GetOpsItemRequest$ = GetOpsItemRequest$;
exports.GetOpsItemResponse$ = GetOpsItemResponse$;
exports.GetOpsMetadata$ = GetOpsMetadata$;
exports.GetOpsMetadataCommand = GetOpsMetadataCommand;
exports.GetOpsMetadataRequest$ = GetOpsMetadataRequest$;
exports.GetOpsMetadataResult$ = GetOpsMetadataResult$;
exports.GetOpsSummary$ = GetOpsSummary$;
exports.GetOpsSummaryCommand = GetOpsSummaryCommand;
exports.GetOpsSummaryRequest$ = GetOpsSummaryRequest$;
exports.GetOpsSummaryResult$ = GetOpsSummaryResult$;
exports.GetParameter$ = GetParameter$;
exports.GetParameterCommand = GetParameterCommand;
exports.GetParameterHistory$ = GetParameterHistory$;
exports.GetParameterHistoryCommand = GetParameterHistoryCommand;
exports.GetParameterHistoryRequest$ = GetParameterHistoryRequest$;
exports.GetParameterHistoryResult$ = GetParameterHistoryResult$;
exports.GetParameterRequest$ = GetParameterRequest$;
exports.GetParameterResult$ = GetParameterResult$;
exports.GetParameters$ = GetParameters$;
exports.GetParametersByPath$ = GetParametersByPath$;
exports.GetParametersByPathCommand = GetParametersByPathCommand;
exports.GetParametersByPathRequest$ = GetParametersByPathRequest$;
exports.GetParametersByPathResult$ = GetParametersByPathResult$;
exports.GetParametersCommand = GetParametersCommand;
exports.GetParametersRequest$ = GetParametersRequest$;
exports.GetParametersResult$ = GetParametersResult$;
exports.GetPatchBaseline$ = GetPatchBaseline$;
exports.GetPatchBaselineCommand = GetPatchBaselineCommand;
exports.GetPatchBaselineForPatchGroup$ = GetPatchBaselineForPatchGroup$;
exports.GetPatchBaselineForPatchGroupCommand = GetPatchBaselineForPatchGroupCommand;
exports.GetPatchBaselineForPatchGroupRequest$ = GetPatchBaselineForPatchGroupRequest$;
exports.GetPatchBaselineForPatchGroupResult$ = GetPatchBaselineForPatchGroupResult$;
exports.GetPatchBaselineRequest$ = GetPatchBaselineRequest$;
exports.GetPatchBaselineResult$ = GetPatchBaselineResult$;
exports.GetResourcePolicies$ = GetResourcePolicies$;
exports.GetResourcePoliciesCommand = GetResourcePoliciesCommand;
exports.GetResourcePoliciesRequest$ = GetResourcePoliciesRequest$;
exports.GetResourcePoliciesResponse$ = GetResourcePoliciesResponse$;
exports.GetResourcePoliciesResponseEntry$ = GetResourcePoliciesResponseEntry$;
exports.GetServiceSetting$ = GetServiceSetting$;
exports.GetServiceSettingCommand = GetServiceSettingCommand;
exports.GetServiceSettingRequest$ = GetServiceSettingRequest$;
exports.GetServiceSettingResult$ = GetServiceSettingResult$;
exports.HierarchyLevelLimitExceededException = HierarchyLevelLimitExceededException;
exports.HierarchyLevelLimitExceededException$ = HierarchyLevelLimitExceededException$;
exports.HierarchyTypeMismatchException = HierarchyTypeMismatchException;
exports.HierarchyTypeMismatchException$ = HierarchyTypeMismatchException$;
exports.IdempotentParameterMismatch = IdempotentParameterMismatch;
exports.IdempotentParameterMismatch$ = IdempotentParameterMismatch$;
exports.ImpactType = ImpactType;
exports.IncompatiblePolicyException = IncompatiblePolicyException;
exports.IncompatiblePolicyException$ = IncompatiblePolicyException$;
exports.InstanceAggregatedAssociationOverview$ = InstanceAggregatedAssociationOverview$;
exports.InstanceAssociation$ = InstanceAssociation$;
exports.InstanceAssociationOutputLocation$ = InstanceAssociationOutputLocation$;
exports.InstanceAssociationOutputUrl$ = InstanceAssociationOutputUrl$;
exports.InstanceAssociationStatusInfo$ = InstanceAssociationStatusInfo$;
exports.InstanceInfo$ = InstanceInfo$;
exports.InstanceInformation$ = InstanceInformation$;
exports.InstanceInformationFilter$ = InstanceInformationFilter$;
exports.InstanceInformationFilterKey = InstanceInformationFilterKey;
exports.InstanceInformationStringFilter$ = InstanceInformationStringFilter$;
exports.InstancePatchState$ = InstancePatchState$;
exports.InstancePatchStateFilter$ = InstancePatchStateFilter$;
exports.InstancePatchStateOperatorType = InstancePatchStateOperatorType;
exports.InstanceProperty$ = InstanceProperty$;
exports.InstancePropertyFilter$ = InstancePropertyFilter$;
exports.InstancePropertyFilterKey = InstancePropertyFilterKey;
exports.InstancePropertyFilterOperator = InstancePropertyFilterOperator;
exports.InstancePropertyStringFilter$ = InstancePropertyStringFilter$;
exports.InternalServerError = InternalServerError;
exports.InternalServerError$ = InternalServerError$;
exports.InvalidActivation = InvalidActivation;
exports.InvalidActivation$ = InvalidActivation$;
exports.InvalidActivationId = InvalidActivationId;
exports.InvalidActivationId$ = InvalidActivationId$;
exports.InvalidAggregatorException = InvalidAggregatorException;
exports.InvalidAggregatorException$ = InvalidAggregatorException$;
exports.InvalidAllowedPatternException = InvalidAllowedPatternException;
exports.InvalidAllowedPatternException$ = InvalidAllowedPatternException$;
exports.InvalidAssociation = InvalidAssociation;
exports.InvalidAssociation$ = InvalidAssociation$;
exports.InvalidAssociationVersion = InvalidAssociationVersion;
exports.InvalidAssociationVersion$ = InvalidAssociationVersion$;
exports.InvalidAutomationExecutionParametersException = InvalidAutomationExecutionParametersException;
exports.InvalidAutomationExecutionParametersException$ = InvalidAutomationExecutionParametersException$;
exports.InvalidAutomationSignalException = InvalidAutomationSignalException;
exports.InvalidAutomationSignalException$ = InvalidAutomationSignalException$;
exports.InvalidAutomationStatusUpdateException = InvalidAutomationStatusUpdateException;
exports.InvalidAutomationStatusUpdateException$ = InvalidAutomationStatusUpdateException$;
exports.InvalidCommandId = InvalidCommandId;
exports.InvalidCommandId$ = InvalidCommandId$;
exports.InvalidDeleteInventoryParametersException = InvalidDeleteInventoryParametersException;
exports.InvalidDeleteInventoryParametersException$ = InvalidDeleteInventoryParametersException$;
exports.InvalidDeletionIdException = InvalidDeletionIdException;
exports.InvalidDeletionIdException$ = InvalidDeletionIdException$;
exports.InvalidDocument = InvalidDocument;
exports.InvalidDocument$ = InvalidDocument$;
exports.InvalidDocumentContent = InvalidDocumentContent;
exports.InvalidDocumentContent$ = InvalidDocumentContent$;
exports.InvalidDocumentOperation = InvalidDocumentOperation;
exports.InvalidDocumentOperation$ = InvalidDocumentOperation$;
exports.InvalidDocumentSchemaVersion = InvalidDocumentSchemaVersion;
exports.InvalidDocumentSchemaVersion$ = InvalidDocumentSchemaVersion$;
exports.InvalidDocumentType = InvalidDocumentType;
exports.InvalidDocumentType$ = InvalidDocumentType$;
exports.InvalidDocumentVersion = InvalidDocumentVersion;
exports.InvalidDocumentVersion$ = InvalidDocumentVersion$;
exports.InvalidFilter = InvalidFilter;
exports.InvalidFilter$ = InvalidFilter$;
exports.InvalidFilterKey = InvalidFilterKey;
exports.InvalidFilterKey$ = InvalidFilterKey$;
exports.InvalidFilterOption = InvalidFilterOption;
exports.InvalidFilterOption$ = InvalidFilterOption$;
exports.InvalidFilterValue = InvalidFilterValue;
exports.InvalidFilterValue$ = InvalidFilterValue$;
exports.InvalidInstanceId = InvalidInstanceId;
exports.InvalidInstanceId$ = InvalidInstanceId$;
exports.InvalidInstanceInformationFilterValue = InvalidInstanceInformationFilterValue;
exports.InvalidInstanceInformationFilterValue$ = InvalidInstanceInformationFilterValue$;
exports.InvalidInstancePropertyFilterValue = InvalidInstancePropertyFilterValue;
exports.InvalidInstancePropertyFilterValue$ = InvalidInstancePropertyFilterValue$;
exports.InvalidInventoryGroupException = InvalidInventoryGroupException;
exports.InvalidInventoryGroupException$ = InvalidInventoryGroupException$;
exports.InvalidInventoryItemContextException = InvalidInventoryItemContextException;
exports.InvalidInventoryItemContextException$ = InvalidInventoryItemContextException$;
exports.InvalidInventoryRequestException = InvalidInventoryRequestException;
exports.InvalidInventoryRequestException$ = InvalidInventoryRequestException$;
exports.InvalidItemContentException = InvalidItemContentException;
exports.InvalidItemContentException$ = InvalidItemContentException$;
exports.InvalidKeyId = InvalidKeyId;
exports.InvalidKeyId$ = InvalidKeyId$;
exports.InvalidNextToken = InvalidNextToken;
exports.InvalidNextToken$ = InvalidNextToken$;
exports.InvalidNotificationConfig = InvalidNotificationConfig;
exports.InvalidNotificationConfig$ = InvalidNotificationConfig$;
exports.InvalidOptionException = InvalidOptionException;
exports.InvalidOptionException$ = InvalidOptionException$;
exports.InvalidOutputFolder = InvalidOutputFolder;
exports.InvalidOutputFolder$ = InvalidOutputFolder$;
exports.InvalidOutputLocation = InvalidOutputLocation;
exports.InvalidOutputLocation$ = InvalidOutputLocation$;
exports.InvalidParameters = InvalidParameters;
exports.InvalidParameters$ = InvalidParameters$;
exports.InvalidPermissionType = InvalidPermissionType;
exports.InvalidPermissionType$ = InvalidPermissionType$;
exports.InvalidPluginName = InvalidPluginName;
exports.InvalidPluginName$ = InvalidPluginName$;
exports.InvalidPolicyAttributeException = InvalidPolicyAttributeException;
exports.InvalidPolicyAttributeException$ = InvalidPolicyAttributeException$;
exports.InvalidPolicyTypeException = InvalidPolicyTypeException;
exports.InvalidPolicyTypeException$ = InvalidPolicyTypeException$;
exports.InvalidResourceId = InvalidResourceId;
exports.InvalidResourceId$ = InvalidResourceId$;
exports.InvalidResourceType = InvalidResourceType;
exports.InvalidResourceType$ = InvalidResourceType$;
exports.InvalidResultAttributeException = InvalidResultAttributeException;
exports.InvalidResultAttributeException$ = InvalidResultAttributeException$;
exports.InvalidRole = InvalidRole;
exports.InvalidRole$ = InvalidRole$;
exports.InvalidSchedule = InvalidSchedule;
exports.InvalidSchedule$ = InvalidSchedule$;
exports.InvalidTag = InvalidTag;
exports.InvalidTag$ = InvalidTag$;
exports.InvalidTarget = InvalidTarget;
exports.InvalidTarget$ = InvalidTarget$;
exports.InvalidTargetMaps = InvalidTargetMaps;
exports.InvalidTargetMaps$ = InvalidTargetMaps$;
exports.InvalidTypeNameException = InvalidTypeNameException;
exports.InvalidTypeNameException$ = InvalidTypeNameException$;
exports.InvalidUpdate = InvalidUpdate;
exports.InvalidUpdate$ = InvalidUpdate$;
exports.InventoryAggregator$ = InventoryAggregator$;
exports.InventoryAttributeDataType = InventoryAttributeDataType;
exports.InventoryDeletionStatus = InventoryDeletionStatus;
exports.InventoryDeletionStatusItem$ = InventoryDeletionStatusItem$;
exports.InventoryDeletionSummary$ = InventoryDeletionSummary$;
exports.InventoryDeletionSummaryItem$ = InventoryDeletionSummaryItem$;
exports.InventoryFilter$ = InventoryFilter$;
exports.InventoryGroup$ = InventoryGroup$;
exports.InventoryItem$ = InventoryItem$;
exports.InventoryItemAttribute$ = InventoryItemAttribute$;
exports.InventoryItemSchema$ = InventoryItemSchema$;
exports.InventoryQueryOperatorType = InventoryQueryOperatorType;
exports.InventoryResultEntity$ = InventoryResultEntity$;
exports.InventoryResultItem$ = InventoryResultItem$;
exports.InventorySchemaDeleteOption = InventorySchemaDeleteOption;
exports.InvocationDoesNotExist = InvocationDoesNotExist;
exports.InvocationDoesNotExist$ = InvocationDoesNotExist$;
exports.ItemContentMismatchException = ItemContentMismatchException;
exports.ItemContentMismatchException$ = ItemContentMismatchException$;
exports.ItemSizeLimitExceededException = ItemSizeLimitExceededException;
exports.ItemSizeLimitExceededException$ = ItemSizeLimitExceededException$;
exports.LabelParameterVersion$ = LabelParameterVersion$;
exports.LabelParameterVersionCommand = LabelParameterVersionCommand;
exports.LabelParameterVersionRequest$ = LabelParameterVersionRequest$;
exports.LabelParameterVersionResult$ = LabelParameterVersionResult$;
exports.LastResourceDataSyncStatus = LastResourceDataSyncStatus;
exports.ListAssociationVersions$ = ListAssociationVersions$;
exports.ListAssociationVersionsCommand = ListAssociationVersionsCommand;
exports.ListAssociationVersionsRequest$ = ListAssociationVersionsRequest$;
exports.ListAssociationVersionsResult$ = ListAssociationVersionsResult$;
exports.ListAssociations$ = ListAssociations$;
exports.ListAssociationsCommand = ListAssociationsCommand;
exports.ListAssociationsRequest$ = ListAssociationsRequest$;
exports.ListAssociationsResult$ = ListAssociationsResult$;
exports.ListCommandInvocations$ = ListCommandInvocations$;
exports.ListCommandInvocationsCommand = ListCommandInvocationsCommand;
exports.ListCommandInvocationsRequest$ = ListCommandInvocationsRequest$;
exports.ListCommandInvocationsResult$ = ListCommandInvocationsResult$;
exports.ListCommands$ = ListCommands$;
exports.ListCommandsCommand = ListCommandsCommand;
exports.ListCommandsRequest$ = ListCommandsRequest$;
exports.ListCommandsResult$ = ListCommandsResult$;
exports.ListComplianceItems$ = ListComplianceItems$;
exports.ListComplianceItemsCommand = ListComplianceItemsCommand;
exports.ListComplianceItemsRequest$ = ListComplianceItemsRequest$;
exports.ListComplianceItemsResult$ = ListComplianceItemsResult$;
exports.ListComplianceSummaries$ = ListComplianceSummaries$;
exports.ListComplianceSummariesCommand = ListComplianceSummariesCommand;
exports.ListComplianceSummariesRequest$ = ListComplianceSummariesRequest$;
exports.ListComplianceSummariesResult$ = ListComplianceSummariesResult$;
exports.ListDocumentMetadataHistory$ = ListDocumentMetadataHistory$;
exports.ListDocumentMetadataHistoryCommand = ListDocumentMetadataHistoryCommand;
exports.ListDocumentMetadataHistoryRequest$ = ListDocumentMetadataHistoryRequest$;
exports.ListDocumentMetadataHistoryResponse$ = ListDocumentMetadataHistoryResponse$;
exports.ListDocumentVersions$ = ListDocumentVersions$;
exports.ListDocumentVersionsCommand = ListDocumentVersionsCommand;
exports.ListDocumentVersionsRequest$ = ListDocumentVersionsRequest$;
exports.ListDocumentVersionsResult$ = ListDocumentVersionsResult$;
exports.ListDocuments$ = ListDocuments$;
exports.ListDocumentsCommand = ListDocumentsCommand;
exports.ListDocumentsRequest$ = ListDocumentsRequest$;
exports.ListDocumentsResult$ = ListDocumentsResult$;
exports.ListInventoryEntries$ = ListInventoryEntries$;
exports.ListInventoryEntriesCommand = ListInventoryEntriesCommand;
exports.ListInventoryEntriesRequest$ = ListInventoryEntriesRequest$;
exports.ListInventoryEntriesResult$ = ListInventoryEntriesResult$;
exports.ListNodes$ = ListNodes$;
exports.ListNodesCommand = ListNodesCommand;
exports.ListNodesRequest$ = ListNodesRequest$;
exports.ListNodesResult$ = ListNodesResult$;
exports.ListNodesSummary$ = ListNodesSummary$;
exports.ListNodesSummaryCommand = ListNodesSummaryCommand;
exports.ListNodesSummaryRequest$ = ListNodesSummaryRequest$;
exports.ListNodesSummaryResult$ = ListNodesSummaryResult$;
exports.ListOpsItemEvents$ = ListOpsItemEvents$;
exports.ListOpsItemEventsCommand = ListOpsItemEventsCommand;
exports.ListOpsItemEventsRequest$ = ListOpsItemEventsRequest$;
exports.ListOpsItemEventsResponse$ = ListOpsItemEventsResponse$;
exports.ListOpsItemRelatedItems$ = ListOpsItemRelatedItems$;
exports.ListOpsItemRelatedItemsCommand = ListOpsItemRelatedItemsCommand;
exports.ListOpsItemRelatedItemsRequest$ = ListOpsItemRelatedItemsRequest$;
exports.ListOpsItemRelatedItemsResponse$ = ListOpsItemRelatedItemsResponse$;
exports.ListOpsMetadata$ = ListOpsMetadata$;
exports.ListOpsMetadataCommand = ListOpsMetadataCommand;
exports.ListOpsMetadataRequest$ = ListOpsMetadataRequest$;
exports.ListOpsMetadataResult$ = ListOpsMetadataResult$;
exports.ListResourceComplianceSummaries$ = ListResourceComplianceSummaries$;
exports.ListResourceComplianceSummariesCommand = ListResourceComplianceSummariesCommand;
exports.ListResourceComplianceSummariesRequest$ = ListResourceComplianceSummariesRequest$;
exports.ListResourceComplianceSummariesResult$ = ListResourceComplianceSummariesResult$;
exports.ListResourceDataSync$ = ListResourceDataSync$;
exports.ListResourceDataSyncCommand = ListResourceDataSyncCommand;
exports.ListResourceDataSyncRequest$ = ListResourceDataSyncRequest$;
exports.ListResourceDataSyncResult$ = ListResourceDataSyncResult$;
exports.ListTagsForResource$ = ListTagsForResource$;
exports.ListTagsForResourceCommand = ListTagsForResourceCommand;
exports.ListTagsForResourceRequest$ = ListTagsForResourceRequest$;
exports.ListTagsForResourceResult$ = ListTagsForResourceResult$;
exports.LoggingInfo$ = LoggingInfo$;
exports.MaintenanceWindowAutomationParameters$ = MaintenanceWindowAutomationParameters$;
exports.MaintenanceWindowExecution$ = MaintenanceWindowExecution$;
exports.MaintenanceWindowExecutionStatus = MaintenanceWindowExecutionStatus;
exports.MaintenanceWindowExecutionTaskIdentity$ = MaintenanceWindowExecutionTaskIdentity$;
exports.MaintenanceWindowExecutionTaskInvocationIdentity$ = MaintenanceWindowExecutionTaskInvocationIdentity$;
exports.MaintenanceWindowFilter$ = MaintenanceWindowFilter$;
exports.MaintenanceWindowIdentity$ = MaintenanceWindowIdentity$;
exports.MaintenanceWindowIdentityForTarget$ = MaintenanceWindowIdentityForTarget$;
exports.MaintenanceWindowLambdaParameters$ = MaintenanceWindowLambdaParameters$;
exports.MaintenanceWindowResourceType = MaintenanceWindowResourceType;
exports.MaintenanceWindowRunCommandParameters$ = MaintenanceWindowRunCommandParameters$;
exports.MaintenanceWindowStepFunctionsParameters$ = MaintenanceWindowStepFunctionsParameters$;
exports.MaintenanceWindowTarget$ = MaintenanceWindowTarget$;
exports.MaintenanceWindowTask$ = MaintenanceWindowTask$;
exports.MaintenanceWindowTaskCutoffBehavior = MaintenanceWindowTaskCutoffBehavior;
exports.MaintenanceWindowTaskInvocationParameters$ = MaintenanceWindowTaskInvocationParameters$;
exports.MaintenanceWindowTaskParameterValueExpression$ = MaintenanceWindowTaskParameterValueExpression$;
exports.MaintenanceWindowTaskType = MaintenanceWindowTaskType;
exports.MalformedResourcePolicyDocumentException = MalformedResourcePolicyDocumentException;
exports.MalformedResourcePolicyDocumentException$ = MalformedResourcePolicyDocumentException$;
exports.ManagedStatus = ManagedStatus;
exports.MaxDocumentSizeExceeded = MaxDocumentSizeExceeded;
exports.MaxDocumentSizeExceeded$ = MaxDocumentSizeExceeded$;
exports.MetadataValue$ = MetadataValue$;
exports.ModifyDocumentPermission$ = ModifyDocumentPermission$;
exports.ModifyDocumentPermissionCommand = ModifyDocumentPermissionCommand;
exports.ModifyDocumentPermissionRequest$ = ModifyDocumentPermissionRequest$;
exports.ModifyDocumentPermissionResponse$ = ModifyDocumentPermissionResponse$;
exports.NoLongerSupportedException = NoLongerSupportedException;
exports.NoLongerSupportedException$ = NoLongerSupportedException$;
exports.Node$ = Node$;
exports.NodeAggregator$ = NodeAggregator$;
exports.NodeAggregatorType = NodeAggregatorType;
exports.NodeAttributeName = NodeAttributeName;
exports.NodeFilter$ = NodeFilter$;
exports.NodeFilterKey = NodeFilterKey;
exports.NodeFilterOperatorType = NodeFilterOperatorType;
exports.NodeOwnerInfo$ = NodeOwnerInfo$;
exports.NodeType$ = NodeType$;
exports.NodeTypeName = NodeTypeName;
exports.NonCompliantSummary$ = NonCompliantSummary$;
exports.NotificationConfig$ = NotificationConfig$;
exports.NotificationEvent = NotificationEvent;
exports.NotificationType = NotificationType;
exports.OperatingSystem = OperatingSystem;
exports.OpsAggregator$ = OpsAggregator$;
exports.OpsEntity$ = OpsEntity$;
exports.OpsEntityItem$ = OpsEntityItem$;
exports.OpsFilter$ = OpsFilter$;
exports.OpsFilterOperatorType = OpsFilterOperatorType;
exports.OpsItem$ = OpsItem$;
exports.OpsItemAccessDeniedException = OpsItemAccessDeniedException;
exports.OpsItemAccessDeniedException$ = OpsItemAccessDeniedException$;
exports.OpsItemAlreadyExistsException = OpsItemAlreadyExistsException;
exports.OpsItemAlreadyExistsException$ = OpsItemAlreadyExistsException$;
exports.OpsItemConflictException = OpsItemConflictException;
exports.OpsItemConflictException$ = OpsItemConflictException$;
exports.OpsItemDataType = OpsItemDataType;
exports.OpsItemDataValue$ = OpsItemDataValue$;
exports.OpsItemEventFilter$ = OpsItemEventFilter$;
exports.OpsItemEventFilterKey = OpsItemEventFilterKey;
exports.OpsItemEventFilterOperator = OpsItemEventFilterOperator;
exports.OpsItemEventSummary$ = OpsItemEventSummary$;
exports.OpsItemFilter$ = OpsItemFilter$;
exports.OpsItemFilterKey = OpsItemFilterKey;
exports.OpsItemFilterOperator = OpsItemFilterOperator;
exports.OpsItemIdentity$ = OpsItemIdentity$;
exports.OpsItemInvalidParameterException = OpsItemInvalidParameterException;
exports.OpsItemInvalidParameterException$ = OpsItemInvalidParameterException$;
exports.OpsItemLimitExceededException = OpsItemLimitExceededException;
exports.OpsItemLimitExceededException$ = OpsItemLimitExceededException$;
exports.OpsItemNotFoundException = OpsItemNotFoundException;
exports.OpsItemNotFoundException$ = OpsItemNotFoundException$;
exports.OpsItemNotification$ = OpsItemNotification$;
exports.OpsItemRelatedItemAlreadyExistsException = OpsItemRelatedItemAlreadyExistsException;
exports.OpsItemRelatedItemAlreadyExistsException$ = OpsItemRelatedItemAlreadyExistsException$;
exports.OpsItemRelatedItemAssociationNotFoundException = OpsItemRelatedItemAssociationNotFoundException;
exports.OpsItemRelatedItemAssociationNotFoundException$ = OpsItemRelatedItemAssociationNotFoundException$;
exports.OpsItemRelatedItemSummary$ = OpsItemRelatedItemSummary$;
exports.OpsItemRelatedItemsFilter$ = OpsItemRelatedItemsFilter$;
exports.OpsItemRelatedItemsFilterKey = OpsItemRelatedItemsFilterKey;
exports.OpsItemRelatedItemsFilterOperator = OpsItemRelatedItemsFilterOperator;
exports.OpsItemStatus = OpsItemStatus;
exports.OpsItemSummary$ = OpsItemSummary$;
exports.OpsMetadata$ = OpsMetadata$;
exports.OpsMetadataAlreadyExistsException = OpsMetadataAlreadyExistsException;
exports.OpsMetadataAlreadyExistsException$ = OpsMetadataAlreadyExistsException$;
exports.OpsMetadataFilter$ = OpsMetadataFilter$;
exports.OpsMetadataInvalidArgumentException = OpsMetadataInvalidArgumentException;
exports.OpsMetadataInvalidArgumentException$ = OpsMetadataInvalidArgumentException$;
exports.OpsMetadataKeyLimitExceededException = OpsMetadataKeyLimitExceededException;
exports.OpsMetadataKeyLimitExceededException$ = OpsMetadataKeyLimitExceededException$;
exports.OpsMetadataLimitExceededException = OpsMetadataLimitExceededException;
exports.OpsMetadataLimitExceededException$ = OpsMetadataLimitExceededException$;
exports.OpsMetadataNotFoundException = OpsMetadataNotFoundException;
exports.OpsMetadataNotFoundException$ = OpsMetadataNotFoundException$;
exports.OpsMetadataTooManyUpdatesException = OpsMetadataTooManyUpdatesException;
exports.OpsMetadataTooManyUpdatesException$ = OpsMetadataTooManyUpdatesException$;
exports.OpsResultAttribute$ = OpsResultAttribute$;
exports.OutputSource$ = OutputSource$;
exports.Parameter$ = Parameter$;
exports.ParameterAlreadyExists = ParameterAlreadyExists;
exports.ParameterAlreadyExists$ = ParameterAlreadyExists$;
exports.ParameterHistory$ = ParameterHistory$;
exports.ParameterInlinePolicy$ = ParameterInlinePolicy$;
exports.ParameterLimitExceeded = ParameterLimitExceeded;
exports.ParameterLimitExceeded$ = ParameterLimitExceeded$;
exports.ParameterMaxVersionLimitExceeded = ParameterMaxVersionLimitExceeded;
exports.ParameterMaxVersionLimitExceeded$ = ParameterMaxVersionLimitExceeded$;
exports.ParameterMetadata$ = ParameterMetadata$;
exports.ParameterNotFound = ParameterNotFound;
exports.ParameterNotFound$ = ParameterNotFound$;
exports.ParameterPatternMismatchException = ParameterPatternMismatchException;
exports.ParameterPatternMismatchException$ = ParameterPatternMismatchException$;
exports.ParameterStringFilter$ = ParameterStringFilter$;
exports.ParameterTier = ParameterTier;
exports.ParameterType = ParameterType;
exports.ParameterVersionLabelLimitExceeded = ParameterVersionLabelLimitExceeded;
exports.ParameterVersionLabelLimitExceeded$ = ParameterVersionLabelLimitExceeded$;
exports.ParameterVersionNotFound = ParameterVersionNotFound;
exports.ParameterVersionNotFound$ = ParameterVersionNotFound$;
exports.ParametersFilter$ = ParametersFilter$;
exports.ParametersFilterKey = ParametersFilterKey;
exports.ParentStepDetails$ = ParentStepDetails$;
exports.Patch$ = Patch$;
exports.PatchAction = PatchAction;
exports.PatchBaselineIdentity$ = PatchBaselineIdentity$;
exports.PatchComplianceData$ = PatchComplianceData$;
exports.PatchComplianceDataState = PatchComplianceDataState;
exports.PatchComplianceLevel = PatchComplianceLevel;
exports.PatchComplianceStatus = PatchComplianceStatus;
exports.PatchDeploymentStatus = PatchDeploymentStatus;
exports.PatchFilter$ = PatchFilter$;
exports.PatchFilterGroup$ = PatchFilterGroup$;
exports.PatchFilterKey = PatchFilterKey;
exports.PatchGroupPatchBaselineMapping$ = PatchGroupPatchBaselineMapping$;
exports.PatchOperationType = PatchOperationType;
exports.PatchOrchestratorFilter$ = PatchOrchestratorFilter$;
exports.PatchProperty = PatchProperty;
exports.PatchRule$ = PatchRule$;
exports.PatchRuleGroup$ = PatchRuleGroup$;
exports.PatchSet = PatchSet;
exports.PatchSource$ = PatchSource$;
exports.PatchStatus$ = PatchStatus$;
exports.PingStatus = PingStatus;
exports.PlatformType = PlatformType;
exports.PoliciesLimitExceededException = PoliciesLimitExceededException;
exports.PoliciesLimitExceededException$ = PoliciesLimitExceededException$;
exports.ProgressCounters$ = ProgressCounters$;
exports.PutComplianceItems$ = PutComplianceItems$;
exports.PutComplianceItemsCommand = PutComplianceItemsCommand;
exports.PutComplianceItemsRequest$ = PutComplianceItemsRequest$;
exports.PutComplianceItemsResult$ = PutComplianceItemsResult$;
exports.PutInventory$ = PutInventory$;
exports.PutInventoryCommand = PutInventoryCommand;
exports.PutInventoryRequest$ = PutInventoryRequest$;
exports.PutInventoryResult$ = PutInventoryResult$;
exports.PutParameter$ = PutParameter$;
exports.PutParameterCommand = PutParameterCommand;
exports.PutParameterRequest$ = PutParameterRequest$;
exports.PutParameterResult$ = PutParameterResult$;
exports.PutResourcePolicy$ = PutResourcePolicy$;
exports.PutResourcePolicyCommand = PutResourcePolicyCommand;
exports.PutResourcePolicyRequest$ = PutResourcePolicyRequest$;
exports.PutResourcePolicyResponse$ = PutResourcePolicyResponse$;
exports.RebootOption = RebootOption;
exports.RegisterDefaultPatchBaseline$ = RegisterDefaultPatchBaseline$;
exports.RegisterDefaultPatchBaselineCommand = RegisterDefaultPatchBaselineCommand;
exports.RegisterDefaultPatchBaselineRequest$ = RegisterDefaultPatchBaselineRequest$;
exports.RegisterDefaultPatchBaselineResult$ = RegisterDefaultPatchBaselineResult$;
exports.RegisterPatchBaselineForPatchGroup$ = RegisterPatchBaselineForPatchGroup$;
exports.RegisterPatchBaselineForPatchGroupCommand = RegisterPatchBaselineForPatchGroupCommand;
exports.RegisterPatchBaselineForPatchGroupRequest$ = RegisterPatchBaselineForPatchGroupRequest$;
exports.RegisterPatchBaselineForPatchGroupResult$ = RegisterPatchBaselineForPatchGroupResult$;
exports.RegisterTargetWithMaintenanceWindow$ = RegisterTargetWithMaintenanceWindow$;
exports.RegisterTargetWithMaintenanceWindowCommand = RegisterTargetWithMaintenanceWindowCommand;
exports.RegisterTargetWithMaintenanceWindowRequest$ = RegisterTargetWithMaintenanceWindowRequest$;
exports.RegisterTargetWithMaintenanceWindowResult$ = RegisterTargetWithMaintenanceWindowResult$;
exports.RegisterTaskWithMaintenanceWindow$ = RegisterTaskWithMaintenanceWindow$;
exports.RegisterTaskWithMaintenanceWindowCommand = RegisterTaskWithMaintenanceWindowCommand;
exports.RegisterTaskWithMaintenanceWindowRequest$ = RegisterTaskWithMaintenanceWindowRequest$;
exports.RegisterTaskWithMaintenanceWindowResult$ = RegisterTaskWithMaintenanceWindowResult$;
exports.RegistrationMetadataItem$ = RegistrationMetadataItem$;
exports.RelatedOpsItem$ = RelatedOpsItem$;
exports.RemoveTagsFromResource$ = RemoveTagsFromResource$;
exports.RemoveTagsFromResourceCommand = RemoveTagsFromResourceCommand;
exports.RemoveTagsFromResourceRequest$ = RemoveTagsFromResourceRequest$;
exports.RemoveTagsFromResourceResult$ = RemoveTagsFromResourceResult$;
exports.ResetServiceSetting$ = ResetServiceSetting$;
exports.ResetServiceSettingCommand = ResetServiceSettingCommand;
exports.ResetServiceSettingRequest$ = ResetServiceSettingRequest$;
exports.ResetServiceSettingResult$ = ResetServiceSettingResult$;
exports.ResolvedTargets$ = ResolvedTargets$;
exports.ResourceComplianceSummaryItem$ = ResourceComplianceSummaryItem$;
exports.ResourceDataSyncAlreadyExistsException = ResourceDataSyncAlreadyExistsException;
exports.ResourceDataSyncAlreadyExistsException$ = ResourceDataSyncAlreadyExistsException$;
exports.ResourceDataSyncAwsOrganizationsSource$ = ResourceDataSyncAwsOrganizationsSource$;
exports.ResourceDataSyncConflictException = ResourceDataSyncConflictException;
exports.ResourceDataSyncConflictException$ = ResourceDataSyncConflictException$;
exports.ResourceDataSyncCountExceededException = ResourceDataSyncCountExceededException;
exports.ResourceDataSyncCountExceededException$ = ResourceDataSyncCountExceededException$;
exports.ResourceDataSyncDestinationDataSharing$ = ResourceDataSyncDestinationDataSharing$;
exports.ResourceDataSyncInvalidConfigurationException = ResourceDataSyncInvalidConfigurationException;
exports.ResourceDataSyncInvalidConfigurationException$ = ResourceDataSyncInvalidConfigurationException$;
exports.ResourceDataSyncItem$ = ResourceDataSyncItem$;
exports.ResourceDataSyncNotFoundException = ResourceDataSyncNotFoundException;
exports.ResourceDataSyncNotFoundException$ = ResourceDataSyncNotFoundException$;
exports.ResourceDataSyncOrganizationalUnit$ = ResourceDataSyncOrganizationalUnit$;
exports.ResourceDataSyncS3Destination$ = ResourceDataSyncS3Destination$;
exports.ResourceDataSyncS3Format = ResourceDataSyncS3Format;
exports.ResourceDataSyncSource$ = ResourceDataSyncSource$;
exports.ResourceDataSyncSourceWithState$ = ResourceDataSyncSourceWithState$;
exports.ResourceInUseException = ResourceInUseException;
exports.ResourceInUseException$ = ResourceInUseException$;
exports.ResourceLimitExceededException = ResourceLimitExceededException;
exports.ResourceLimitExceededException$ = ResourceLimitExceededException$;
exports.ResourceNotFoundException = ResourceNotFoundException;
exports.ResourceNotFoundException$ = ResourceNotFoundException$;
exports.ResourcePolicyConflictException = ResourcePolicyConflictException;
exports.ResourcePolicyConflictException$ = ResourcePolicyConflictException$;
exports.ResourcePolicyInvalidParameterException = ResourcePolicyInvalidParameterException;
exports.ResourcePolicyInvalidParameterException$ = ResourcePolicyInvalidParameterException$;
exports.ResourcePolicyLimitExceededException = ResourcePolicyLimitExceededException;
exports.ResourcePolicyLimitExceededException$ = ResourcePolicyLimitExceededException$;
exports.ResourcePolicyNotFoundException = ResourcePolicyNotFoundException;
exports.ResourcePolicyNotFoundException$ = ResourcePolicyNotFoundException$;
exports.ResourceType = ResourceType;
exports.ResourceTypeForTagging = ResourceTypeForTagging;
exports.ResultAttribute$ = ResultAttribute$;
exports.ResumeSession$ = ResumeSession$;
exports.ResumeSessionCommand = ResumeSessionCommand;
exports.ResumeSessionRequest$ = ResumeSessionRequest$;
exports.ResumeSessionResponse$ = ResumeSessionResponse$;
exports.ReviewInformation$ = ReviewInformation$;
exports.ReviewStatus = ReviewStatus;
exports.Runbook$ = Runbook$;
exports.S3OutputLocation$ = S3OutputLocation$;
exports.S3OutputUrl$ = S3OutputUrl$;
exports.SSM = SSM;
exports.SSMClient = SSMClient;
exports.SSMServiceException = SSMServiceException;
exports.SSMServiceException$ = SSMServiceException$;
exports.ScheduledWindowExecution$ = ScheduledWindowExecution$;
exports.SendAutomationSignal$ = SendAutomationSignal$;
exports.SendAutomationSignalCommand = SendAutomationSignalCommand;
exports.SendAutomationSignalRequest$ = SendAutomationSignalRequest$;
exports.SendAutomationSignalResult$ = SendAutomationSignalResult$;
exports.SendCommand$ = SendCommand$;
exports.SendCommandCommand = SendCommandCommand;
exports.SendCommandRequest$ = SendCommandRequest$;
exports.SendCommandResult$ = SendCommandResult$;
exports.ServiceQuotaExceededException = ServiceQuotaExceededException;
exports.ServiceQuotaExceededException$ = ServiceQuotaExceededException$;
exports.ServiceSetting$ = ServiceSetting$;
exports.ServiceSettingNotFound = ServiceSettingNotFound;
exports.ServiceSettingNotFound$ = ServiceSettingNotFound$;
exports.Session$ = Session$;
exports.SessionFilter$ = SessionFilter$;
exports.SessionFilterKey = SessionFilterKey;
exports.SessionManagerOutputUrl$ = SessionManagerOutputUrl$;
exports.SessionState = SessionState;
exports.SessionStatus = SessionStatus;
exports.SeveritySummary$ = SeveritySummary$;
exports.SignalType = SignalType;
exports.SourceType = SourceType;
exports.StartAccessRequest$ = StartAccessRequest$;
exports.StartAccessRequestCommand = StartAccessRequestCommand;
exports.StartAccessRequestRequest$ = StartAccessRequestRequest$;
exports.StartAccessRequestResponse$ = StartAccessRequestResponse$;
exports.StartAssociationsOnce$ = StartAssociationsOnce$;
exports.StartAssociationsOnceCommand = StartAssociationsOnceCommand;
exports.StartAssociationsOnceRequest$ = StartAssociationsOnceRequest$;
exports.StartAssociationsOnceResult$ = StartAssociationsOnceResult$;
exports.StartAutomationExecution$ = StartAutomationExecution$;
exports.StartAutomationExecutionCommand = StartAutomationExecutionCommand;
exports.StartAutomationExecutionRequest$ = StartAutomationExecutionRequest$;
exports.StartAutomationExecutionResult$ = StartAutomationExecutionResult$;
exports.StartChangeRequestExecution$ = StartChangeRequestExecution$;
exports.StartChangeRequestExecutionCommand = StartChangeRequestExecutionCommand;
exports.StartChangeRequestExecutionRequest$ = StartChangeRequestExecutionRequest$;
exports.StartChangeRequestExecutionResult$ = StartChangeRequestExecutionResult$;
exports.StartExecutionPreview$ = StartExecutionPreview$;
exports.StartExecutionPreviewCommand = StartExecutionPreviewCommand;
exports.StartExecutionPreviewRequest$ = StartExecutionPreviewRequest$;
exports.StartExecutionPreviewResponse$ = StartExecutionPreviewResponse$;
exports.StartSession$ = StartSession$;
exports.StartSessionCommand = StartSessionCommand;
exports.StartSessionRequest$ = StartSessionRequest$;
exports.StartSessionResponse$ = StartSessionResponse$;
exports.StatusUnchanged = StatusUnchanged;
exports.StatusUnchanged$ = StatusUnchanged$;
exports.StepExecution$ = StepExecution$;
exports.StepExecutionFilter$ = StepExecutionFilter$;
exports.StepExecutionFilterKey = StepExecutionFilterKey;
exports.StopAutomationExecution$ = StopAutomationExecution$;
exports.StopAutomationExecutionCommand = StopAutomationExecutionCommand;
exports.StopAutomationExecutionRequest$ = StopAutomationExecutionRequest$;
exports.StopAutomationExecutionResult$ = StopAutomationExecutionResult$;
exports.StopType = StopType;
exports.SubTypeCountLimitExceededException = SubTypeCountLimitExceededException;
exports.SubTypeCountLimitExceededException$ = SubTypeCountLimitExceededException$;
exports.Tag$ = Tag$;
exports.Target$ = Target$;
exports.TargetInUseException = TargetInUseException;
exports.TargetInUseException$ = TargetInUseException$;
exports.TargetLocation$ = TargetLocation$;
exports.TargetNotConnected = TargetNotConnected;
exports.TargetNotConnected$ = TargetNotConnected$;
exports.TargetPreview$ = TargetPreview$;
exports.TerminateSession$ = TerminateSession$;
exports.TerminateSessionCommand = TerminateSessionCommand;
exports.TerminateSessionRequest$ = TerminateSessionRequest$;
exports.TerminateSessionResponse$ = TerminateSessionResponse$;
exports.ThrottlingException = ThrottlingException;
exports.ThrottlingException$ = ThrottlingException$;
exports.TooManyTagsError = TooManyTagsError;
exports.TooManyTagsError$ = TooManyTagsError$;
exports.TooManyUpdates = TooManyUpdates;
exports.TooManyUpdates$ = TooManyUpdates$;
exports.TotalSizeLimitExceededException = TotalSizeLimitExceededException;
exports.TotalSizeLimitExceededException$ = TotalSizeLimitExceededException$;
exports.UnlabelParameterVersion$ = UnlabelParameterVersion$;
exports.UnlabelParameterVersionCommand = UnlabelParameterVersionCommand;
exports.UnlabelParameterVersionRequest$ = UnlabelParameterVersionRequest$;
exports.UnlabelParameterVersionResult$ = UnlabelParameterVersionResult$;
exports.UnsupportedCalendarException = UnsupportedCalendarException;
exports.UnsupportedCalendarException$ = UnsupportedCalendarException$;
exports.UnsupportedFeatureRequiredException = UnsupportedFeatureRequiredException;
exports.UnsupportedFeatureRequiredException$ = UnsupportedFeatureRequiredException$;
exports.UnsupportedInventoryItemContextException = UnsupportedInventoryItemContextException;
exports.UnsupportedInventoryItemContextException$ = UnsupportedInventoryItemContextException$;
exports.UnsupportedInventorySchemaVersionException = UnsupportedInventorySchemaVersionException;
exports.UnsupportedInventorySchemaVersionException$ = UnsupportedInventorySchemaVersionException$;
exports.UnsupportedOperatingSystem = UnsupportedOperatingSystem;
exports.UnsupportedOperatingSystem$ = UnsupportedOperatingSystem$;
exports.UnsupportedOperationException = UnsupportedOperationException;
exports.UnsupportedOperationException$ = UnsupportedOperationException$;
exports.UnsupportedParameterType = UnsupportedParameterType;
exports.UnsupportedParameterType$ = UnsupportedParameterType$;
exports.UnsupportedPlatformType = UnsupportedPlatformType;
exports.UnsupportedPlatformType$ = UnsupportedPlatformType$;
exports.UpdateAssociation$ = UpdateAssociation$;
exports.UpdateAssociationCommand = UpdateAssociationCommand;
exports.UpdateAssociationRequest$ = UpdateAssociationRequest$;
exports.UpdateAssociationResult$ = UpdateAssociationResult$;
exports.UpdateAssociationStatus$ = UpdateAssociationStatus$;
exports.UpdateAssociationStatusCommand = UpdateAssociationStatusCommand;
exports.UpdateAssociationStatusRequest$ = UpdateAssociationStatusRequest$;
exports.UpdateAssociationStatusResult$ = UpdateAssociationStatusResult$;
exports.UpdateDocument$ = UpdateDocument$;
exports.UpdateDocumentCommand = UpdateDocumentCommand;
exports.UpdateDocumentDefaultVersion$ = UpdateDocumentDefaultVersion$;
exports.UpdateDocumentDefaultVersionCommand = UpdateDocumentDefaultVersionCommand;
exports.UpdateDocumentDefaultVersionRequest$ = UpdateDocumentDefaultVersionRequest$;
exports.UpdateDocumentDefaultVersionResult$ = UpdateDocumentDefaultVersionResult$;
exports.UpdateDocumentMetadata$ = UpdateDocumentMetadata$;
exports.UpdateDocumentMetadataCommand = UpdateDocumentMetadataCommand;
exports.UpdateDocumentMetadataRequest$ = UpdateDocumentMetadataRequest$;
exports.UpdateDocumentMetadataResponse$ = UpdateDocumentMetadataResponse$;
exports.UpdateDocumentRequest$ = UpdateDocumentRequest$;
exports.UpdateDocumentResult$ = UpdateDocumentResult$;
exports.UpdateMaintenanceWindow$ = UpdateMaintenanceWindow$;
exports.UpdateMaintenanceWindowCommand = UpdateMaintenanceWindowCommand;
exports.UpdateMaintenanceWindowRequest$ = UpdateMaintenanceWindowRequest$;
exports.UpdateMaintenanceWindowResult$ = UpdateMaintenanceWindowResult$;
exports.UpdateMaintenanceWindowTarget$ = UpdateMaintenanceWindowTarget$;
exports.UpdateMaintenanceWindowTargetCommand = UpdateMaintenanceWindowTargetCommand;
exports.UpdateMaintenanceWindowTargetRequest$ = UpdateMaintenanceWindowTargetRequest$;
exports.UpdateMaintenanceWindowTargetResult$ = UpdateMaintenanceWindowTargetResult$;
exports.UpdateMaintenanceWindowTask$ = UpdateMaintenanceWindowTask$;
exports.UpdateMaintenanceWindowTaskCommand = UpdateMaintenanceWindowTaskCommand;
exports.UpdateMaintenanceWindowTaskRequest$ = UpdateMaintenanceWindowTaskRequest$;
exports.UpdateMaintenanceWindowTaskResult$ = UpdateMaintenanceWindowTaskResult$;
exports.UpdateManagedInstanceRole$ = UpdateManagedInstanceRole$;
exports.UpdateManagedInstanceRoleCommand = UpdateManagedInstanceRoleCommand;
exports.UpdateManagedInstanceRoleRequest$ = UpdateManagedInstanceRoleRequest$;
exports.UpdateManagedInstanceRoleResult$ = UpdateManagedInstanceRoleResult$;
exports.UpdateOpsItem$ = UpdateOpsItem$;
exports.UpdateOpsItemCommand = UpdateOpsItemCommand;
exports.UpdateOpsItemRequest$ = UpdateOpsItemRequest$;
exports.UpdateOpsItemResponse$ = UpdateOpsItemResponse$;
exports.UpdateOpsMetadata$ = UpdateOpsMetadata$;
exports.UpdateOpsMetadataCommand = UpdateOpsMetadataCommand;
exports.UpdateOpsMetadataRequest$ = UpdateOpsMetadataRequest$;
exports.UpdateOpsMetadataResult$ = UpdateOpsMetadataResult$;
exports.UpdatePatchBaseline$ = UpdatePatchBaseline$;
exports.UpdatePatchBaselineCommand = UpdatePatchBaselineCommand;
exports.UpdatePatchBaselineRequest$ = UpdatePatchBaselineRequest$;
exports.UpdatePatchBaselineResult$ = UpdatePatchBaselineResult$;
exports.UpdateResourceDataSync$ = UpdateResourceDataSync$;
exports.UpdateResourceDataSyncCommand = UpdateResourceDataSyncCommand;
exports.UpdateResourceDataSyncRequest$ = UpdateResourceDataSyncRequest$;
exports.UpdateResourceDataSyncResult$ = UpdateResourceDataSyncResult$;
exports.UpdateServiceSetting$ = UpdateServiceSetting$;
exports.UpdateServiceSettingCommand = UpdateServiceSettingCommand;
exports.UpdateServiceSettingRequest$ = UpdateServiceSettingRequest$;
exports.UpdateServiceSettingResult$ = UpdateServiceSettingResult$;
exports.ValidationException = ValidationException;
exports.ValidationException$ = ValidationException$;
exports.paginateDescribeActivations = paginateDescribeActivations;
exports.paginateDescribeAssociationExecutionTargets = paginateDescribeAssociationExecutionTargets;
exports.paginateDescribeAssociationExecutions = paginateDescribeAssociationExecutions;
exports.paginateDescribeAutomationExecutions = paginateDescribeAutomationExecutions;
exports.paginateDescribeAutomationStepExecutions = paginateDescribeAutomationStepExecutions;
exports.paginateDescribeAvailablePatches = paginateDescribeAvailablePatches;
exports.paginateDescribeEffectiveInstanceAssociations = paginateDescribeEffectiveInstanceAssociations;
exports.paginateDescribeEffectivePatchesForPatchBaseline = paginateDescribeEffectivePatchesForPatchBaseline;
exports.paginateDescribeInstanceAssociationsStatus = paginateDescribeInstanceAssociationsStatus;
exports.paginateDescribeInstanceInformation = paginateDescribeInstanceInformation;
exports.paginateDescribeInstancePatchStates = paginateDescribeInstancePatchStates;
exports.paginateDescribeInstancePatchStatesForPatchGroup = paginateDescribeInstancePatchStatesForPatchGroup;
exports.paginateDescribeInstancePatches = paginateDescribeInstancePatches;
exports.paginateDescribeInstanceProperties = paginateDescribeInstanceProperties;
exports.paginateDescribeInventoryDeletions = paginateDescribeInventoryDeletions;
exports.paginateDescribeMaintenanceWindowExecutionTaskInvocations = paginateDescribeMaintenanceWindowExecutionTaskInvocations;
exports.paginateDescribeMaintenanceWindowExecutionTasks = paginateDescribeMaintenanceWindowExecutionTasks;
exports.paginateDescribeMaintenanceWindowExecutions = paginateDescribeMaintenanceWindowExecutions;
exports.paginateDescribeMaintenanceWindowSchedule = paginateDescribeMaintenanceWindowSchedule;
exports.paginateDescribeMaintenanceWindowTargets = paginateDescribeMaintenanceWindowTargets;
exports.paginateDescribeMaintenanceWindowTasks = paginateDescribeMaintenanceWindowTasks;
exports.paginateDescribeMaintenanceWindows = paginateDescribeMaintenanceWindows;
exports.paginateDescribeMaintenanceWindowsForTarget = paginateDescribeMaintenanceWindowsForTarget;
exports.paginateDescribeOpsItems = paginateDescribeOpsItems;
exports.paginateDescribeParameters = paginateDescribeParameters;
exports.paginateDescribePatchBaselines = paginateDescribePatchBaselines;
exports.paginateDescribePatchGroups = paginateDescribePatchGroups;
exports.paginateDescribePatchProperties = paginateDescribePatchProperties;
exports.paginateDescribeSessions = paginateDescribeSessions;
exports.paginateGetInventory = paginateGetInventory;
exports.paginateGetInventorySchema = paginateGetInventorySchema;
exports.paginateGetOpsSummary = paginateGetOpsSummary;
exports.paginateGetParameterHistory = paginateGetParameterHistory;
exports.paginateGetParametersByPath = paginateGetParametersByPath;
exports.paginateGetResourcePolicies = paginateGetResourcePolicies;
exports.paginateListAssociationVersions = paginateListAssociationVersions;
exports.paginateListAssociations = paginateListAssociations;
exports.paginateListCommandInvocations = paginateListCommandInvocations;
exports.paginateListCommands = paginateListCommands;
exports.paginateListComplianceItems = paginateListComplianceItems;
exports.paginateListComplianceSummaries = paginateListComplianceSummaries;
exports.paginateListDocumentVersions = paginateListDocumentVersions;
exports.paginateListDocuments = paginateListDocuments;
exports.paginateListNodes = paginateListNodes;
exports.paginateListNodesSummary = paginateListNodesSummary;
exports.paginateListOpsItemEvents = paginateListOpsItemEvents;
exports.paginateListOpsItemRelatedItems = paginateListOpsItemRelatedItems;
exports.paginateListOpsMetadata = paginateListOpsMetadata;
exports.paginateListResourceComplianceSummaries = paginateListResourceComplianceSummaries;
exports.paginateListResourceDataSync = paginateListResourceDataSync;
exports.waitForCommandExecuted = waitForCommandExecuted;
exports.waitUntilCommandExecuted = waitUntilCommandExecuted;


/***/ }),

/***/ 8509:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const tslib_1 = __nccwpck_require__(4351);
const package_json_1 = tslib_1.__importDefault(__nccwpck_require__(466));
const core_1 = __nccwpck_require__(9963);
const credential_provider_node_1 = __nccwpck_require__(5531);
const util_user_agent_node_1 = __nccwpck_require__(8095);
const config_resolver_1 = __nccwpck_require__(3098);
const hash_node_1 = __nccwpck_require__(3081);
const middleware_retry_1 = __nccwpck_require__(6039);
const node_config_provider_1 = __nccwpck_require__(3461);
const node_http_handler_1 = __nccwpck_require__(258);
const smithy_client_1 = __nccwpck_require__(3570);
const util_body_length_node_1 = __nccwpck_require__(8075);
const util_defaults_mode_node_1 = __nccwpck_require__(2429);
const util_retry_1 = __nccwpck_require__(4902);
const runtimeConfig_shared_1 = __nccwpck_require__(2214);
const getRuntimeConfig = (config) => {
    (0, smithy_client_1.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = () => defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    (0, core_1.emitWarningIfUnsupportedVersion)(process.version);
    const loaderConfig = {
        profile: config?.profile,
        logger: clientSharedValues.logger,
    };
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        authSchemePreference: config?.authSchemePreference ?? (0, node_config_provider_1.loadConfig)(core_1.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS, loaderConfig),
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? credential_provider_node_1.defaultProvider,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.createDefaultUserAgentProvider)({ serviceId: clientSharedValues.serviceId, clientVersion: package_json_1.default.version }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS, config),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig }),
        requestHandler: node_http_handler_1.NodeHttpHandler.create(config?.requestHandler ?? defaultConfigProvider),
        retryMode: config?.retryMode ??
            (0, node_config_provider_1.loadConfig)({
                ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
                default: async () => (await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE,
            }, config),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS, loaderConfig),
        userAgentAppId: config?.userAgentAppId ?? (0, node_config_provider_1.loadConfig)(util_user_agent_node_1.NODE_APP_ID_CONFIG_OPTIONS, loaderConfig),
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 2214:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRuntimeConfig = void 0;
const core_1 = __nccwpck_require__(9963);
const protocols_1 = __nccwpck_require__(785);
const smithy_client_1 = __nccwpck_require__(3570);
const url_parser_1 = __nccwpck_require__(4681);
const util_base64_1 = __nccwpck_require__(5600);
const util_utf8_1 = __nccwpck_require__(1895);
const httpAuthSchemeProvider_1 = __nccwpck_require__(3791);
const endpointResolver_1 = __nccwpck_require__(4521);
const getRuntimeConfig = (config) => {
    return {
        apiVersion: "2014-11-06",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        httpAuthSchemeProvider: config?.httpAuthSchemeProvider ?? httpAuthSchemeProvider_1.defaultSSMHttpAuthSchemeProvider,
        httpAuthSchemes: config?.httpAuthSchemes ?? [
            {
                schemeId: "aws.auth#sigv4",
                identityProvider: (ipc) => ipc.getIdentityProvider("aws.auth#sigv4"),
                signer: new core_1.AwsSdkSigV4Signer(),
            },
        ],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        protocol: config?.protocol ?? protocols_1.AwsJson1_1Protocol,
        protocolSettings: config?.protocolSettings ?? {
            defaultNamespace: "com.amazonaws.ssm",
            xmlNamespace: "http://ssm.amazonaws.com/doc/2014-11-06/",
            version: "2014-11-06",
            serviceTarget: "AmazonSSM",
        },
        serviceId: config?.serviceId ?? "SSM",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8,
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 9963:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var protocolHttp = __nccwpck_require__(4418);
var core = __nccwpck_require__(5829);
var propertyProvider = __nccwpck_require__(9721);
var client = __nccwpck_require__(2825);
var signatureV4 = __nccwpck_require__(1528);
var cbor = __nccwpck_require__(804);
var schema = __nccwpck_require__(9826);
var smithyClient = __nccwpck_require__(3570);
var protocols = __nccwpck_require__(2241);
var serde = __nccwpck_require__(7669);
var utilBase64 = __nccwpck_require__(5600);
var utilUtf8 = __nccwpck_require__(1895);
var xmlBuilder = __nccwpck_require__(2329);

const state = {
    warningEmitted: false,
};
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !state.warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 20) {
        state.warningEmitted = true;
        process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js ${version} in January 2026.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/c895JFp`);
    }
};

function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
        credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
}

function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
        context.__aws_sdk_context = {
            features: {},
        };
    }
    else if (!context.__aws_sdk_context.features) {
        context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
}

function setTokenFeature(token, feature, value) {
    if (!token.$source) {
        token.$source = {};
    }
    token.$source[feature] = value;
    return token;
}

const getDateHeader = (response) => protocolHttp.HttpResponse.isInstance(response) ? response.headers?.date ?? response.headers?.Date : undefined;

const getSkewCorrectedDate = (systemClockOffset) => new Date(Date.now() + systemClockOffset);

const isClockSkewed = (clockTime, systemClockOffset) => Math.abs(getSkewCorrectedDate(systemClockOffset).getTime() - clockTime) >= 300000;

const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset) => {
    const clockTimeInMs = Date.parse(clockTime);
    if (isClockSkewed(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
};

const throwSigningPropertyError = (name, property) => {
    if (!property) {
        throw new Error(`Property \`${name}\` is not resolved for AWS SDK SigV4Auth`);
    }
    return property;
};
const validateSigningProperties = async (signingProperties) => {
    const context = throwSigningPropertyError("context", signingProperties.context);
    const config = throwSigningPropertyError("config", signingProperties.config);
    const authScheme = context.endpointV2?.properties?.authSchemes?.[0];
    const signerFunction = throwSigningPropertyError("signer", config.signer);
    const signer = await signerFunction(authScheme);
    const signingRegion = signingProperties?.signingRegion;
    const signingRegionSet = signingProperties?.signingRegionSet;
    const signingName = signingProperties?.signingName;
    return {
        config,
        signer,
        signingRegion,
        signingRegionSet,
        signingName,
    };
};
class AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
        if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
            throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const validatedProps = await validateSigningProperties(signingProperties);
        const { config, signer } = validatedProps;
        let { signingRegion, signingName } = validatedProps;
        const handlerExecutionContext = signingProperties.context;
        if (handlerExecutionContext?.authSchemes?.length ?? 0 > 1) {
            const [first, second] = handlerExecutionContext.authSchemes;
            if (first?.name === "sigv4a" && second?.name === "sigv4") {
                signingRegion = second?.signingRegion ?? signingRegion;
                signingName = second?.signingName ?? signingName;
            }
        }
        const signedRequest = await signer.sign(httpRequest, {
            signingDate: getSkewCorrectedDate(config.systemClockOffset),
            signingRegion: signingRegion,
            signingService: signingName,
        });
        return signedRequest;
    }
    errorHandler(signingProperties) {
        return (error) => {
            const serverTime = error.ServerTime ?? getDateHeader(error.$response);
            if (serverTime) {
                const config = throwSigningPropertyError("config", signingProperties.config);
                const initialSystemClockOffset = config.systemClockOffset;
                config.systemClockOffset = getUpdatedSystemClockOffset(serverTime, config.systemClockOffset);
                const clockSkewCorrected = config.systemClockOffset !== initialSystemClockOffset;
                if (clockSkewCorrected && error.$metadata) {
                    error.$metadata.clockSkewCorrected = true;
                }
            }
            throw error;
        };
    }
    successHandler(httpResponse, signingProperties) {
        const dateHeader = getDateHeader(httpResponse);
        if (dateHeader) {
            const config = throwSigningPropertyError("config", signingProperties.config);
            config.systemClockOffset = getUpdatedSystemClockOffset(dateHeader, config.systemClockOffset);
        }
    }
}
const AWSSDKSigV4Signer = AwsSdkSigV4Signer;

class AwsSdkSigV4ASigner extends AwsSdkSigV4Signer {
    async sign(httpRequest, identity, signingProperties) {
        if (!protocolHttp.HttpRequest.isInstance(httpRequest)) {
            throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
        }
        const { config, signer, signingRegion, signingRegionSet, signingName } = await validateSigningProperties(signingProperties);
        const configResolvedSigningRegionSet = await config.sigv4aSigningRegionSet?.();
        const multiRegionOverride = (configResolvedSigningRegionSet ??
            signingRegionSet ?? [signingRegion]).join(",");
        const signedRequest = await signer.sign(httpRequest, {
            signingDate: getSkewCorrectedDate(config.systemClockOffset),
            signingRegion: multiRegionOverride,
            signingService: signingName,
        });
        return signedRequest;
    }
}

const getArrayForCommaSeparatedString = (str) => typeof str === "string" && str.length > 0 ? str.split(",").map((item) => item.trim()) : [];

const getBearerTokenEnvKey = (signingName) => `AWS_BEARER_TOKEN_${signingName.replace(/[\s-]/g, "_").toUpperCase()}`;

const NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY = "AWS_AUTH_SCHEME_PREFERENCE";
const NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY = "auth_scheme_preference";
const NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = {
    environmentVariableSelector: (env, options) => {
        if (options?.signingName) {
            const bearerTokenKey = getBearerTokenEnvKey(options.signingName);
            if (bearerTokenKey in env)
                return ["httpBearerAuth"];
        }
        if (!(NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY in env))
            return undefined;
        return getArrayForCommaSeparatedString(env[NODE_AUTH_SCHEME_PREFERENCE_ENV_KEY]);
    },
    configFileSelector: (profile) => {
        if (!(NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY in profile))
            return undefined;
        return getArrayForCommaSeparatedString(profile[NODE_AUTH_SCHEME_PREFERENCE_CONFIG_KEY]);
    },
    default: [],
};

const resolveAwsSdkSigV4AConfig = (config) => {
    config.sigv4aSigningRegionSet = core.normalizeProvider(config.sigv4aSigningRegionSet);
    return config;
};
const NODE_SIGV4A_CONFIG_OPTIONS = {
    environmentVariableSelector(env) {
        if (env.AWS_SIGV4A_SIGNING_REGION_SET) {
            return env.AWS_SIGV4A_SIGNING_REGION_SET.split(",").map((_) => _.trim());
        }
        throw new propertyProvider.ProviderError("AWS_SIGV4A_SIGNING_REGION_SET not set in env.", {
            tryNextLink: true,
        });
    },
    configFileSelector(profile) {
        if (profile.sigv4a_signing_region_set) {
            return (profile.sigv4a_signing_region_set ?? "").split(",").map((_) => _.trim());
        }
        throw new propertyProvider.ProviderError("sigv4a_signing_region_set not set in profile.", {
            tryNextLink: true,
        });
    },
    default: undefined,
};

const resolveAwsSdkSigV4Config = (config) => {
    let inputCredentials = config.credentials;
    let isUserSupplied = !!config.credentials;
    let resolvedCredentials = undefined;
    Object.defineProperty(config, "credentials", {
        set(credentials) {
            if (credentials && credentials !== inputCredentials && credentials !== resolvedCredentials) {
                isUserSupplied = true;
            }
            inputCredentials = credentials;
            const memoizedProvider = normalizeCredentialProvider(config, {
                credentials: inputCredentials,
                credentialDefaultProvider: config.credentialDefaultProvider,
            });
            const boundProvider = bindCallerConfig(config, memoizedProvider);
            if (isUserSupplied && !boundProvider.attributed) {
                const isCredentialObject = typeof inputCredentials === "object" && inputCredentials !== null;
                resolvedCredentials = async (options) => {
                    const creds = await boundProvider(options);
                    const attributedCreds = creds;
                    if (isCredentialObject && (!attributedCreds.$source || Object.keys(attributedCreds.$source).length === 0)) {
                        return client.setCredentialFeature(attributedCreds, "CREDENTIALS_CODE", "e");
                    }
                    return attributedCreds;
                };
                resolvedCredentials.memoized = boundProvider.memoized;
                resolvedCredentials.configBound = boundProvider.configBound;
                resolvedCredentials.attributed = true;
            }
            else {
                resolvedCredentials = boundProvider;
            }
        },
        get() {
            return resolvedCredentials;
        },
        enumerable: true,
        configurable: true,
    });
    config.credentials = inputCredentials;
    const { signingEscapePath = true, systemClockOffset = config.systemClockOffset || 0, sha256, } = config;
    let signer;
    if (config.signer) {
        signer = core.normalizeProvider(config.signer);
    }
    else if (config.regionInfoProvider) {
        signer = () => core.normalizeProvider(config.region)()
            .then(async (region) => [
            (await config.regionInfoProvider(region, {
                useFipsEndpoint: await config.useFipsEndpoint(),
                useDualstackEndpoint: await config.useDualstackEndpoint(),
            })) || {},
            region,
        ])
            .then(([regionInfo, region]) => {
            const { signingRegion, signingService } = regionInfo;
            config.signingRegion = config.signingRegion || signingRegion || region;
            config.signingName = config.signingName || signingService || config.serviceId;
            const params = {
                ...config,
                credentials: config.credentials,
                region: config.signingRegion,
                service: config.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
            return new SignerCtor(params);
        });
    }
    else {
        signer = async (authScheme) => {
            authScheme = Object.assign({}, {
                name: "sigv4",
                signingName: config.signingName || config.defaultSigningName,
                signingRegion: await core.normalizeProvider(config.region)(),
                properties: {},
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            config.signingRegion = config.signingRegion || signingRegion;
            config.signingName = config.signingName || signingService || config.serviceId;
            const params = {
                ...config,
                credentials: config.credentials,
                region: config.signingRegion,
                service: config.signingName,
                sha256,
                uriEscapePath: signingEscapePath,
            };
            const SignerCtor = config.signerConstructor || signatureV4.SignatureV4;
            return new SignerCtor(params);
        };
    }
    const resolvedConfig = Object.assign(config, {
        systemClockOffset,
        signingEscapePath,
        signer,
    });
    return resolvedConfig;
};
const resolveAWSSDKSigV4Config = resolveAwsSdkSigV4Config;
function normalizeCredentialProvider(config, { credentials, credentialDefaultProvider, }) {
    let credentialsProvider;
    if (credentials) {
        if (!credentials?.memoized) {
            credentialsProvider = core.memoizeIdentityProvider(credentials, core.isIdentityExpired, core.doesIdentityRequireRefresh);
        }
        else {
            credentialsProvider = credentials;
        }
    }
    else {
        if (credentialDefaultProvider) {
            credentialsProvider = core.normalizeProvider(credentialDefaultProvider(Object.assign({}, config, {
                parentClientConfig: config,
            })));
        }
        else {
            credentialsProvider = async () => {
                throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
            };
        }
    }
    credentialsProvider.memoized = true;
    return credentialsProvider;
}
function bindCallerConfig(config, credentialsProvider) {
    if (credentialsProvider.configBound) {
        return credentialsProvider;
    }
    const fn = async (options) => credentialsProvider({ ...options, callerClientConfig: config });
    fn.memoized = credentialsProvider.memoized;
    fn.configBound = true;
    return fn;
}

class ProtocolLib {
    queryCompat;
    constructor(queryCompat = false) {
        this.queryCompat = queryCompat;
    }
    resolveRestContentType(defaultContentType, inputSchema) {
        const members = inputSchema.getMemberSchemas();
        const httpPayloadMember = Object.values(members).find((m) => {
            return !!m.getMergedTraits().httpPayload;
        });
        if (httpPayloadMember) {
            const mediaType = httpPayloadMember.getMergedTraits().mediaType;
            if (mediaType) {
                return mediaType;
            }
            else if (httpPayloadMember.isStringSchema()) {
                return "text/plain";
            }
            else if (httpPayloadMember.isBlobSchema()) {
                return "application/octet-stream";
            }
            else {
                return defaultContentType;
            }
        }
        else if (!inputSchema.isUnitSchema()) {
            const hasBody = Object.values(members).find((m) => {
                const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m.getMergedTraits();
                const noPrefixHeaders = httpPrefixHeaders === void 0;
                return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && noPrefixHeaders;
            });
            if (hasBody) {
                return defaultContentType;
            }
        }
    }
    async getErrorSchemaOrThrowBaseException(errorIdentifier, defaultNamespace, response, dataObject, metadata, getErrorSchema) {
        let namespace = defaultNamespace;
        let errorName = errorIdentifier;
        if (errorIdentifier.includes("#")) {
            [namespace, errorName] = errorIdentifier.split("#");
        }
        const errorMetadata = {
            $metadata: metadata,
            $fault: response.statusCode < 500 ? "client" : "server",
        };
        const registry = schema.TypeRegistry.for(namespace);
        try {
            const errorSchema = getErrorSchema?.(registry, errorName) ?? registry.getSchema(errorIdentifier);
            return { errorSchema, errorMetadata };
        }
        catch (e) {
            dataObject.message = dataObject.message ?? dataObject.Message ?? "UnknownError";
            const synthetic = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
            const baseExceptionSchema = synthetic.getBaseException();
            if (baseExceptionSchema) {
                const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema) ?? Error;
                throw this.decorateServiceException(Object.assign(new ErrorCtor({ name: errorName }), errorMetadata), dataObject);
            }
            throw this.decorateServiceException(Object.assign(new Error(errorName), errorMetadata), dataObject);
        }
    }
    decorateServiceException(exception, additions = {}) {
        if (this.queryCompat) {
            const msg = exception.Message ?? additions.Message;
            const error = smithyClient.decorateServiceException(exception, additions);
            if (msg) {
                error.message = msg;
            }
            error.Error = {
                ...error.Error,
                Type: error.Error.Type,
                Code: error.Error.Code,
                Message: error.Error.message ?? error.Error.Message ?? msg,
            };
            const reqId = error.$metadata.requestId;
            if (reqId) {
                error.RequestId = reqId;
            }
            return error;
        }
        return smithyClient.decorateServiceException(exception, additions);
    }
    setQueryCompatError(output, response) {
        const queryErrorHeader = response.headers?.["x-amzn-query-error"];
        if (output !== undefined && queryErrorHeader != null) {
            const [Code, Type] = queryErrorHeader.split(";");
            const entries = Object.entries(output);
            const Error = {
                Code,
                Type,
            };
            Object.assign(output, Error);
            for (const [k, v] of entries) {
                Error[k === "message" ? "Message" : k] = v;
            }
            delete Error.__type;
            output.Error = Error;
        }
    }
    queryCompatOutput(queryCompatErrorData, errorData) {
        if (queryCompatErrorData.Error) {
            errorData.Error = queryCompatErrorData.Error;
        }
        if (queryCompatErrorData.Type) {
            errorData.Type = queryCompatErrorData.Type;
        }
        if (queryCompatErrorData.Code) {
            errorData.Code = queryCompatErrorData.Code;
        }
    }
    findQueryCompatibleError(registry, errorName) {
        try {
            return registry.getSchema(errorName);
        }
        catch (e) {
            return registry.find((schema$1) => schema.NormalizedSchema.of(schema$1).getMergedTraits().awsQueryError?.[0] === errorName);
        }
    }
}

class AwsSmithyRpcV2CborProtocol extends cbor.SmithyRpcV2CborProtocol {
    awsQueryCompatible;
    mixin;
    constructor({ defaultNamespace, awsQueryCompatible, }) {
        super({ defaultNamespace });
        this.awsQueryCompatible = !!awsQueryCompatible;
        this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        if (this.awsQueryCompatible) {
            request.headers["x-amzn-query-mode"] = "true";
        }
        return request;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        if (this.awsQueryCompatible) {
            this.mixin.setQueryCompatError(dataObject, response);
        }
        const errorName = (() => {
            const compatHeader = response.headers["x-amzn-query-error"];
            if (compatHeader && this.awsQueryCompatible) {
                return compatHeader.split(";")[0];
            }
            return cbor.loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
        })();
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorName, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            if (dataObject[name] != null) {
                output[name] = this.deserializer.readValue(member, dataObject[name]);
            }
        }
        if (this.awsQueryCompatible) {
            this.mixin.queryCompatOutput(dataObject, output);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
}

const _toStr = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "number" || typeof val === "bigint") {
        const warning = new Error(`Received number ${val} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val);
    }
    if (typeof val === "boolean") {
        const warning = new Error(`Received boolean ${val} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val);
    }
    return val;
};
const _toBool = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "string") {
        const lowercase = val.toLowerCase();
        if (val !== "" && lowercase !== "false" && lowercase !== "true") {
            const warning = new Error(`Received string "${val}" where a boolean was expected.`);
            warning.name = "Warning";
            console.warn(warning);
        }
        return val !== "" && lowercase !== "false";
    }
    return val;
};
const _toNum = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "string") {
        const num = Number(val);
        if (num.toString() !== val) {
            const warning = new Error(`Received string "${val}" where a number was expected.`);
            warning.name = "Warning";
            console.warn(warning);
            return val;
        }
        return num;
    }
    return val;
};

class SerdeContextConfig {
    serdeContext;
    setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
    }
}

function* serializingStructIterator(ns, sourceObject) {
    if (ns.isUnitSchema()) {
        return;
    }
    const struct = ns.getSchema();
    for (let i = 0; i < struct[4].length; ++i) {
        const key = struct[4][i];
        const memberSchema = struct[5][i];
        const memberNs = new schema.NormalizedSchema([memberSchema, 0], key);
        if (!(key in sourceObject) && !memberNs.isIdempotencyToken()) {
            continue;
        }
        yield [key, memberNs];
    }
}
function* deserializingStructIterator(ns, sourceObject, nameTrait) {
    if (ns.isUnitSchema()) {
        return;
    }
    const struct = ns.getSchema();
    let keysRemaining = Object.keys(sourceObject).filter((k) => k !== "__type").length;
    for (let i = 0; i < struct[4].length; ++i) {
        if (keysRemaining === 0) {
            break;
        }
        const key = struct[4][i];
        const memberSchema = struct[5][i];
        const memberNs = new schema.NormalizedSchema([memberSchema, 0], key);
        let serializationKey = key;
        if (nameTrait) {
            serializationKey = memberNs.getMergedTraits()[nameTrait] ?? key;
        }
        if (!(serializationKey in sourceObject)) {
            continue;
        }
        yield [key, memberNs];
        keysRemaining -= 1;
    }
}

class UnionSerde {
    from;
    to;
    keys;
    constructor(from, to) {
        this.from = from;
        this.to = to;
        this.keys = new Set(Object.keys(this.from).filter((k) => k !== "__type"));
    }
    mark(key) {
        this.keys.delete(key);
    }
    hasUnknown() {
        return this.keys.size === 1 && Object.keys(this.to).length === 0;
    }
    writeUnknown() {
        if (this.hasUnknown()) {
            const k = this.keys.values().next().value;
            const v = this.from[k];
            this.to.$unknown = [k, v];
        }
    }
}

function jsonReviver(key, value, context) {
    if (context?.source) {
        const numericString = context.source;
        if (typeof value === "number") {
            if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER || numericString !== String(value)) {
                const isFractional = numericString.includes(".");
                if (isFractional) {
                    return new serde.NumericValue(numericString, "bigDecimal");
                }
                else {
                    return BigInt(numericString);
                }
            }
        }
    }
    return value;
}

const collectBodyString = (streamBody, context) => smithyClient.collectBody(streamBody, context).then((body) => (context?.utf8Encoder ?? utilUtf8.toUtf8)(body));

const parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        try {
            return JSON.parse(encoded);
        }
        catch (e) {
            if (e?.name === "SyntaxError") {
                Object.defineProperty(e, "$responseBodyText", {
                    value: encoded,
                });
            }
            throw e;
        }
    }
    return {};
});
const parseJsonErrorBody = async (errorBody, context) => {
    const value = await parseJsonBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data && typeof data === "object") {
        const codeKey = findKey(data, "code");
        if (codeKey && data[codeKey] !== undefined) {
            return sanitizeErrorCode(data[codeKey]);
        }
        if (data["__type"] !== undefined) {
            return sanitizeErrorCode(data["__type"]);
        }
    }
};

class JsonShapeDeserializer extends SerdeContextConfig {
    settings;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    async read(schema, data) {
        return this._read(schema, typeof data === "string" ? JSON.parse(data, jsonReviver) : await parseJsonBody(data, this.serdeContext));
    }
    readObject(schema, data) {
        return this._read(schema, data);
    }
    _read(schema$1, value) {
        const isObject = value !== null && typeof value === "object";
        const ns = schema.NormalizedSchema.of(schema$1);
        if (isObject) {
            if (ns.isStructSchema()) {
                const record = value;
                const union = ns.isUnionSchema();
                const out = {};
                let nameMap = void 0;
                const { jsonName } = this.settings;
                if (jsonName) {
                    nameMap = {};
                }
                let unionSerde;
                if (union) {
                    unionSerde = new UnionSerde(record, out);
                }
                for (const [memberName, memberSchema] of deserializingStructIterator(ns, record, jsonName ? "jsonName" : false)) {
                    let fromKey = memberName;
                    if (jsonName) {
                        fromKey = memberSchema.getMergedTraits().jsonName ?? fromKey;
                        nameMap[fromKey] = memberName;
                    }
                    if (union) {
                        unionSerde.mark(fromKey);
                    }
                    if (record[fromKey] != null) {
                        out[memberName] = this._read(memberSchema, record[fromKey]);
                    }
                }
                if (union) {
                    unionSerde.writeUnknown();
                }
                else if (typeof record.__type === "string") {
                    for (const [k, v] of Object.entries(record)) {
                        const t = jsonName ? nameMap[k] ?? k : k;
                        if (!(t in out)) {
                            out[t] = v;
                        }
                    }
                }
                return out;
            }
            if (Array.isArray(value) && ns.isListSchema()) {
                const listMember = ns.getValueSchema();
                const out = [];
                const sparse = !!ns.getMergedTraits().sparse;
                for (const item of value) {
                    if (sparse || item != null) {
                        out.push(this._read(listMember, item));
                    }
                }
                return out;
            }
            if (ns.isMapSchema()) {
                const mapMember = ns.getValueSchema();
                const out = {};
                const sparse = !!ns.getMergedTraits().sparse;
                for (const [_k, _v] of Object.entries(value)) {
                    if (sparse || _v != null) {
                        out[_k] = this._read(mapMember, _v);
                    }
                }
                return out;
            }
        }
        if (ns.isBlobSchema() && typeof value === "string") {
            return utilBase64.fromBase64(value);
        }
        const mediaType = ns.getMergedTraits().mediaType;
        if (ns.isStringSchema() && typeof value === "string" && mediaType) {
            const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
            if (isJson) {
                return serde.LazyJsonString.from(value);
            }
            return value;
        }
        if (ns.isTimestampSchema() && value != null) {
            const format = protocols.determineTimestampFormat(ns, this.settings);
            switch (format) {
                case 5:
                    return serde.parseRfc3339DateTimeWithOffset(value);
                case 6:
                    return serde.parseRfc7231DateTime(value);
                case 7:
                    return serde.parseEpochTimestamp(value);
                default:
                    console.warn("Missing timestamp format, parsing value with Date constructor:", value);
                    return new Date(value);
            }
        }
        if (ns.isBigIntegerSchema() && (typeof value === "number" || typeof value === "string")) {
            return BigInt(value);
        }
        if (ns.isBigDecimalSchema() && value != undefined) {
            if (value instanceof serde.NumericValue) {
                return value;
            }
            const untyped = value;
            if (untyped.type === "bigDecimal" && "string" in untyped) {
                return new serde.NumericValue(untyped.string, untyped.type);
            }
            return new serde.NumericValue(String(value), "bigDecimal");
        }
        if (ns.isNumericSchema() && typeof value === "string") {
            switch (value) {
                case "Infinity":
                    return Infinity;
                case "-Infinity":
                    return -Infinity;
                case "NaN":
                    return NaN;
            }
            return value;
        }
        if (ns.isDocumentSchema()) {
            if (isObject) {
                const out = Array.isArray(value) ? [] : {};
                for (const [k, v] of Object.entries(value)) {
                    if (v instanceof serde.NumericValue) {
                        out[k] = v;
                    }
                    else {
                        out[k] = this._read(ns, v);
                    }
                }
                return out;
            }
            else {
                return structuredClone(value);
            }
        }
        return value;
    }
}

const NUMERIC_CONTROL_CHAR = String.fromCharCode(925);
class JsonReplacer {
    values = new Map();
    counter = 0;
    stage = 0;
    createReplacer() {
        if (this.stage === 1) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer already created.");
        }
        if (this.stage === 2) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        }
        this.stage = 1;
        return (key, value) => {
            if (value instanceof serde.NumericValue) {
                const v = `${NUMERIC_CONTROL_CHAR + "nv" + this.counter++}_` + value.string;
                this.values.set(`"${v}"`, value.string);
                return v;
            }
            if (typeof value === "bigint") {
                const s = value.toString();
                const v = `${NUMERIC_CONTROL_CHAR + "b" + this.counter++}_` + s;
                this.values.set(`"${v}"`, s);
                return v;
            }
            return value;
        };
    }
    replaceInJson(json) {
        if (this.stage === 0) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
        }
        if (this.stage === 2) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        }
        this.stage = 2;
        if (this.counter === 0) {
            return json;
        }
        for (const [key, value] of this.values) {
            json = json.replace(key, value);
        }
        return json;
    }
}

class JsonShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    useReplacer = false;
    rootSchema;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    write(schema$1, value) {
        this.rootSchema = schema.NormalizedSchema.of(schema$1);
        this.buffer = this._write(this.rootSchema, value);
    }
    writeDiscriminatedDocument(schema$1, value) {
        this.write(schema$1, value);
        if (typeof this.buffer === "object") {
            this.buffer.__type = schema.NormalizedSchema.of(schema$1).getName(true);
        }
    }
    flush() {
        const { rootSchema, useReplacer } = this;
        this.rootSchema = undefined;
        this.useReplacer = false;
        if (rootSchema?.isStructSchema() || rootSchema?.isDocumentSchema()) {
            if (!useReplacer) {
                return JSON.stringify(this.buffer);
            }
            const replacer = new JsonReplacer();
            return replacer.replaceInJson(JSON.stringify(this.buffer, replacer.createReplacer(), 0));
        }
        return this.buffer;
    }
    _write(schema$1, value, container) {
        const isObject = value !== null && typeof value === "object";
        const ns = schema.NormalizedSchema.of(schema$1);
        if (isObject) {
            if (ns.isStructSchema()) {
                const record = value;
                const out = {};
                const { jsonName } = this.settings;
                let nameMap = void 0;
                if (jsonName) {
                    nameMap = {};
                }
                for (const [memberName, memberSchema] of serializingStructIterator(ns, record)) {
                    const serializableValue = this._write(memberSchema, record[memberName], ns);
                    if (serializableValue !== undefined) {
                        let targetKey = memberName;
                        if (jsonName) {
                            targetKey = memberSchema.getMergedTraits().jsonName ?? memberName;
                            nameMap[memberName] = targetKey;
                        }
                        out[targetKey] = serializableValue;
                    }
                }
                if (ns.isUnionSchema() && Object.keys(out).length === 0) {
                    const { $unknown } = record;
                    if (Array.isArray($unknown)) {
                        const [k, v] = $unknown;
                        out[k] = this._write(15, v);
                    }
                }
                else if (typeof record.__type === "string") {
                    for (const [k, v] of Object.entries(record)) {
                        const targetKey = jsonName ? nameMap[k] ?? k : k;
                        if (!(targetKey in out)) {
                            out[targetKey] = this._write(15, v);
                        }
                    }
                }
                return out;
            }
            if (Array.isArray(value) && ns.isListSchema()) {
                const listMember = ns.getValueSchema();
                const out = [];
                const sparse = !!ns.getMergedTraits().sparse;
                for (const item of value) {
                    if (sparse || item != null) {
                        out.push(this._write(listMember, item));
                    }
                }
                return out;
            }
            if (ns.isMapSchema()) {
                const mapMember = ns.getValueSchema();
                const out = {};
                const sparse = !!ns.getMergedTraits().sparse;
                for (const [_k, _v] of Object.entries(value)) {
                    if (sparse || _v != null) {
                        out[_k] = this._write(mapMember, _v);
                    }
                }
                return out;
            }
            if (value instanceof Uint8Array && (ns.isBlobSchema() || ns.isDocumentSchema())) {
                if (ns === this.rootSchema) {
                    return value;
                }
                return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
            }
            if (value instanceof Date && (ns.isTimestampSchema() || ns.isDocumentSchema())) {
                const format = protocols.determineTimestampFormat(ns, this.settings);
                switch (format) {
                    case 5:
                        return value.toISOString().replace(".000Z", "Z");
                    case 6:
                        return serde.dateToUtcString(value);
                    case 7:
                        return value.getTime() / 1000;
                    default:
                        console.warn("Missing timestamp format, using epoch seconds", value);
                        return value.getTime() / 1000;
                }
            }
            if (value instanceof serde.NumericValue) {
                this.useReplacer = true;
            }
        }
        if (value === null && container?.isStructSchema()) {
            return void 0;
        }
        if (ns.isStringSchema()) {
            if (typeof value === "undefined" && ns.isIdempotencyToken()) {
                return serde.generateIdempotencyToken();
            }
            const mediaType = ns.getMergedTraits().mediaType;
            if (value != null && mediaType) {
                const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
                if (isJson) {
                    return serde.LazyJsonString.from(value);
                }
            }
            return value;
        }
        if (typeof value === "number" && ns.isNumericSchema()) {
            if (Math.abs(value) === Infinity || isNaN(value)) {
                return String(value);
            }
            return value;
        }
        if (typeof value === "string" && ns.isBlobSchema()) {
            if (ns === this.rootSchema) {
                return value;
            }
            return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
        }
        if (typeof value === "bigint") {
            this.useReplacer = true;
        }
        if (ns.isDocumentSchema()) {
            if (isObject) {
                const out = Array.isArray(value) ? [] : {};
                for (const [k, v] of Object.entries(value)) {
                    if (v instanceof serde.NumericValue) {
                        this.useReplacer = true;
                        out[k] = v;
                    }
                    else {
                        out[k] = this._write(ns, v);
                    }
                }
                return out;
            }
            else {
                return structuredClone(value);
            }
        }
        return value;
    }
}

class JsonCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    createSerializer() {
        const serializer = new JsonShapeSerializer(this.settings);
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
    }
    createDeserializer() {
        const deserializer = new JsonShapeDeserializer(this.settings);
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
    }
}

class AwsJsonRpcProtocol extends protocols.RpcProtocol {
    serializer;
    deserializer;
    serviceTarget;
    codec;
    mixin;
    awsQueryCompatible;
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec, }) {
        super({
            defaultNamespace,
        });
        this.serviceTarget = serviceTarget;
        this.codec =
            jsonCodec ??
                new JsonCodec({
                    timestampFormat: {
                        useTrait: true,
                        default: 7,
                    },
                    jsonName: false,
                });
        this.serializer = this.codec.createSerializer();
        this.deserializer = this.codec.createDeserializer();
        this.awsQueryCompatible = !!awsQueryCompatible;
        this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        if (!request.path.endsWith("/")) {
            request.path += "/";
        }
        Object.assign(request.headers, {
            "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
            "x-amz-target": `${this.serviceTarget}.${operationSchema.name}`,
        });
        if (this.awsQueryCompatible) {
            request.headers["x-amzn-query-mode"] = "true";
        }
        if (schema.deref(operationSchema.input) === "unit" || !request.body) {
            request.body = "{}";
        }
        return request;
    }
    getPayloadCodec() {
        return this.codec;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        if (this.awsQueryCompatible) {
            this.mixin.setQueryCompatError(dataObject, response);
        }
        const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            if (dataObject[name] != null) {
                output[name] = this.codec.createDeserializer().readObject(member, dataObject[name]);
            }
        }
        if (this.awsQueryCompatible) {
            this.mixin.queryCompatOutput(dataObject, output);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
}

class AwsJson1_0Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec, }) {
        super({
            defaultNamespace,
            serviceTarget,
            awsQueryCompatible,
            jsonCodec,
        });
    }
    getShapeId() {
        return "aws.protocols#awsJson1_0";
    }
    getJsonRpcVersion() {
        return "1.0";
    }
    getDefaultContentType() {
        return "application/x-amz-json-1.0";
    }
}

class AwsJson1_1Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec, }) {
        super({
            defaultNamespace,
            serviceTarget,
            awsQueryCompatible,
            jsonCodec,
        });
    }
    getShapeId() {
        return "aws.protocols#awsJson1_1";
    }
    getJsonRpcVersion() {
        return "1.1";
    }
    getDefaultContentType() {
        return "application/x-amz-json-1.1";
    }
}

class AwsRestJsonProtocol extends protocols.HttpBindingProtocol {
    serializer;
    deserializer;
    codec;
    mixin = new ProtocolLib();
    constructor({ defaultNamespace }) {
        super({
            defaultNamespace,
        });
        const settings = {
            timestampFormat: {
                useTrait: true,
                default: 7,
            },
            httpBindings: true,
            jsonName: true,
        };
        this.codec = new JsonCodec(settings);
        this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
        this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getShapeId() {
        return "aws.protocols#restJson1";
    }
    getPayloadCodec() {
        return this.codec;
    }
    setSerdeContext(serdeContext) {
        this.codec.setSerdeContext(serdeContext);
        super.setSerdeContext(serdeContext);
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
        if (!request.headers["content-type"]) {
            const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
            if (contentType) {
                request.headers["content-type"] = contentType;
            }
        }
        if (request.body == null && request.headers["content-type"] === this.getDefaultContentType()) {
            request.body = "{}";
        }
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        const output = await super.deserializeResponse(operationSchema, context, response);
        const outputSchema = schema.NormalizedSchema.of(operationSchema.output);
        for (const [name, member] of outputSchema.structIterator()) {
            if (member.getMemberTraits().httpPayload && !(name in output)) {
                output[name] = null;
            }
        }
        return output;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            const target = member.getMergedTraits().jsonName ?? name;
            output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
    getDefaultContentType() {
        return "application/json";
    }
}

const awsExpectUnion = (value) => {
    if (value == null) {
        return undefined;
    }
    if (typeof value === "object" && "__type" in value) {
        delete value.__type;
    }
    return smithyClient.expectUnion(value);
};

class XmlShapeDeserializer extends SerdeContextConfig {
    settings;
    stringDeserializer;
    constructor(settings) {
        super();
        this.settings = settings;
        this.stringDeserializer = new protocols.FromStringShapeDeserializer(settings);
    }
    setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
        this.stringDeserializer.setSerdeContext(serdeContext);
    }
    read(schema$1, bytes, key) {
        const ns = schema.NormalizedSchema.of(schema$1);
        const memberSchemas = ns.getMemberSchemas();
        const isEventPayload = ns.isStructSchema() &&
            ns.isMemberSchema() &&
            !!Object.values(memberSchemas).find((memberNs) => {
                return !!memberNs.getMemberTraits().eventPayload;
            });
        if (isEventPayload) {
            const output = {};
            const memberName = Object.keys(memberSchemas)[0];
            const eventMemberSchema = memberSchemas[memberName];
            if (eventMemberSchema.isBlobSchema()) {
                output[memberName] = bytes;
            }
            else {
                output[memberName] = this.read(memberSchemas[memberName], bytes);
            }
            return output;
        }
        const xmlString = (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)(bytes);
        const parsedObject = this.parseXml(xmlString);
        return this.readSchema(schema$1, key ? parsedObject[key] : parsedObject);
    }
    readSchema(_schema, value) {
        const ns = schema.NormalizedSchema.of(_schema);
        if (ns.isUnitSchema()) {
            return;
        }
        const traits = ns.getMergedTraits();
        if (ns.isListSchema() && !Array.isArray(value)) {
            return this.readSchema(ns, [value]);
        }
        if (value == null) {
            return value;
        }
        if (typeof value === "object") {
            const sparse = !!traits.sparse;
            const flat = !!traits.xmlFlattened;
            if (ns.isListSchema()) {
                const listValue = ns.getValueSchema();
                const buffer = [];
                const sourceKey = listValue.getMergedTraits().xmlName ?? "member";
                const source = flat ? value : (value[0] ?? value)[sourceKey];
                const sourceArray = Array.isArray(source) ? source : [source];
                for (const v of sourceArray) {
                    if (v != null || sparse) {
                        buffer.push(this.readSchema(listValue, v));
                    }
                }
                return buffer;
            }
            const buffer = {};
            if (ns.isMapSchema()) {
                const keyNs = ns.getKeySchema();
                const memberNs = ns.getValueSchema();
                let entries;
                if (flat) {
                    entries = Array.isArray(value) ? value : [value];
                }
                else {
                    entries = Array.isArray(value.entry) ? value.entry : [value.entry];
                }
                const keyProperty = keyNs.getMergedTraits().xmlName ?? "key";
                const valueProperty = memberNs.getMergedTraits().xmlName ?? "value";
                for (const entry of entries) {
                    const key = entry[keyProperty];
                    const value = entry[valueProperty];
                    if (value != null || sparse) {
                        buffer[key] = this.readSchema(memberNs, value);
                    }
                }
                return buffer;
            }
            if (ns.isStructSchema()) {
                const union = ns.isUnionSchema();
                let unionSerde;
                if (union) {
                    unionSerde = new UnionSerde(value, buffer);
                }
                for (const [memberName, memberSchema] of ns.structIterator()) {
                    const memberTraits = memberSchema.getMergedTraits();
                    const xmlObjectKey = !memberTraits.httpPayload
                        ? memberSchema.getMemberTraits().xmlName ?? memberName
                        : memberTraits.xmlName ?? memberSchema.getName();
                    if (union) {
                        unionSerde.mark(xmlObjectKey);
                    }
                    if (value[xmlObjectKey] != null) {
                        buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);
                    }
                }
                if (union) {
                    unionSerde.writeUnknown();
                }
                return buffer;
            }
            if (ns.isDocumentSchema()) {
                return value;
            }
            throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);
        }
        if (ns.isListSchema()) {
            return [];
        }
        if (ns.isMapSchema() || ns.isStructSchema()) {
            return {};
        }
        return this.stringDeserializer.read(ns, value);
    }
    parseXml(xml) {
        if (xml.length) {
            let parsedObj;
            try {
                parsedObj = xmlBuilder.parseXML(xml);
            }
            catch (e) {
                if (e && typeof e === "object") {
                    Object.defineProperty(e, "$responseBodyText", {
                        value: xml,
                    });
                }
                throw e;
            }
            const textNodeName = "#text";
            const key = Object.keys(parsedObj)[0];
            const parsedObjToReturn = parsedObj[key];
            if (parsedObjToReturn[textNodeName]) {
                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
                delete parsedObjToReturn[textNodeName];
            }
            return smithyClient.getValueFromTextNode(parsedObjToReturn);
        }
        return {};
    }
}

class QueryShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    write(schema$1, value, prefix = "") {
        if (this.buffer === undefined) {
            this.buffer = "";
        }
        const ns = schema.NormalizedSchema.of(schema$1);
        if (prefix && !prefix.endsWith(".")) {
            prefix += ".";
        }
        if (ns.isBlobSchema()) {
            if (typeof value === "string" || value instanceof Uint8Array) {
                this.writeKey(prefix);
                this.writeValue((this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value));
            }
        }
        else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {
            if (value != null) {
                this.writeKey(prefix);
                this.writeValue(String(value));
            }
            else if (ns.isIdempotencyToken()) {
                this.writeKey(prefix);
                this.writeValue(serde.generateIdempotencyToken());
            }
        }
        else if (ns.isBigIntegerSchema()) {
            if (value != null) {
                this.writeKey(prefix);
                this.writeValue(String(value));
            }
        }
        else if (ns.isBigDecimalSchema()) {
            if (value != null) {
                this.writeKey(prefix);
                this.writeValue(value instanceof serde.NumericValue ? value.string : String(value));
            }
        }
        else if (ns.isTimestampSchema()) {
            if (value instanceof Date) {
                this.writeKey(prefix);
                const format = protocols.determineTimestampFormat(ns, this.settings);
                switch (format) {
                    case 5:
                        this.writeValue(value.toISOString().replace(".000Z", "Z"));
                        break;
                    case 6:
                        this.writeValue(smithyClient.dateToUtcString(value));
                        break;
                    case 7:
                        this.writeValue(String(value.getTime() / 1000));
                        break;
                }
            }
        }
        else if (ns.isDocumentSchema()) {
            if (Array.isArray(value)) {
                this.write(64 | 15, value, prefix);
            }
            else if (value instanceof Date) {
                this.write(4, value, prefix);
            }
            else if (value instanceof Uint8Array) {
                this.write(21, value, prefix);
            }
            else if (value && typeof value === "object") {
                this.write(128 | 15, value, prefix);
            }
            else {
                this.writeKey(prefix);
                this.writeValue(String(value));
            }
        }
        else if (ns.isListSchema()) {
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    if (this.settings.serializeEmptyLists) {
                        this.writeKey(prefix);
                        this.writeValue("");
                    }
                }
                else {
                    const member = ns.getValueSchema();
                    const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;
                    let i = 1;
                    for (const item of value) {
                        if (item == null) {
                            continue;
                        }
                        const suffix = this.getKey("member", member.getMergedTraits().xmlName);
                        const key = flat ? `${prefix}${i}` : `${prefix}${suffix}.${i}`;
                        this.write(member, item, key);
                        ++i;
                    }
                }
            }
        }
        else if (ns.isMapSchema()) {
            if (value && typeof value === "object") {
                const keySchema = ns.getKeySchema();
                const memberSchema = ns.getValueSchema();
                const flat = ns.getMergedTraits().xmlFlattened;
                let i = 1;
                for (const [k, v] of Object.entries(value)) {
                    if (v == null) {
                        continue;
                    }
                    const keySuffix = this.getKey("key", keySchema.getMergedTraits().xmlName);
                    const key = flat ? `${prefix}${i}.${keySuffix}` : `${prefix}entry.${i}.${keySuffix}`;
                    const valueSuffix = this.getKey("value", memberSchema.getMergedTraits().xmlName);
                    const valueKey = flat ? `${prefix}${i}.${valueSuffix}` : `${prefix}entry.${i}.${valueSuffix}`;
                    this.write(keySchema, k, key);
                    this.write(memberSchema, v, valueKey);
                    ++i;
                }
            }
        }
        else if (ns.isStructSchema()) {
            if (value && typeof value === "object") {
                let didWriteMember = false;
                for (const [memberName, member] of serializingStructIterator(ns, value)) {
                    if (value[memberName] == null && !member.isIdempotencyToken()) {
                        continue;
                    }
                    const suffix = this.getKey(memberName, member.getMergedTraits().xmlName);
                    const key = `${prefix}${suffix}`;
                    this.write(member, value[memberName], key);
                    didWriteMember = true;
                }
                if (!didWriteMember && ns.isUnionSchema()) {
                    const { $unknown } = value;
                    if (Array.isArray($unknown)) {
                        const [k, v] = $unknown;
                        const key = `${prefix}${k}`;
                        this.write(15, v, key);
                    }
                }
            }
        }
        else if (ns.isUnitSchema()) ;
        else {
            throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);
        }
    }
    flush() {
        if (this.buffer === undefined) {
            throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
        }
        const str = this.buffer;
        delete this.buffer;
        return str;
    }
    getKey(memberName, xmlName) {
        const key = xmlName ?? memberName;
        if (this.settings.capitalizeKeys) {
            return key[0].toUpperCase() + key.slice(1);
        }
        return key;
    }
    writeKey(key) {
        if (key.endsWith(".")) {
            key = key.slice(0, key.length - 1);
        }
        this.buffer += `&${protocols.extendedEncodeURIComponent(key)}=`;
    }
    writeValue(value) {
        this.buffer += protocols.extendedEncodeURIComponent(value);
    }
}

class AwsQueryProtocol extends protocols.RpcProtocol {
    options;
    serializer;
    deserializer;
    mixin = new ProtocolLib();
    constructor(options) {
        super({
            defaultNamespace: options.defaultNamespace,
        });
        this.options = options;
        const settings = {
            timestampFormat: {
                useTrait: true,
                default: 5,
            },
            httpBindings: false,
            xmlNamespace: options.xmlNamespace,
            serviceNamespace: options.defaultNamespace,
            serializeEmptyLists: true,
        };
        this.serializer = new QueryShapeSerializer(settings);
        this.deserializer = new XmlShapeDeserializer(settings);
    }
    getShapeId() {
        return "aws.protocols#awsQuery";
    }
    setSerdeContext(serdeContext) {
        this.serializer.setSerdeContext(serdeContext);
        this.deserializer.setSerdeContext(serdeContext);
    }
    getPayloadCodec() {
        throw new Error("AWSQuery protocol has no payload codec.");
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        if (!request.path.endsWith("/")) {
            request.path += "/";
        }
        Object.assign(request.headers, {
            "content-type": `application/x-www-form-urlencoded`,
        });
        if (schema.deref(operationSchema.input) === "unit" || !request.body) {
            request.body = "";
        }
        const action = operationSchema.name.split("#")[1] ?? operationSchema.name;
        request.body = `Action=${action}&Version=${this.options.version}` + request.body;
        if (request.body.endsWith("&")) {
            request.body = request.body.slice(-1);
        }
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        const deserializer = this.deserializer;
        const ns = schema.NormalizedSchema.of(operationSchema.output);
        const dataObject = {};
        if (response.statusCode >= 300) {
            const bytes = await protocols.collectBody(response.body, context);
            if (bytes.byteLength > 0) {
                Object.assign(dataObject, await deserializer.read(15, bytes));
            }
            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
        }
        for (const header in response.headers) {
            const value = response.headers[header];
            delete response.headers[header];
            response.headers[header.toLowerCase()] = value;
        }
        const shortName = operationSchema.name.split("#")[1] ?? operationSchema.name;
        const awsQueryResultKey = ns.isStructSchema() && this.useNestedResult() ? shortName + "Result" : undefined;
        const bytes = await protocols.collectBody(response.body, context);
        if (bytes.byteLength > 0) {
            Object.assign(dataObject, await deserializer.read(ns, bytes, awsQueryResultKey));
        }
        const output = {
            $metadata: this.deserializeMetadata(response),
            ...dataObject,
        };
        return output;
    }
    useNestedResult() {
        return true;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        const errorIdentifier = this.loadQueryErrorCode(response, dataObject) ?? "Unknown";
        const errorData = this.loadQueryError(dataObject);
        const message = this.loadQueryErrorMessage(dataObject);
        errorData.message = message;
        errorData.Error = {
            Type: errorData.Type,
            Code: errorData.Code,
            Message: message,
        };
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, errorData, metadata, this.mixin.findQueryCompatibleError);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {
            Type: errorData.Error.Type,
            Code: errorData.Error.Code,
            Error: errorData.Error,
        };
        for (const [name, member] of ns.structIterator()) {
            const target = member.getMergedTraits().xmlName ?? name;
            const value = errorData[target] ?? dataObject[target];
            output[name] = this.deserializer.readSchema(member, value);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
    loadQueryErrorCode(output, data) {
        const code = (data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error)?.Code;
        if (code !== undefined) {
            return code;
        }
        if (output.statusCode == 404) {
            return "NotFound";
        }
    }
    loadQueryError(data) {
        return data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error;
    }
    loadQueryErrorMessage(data) {
        const errorData = this.loadQueryError(data);
        return errorData?.message ?? errorData?.Message ?? data.message ?? data.Message ?? "Unknown";
    }
    getDefaultContentType() {
        return "application/x-www-form-urlencoded";
    }
}

class AwsEc2QueryProtocol extends AwsQueryProtocol {
    options;
    constructor(options) {
        super(options);
        this.options = options;
        const ec2Settings = {
            capitalizeKeys: true,
            flattenLists: true,
            serializeEmptyLists: false,
        };
        Object.assign(this.serializer.settings, ec2Settings);
    }
    useNestedResult() {
        return false;
    }
}

const parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        let parsedObj;
        try {
            parsedObj = xmlBuilder.parseXML(encoded);
        }
        catch (e) {
            if (e && typeof e === "object") {
                Object.defineProperty(e, "$responseBodyText", {
                    value: encoded,
                });
            }
            throw e;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return smithyClient.getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data?.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (data?.Code !== undefined) {
        return data.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};

class XmlShapeSerializer extends SerdeContextConfig {
    settings;
    stringBuffer;
    byteBuffer;
    buffer;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    write(schema$1, value) {
        const ns = schema.NormalizedSchema.of(schema$1);
        if (ns.isStringSchema() && typeof value === "string") {
            this.stringBuffer = value;
        }
        else if (ns.isBlobSchema()) {
            this.byteBuffer =
                "byteLength" in value
                    ? value
                    : (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
        }
        else {
            this.buffer = this.writeStruct(ns, value, undefined);
            const traits = ns.getMergedTraits();
            if (traits.httpPayload && !traits.xmlName) {
                this.buffer.withName(ns.getName());
            }
        }
    }
    flush() {
        if (this.byteBuffer !== undefined) {
            const bytes = this.byteBuffer;
            delete this.byteBuffer;
            return bytes;
        }
        if (this.stringBuffer !== undefined) {
            const str = this.stringBuffer;
            delete this.stringBuffer;
            return str;
        }
        const buffer = this.buffer;
        if (this.settings.xmlNamespace) {
            if (!buffer?.attributes?.["xmlns"]) {
                buffer.addAttribute("xmlns", this.settings.xmlNamespace);
            }
        }
        delete this.buffer;
        return buffer.toString();
    }
    writeStruct(ns, value, parentXmlns) {
        const traits = ns.getMergedTraits();
        const name = ns.isMemberSchema() && !traits.httpPayload
            ? ns.getMemberTraits().xmlName ?? ns.getMemberName()
            : traits.xmlName ?? ns.getName();
        if (!name || !ns.isStructSchema()) {
            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);
        }
        const structXmlNode = xmlBuilder.XmlNode.of(name);
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
        for (const [memberName, memberSchema] of serializingStructIterator(ns, value)) {
            const val = value[memberName];
            if (val != null || memberSchema.isIdempotencyToken()) {
                if (memberSchema.getMergedTraits().xmlAttribute) {
                    structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));
                    continue;
                }
                if (memberSchema.isListSchema()) {
                    this.writeList(memberSchema, val, structXmlNode, xmlns);
                }
                else if (memberSchema.isMapSchema()) {
                    this.writeMap(memberSchema, val, structXmlNode, xmlns);
                }
                else if (memberSchema.isStructSchema()) {
                    structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));
                }
                else {
                    const memberNode = xmlBuilder.XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());
                    this.writeSimpleInto(memberSchema, val, memberNode, xmlns);
                    structXmlNode.addChildNode(memberNode);
                }
            }
        }
        const { $unknown } = value;
        if ($unknown && ns.isUnionSchema() && Array.isArray($unknown) && Object.keys(value).length === 1) {
            const [k, v] = $unknown;
            const node = xmlBuilder.XmlNode.of(k);
            if (typeof v !== "string") {
                if (value instanceof xmlBuilder.XmlNode || value instanceof xmlBuilder.XmlText) {
                    structXmlNode.addChildNode(value);
                }
                else {
                    throw new Error(`@aws-sdk - $unknown union member in XML requires ` +
                        `value of type string, @aws-sdk/xml-builder::XmlNode or XmlText.`);
                }
            }
            this.writeSimpleInto(0, v, node, xmlns);
            structXmlNode.addChildNode(node);
        }
        if (xmlns) {
            structXmlNode.addAttribute(xmlnsAttr, xmlns);
        }
        return structXmlNode;
    }
    writeList(listMember, array, container, parentXmlns) {
        if (!listMember.isMemberSchema()) {
            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);
        }
        const listTraits = listMember.getMergedTraits();
        const listValueSchema = listMember.getValueSchema();
        const listValueTraits = listValueSchema.getMergedTraits();
        const sparse = !!listValueTraits.sparse;
        const flat = !!listTraits.xmlFlattened;
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);
        const writeItem = (container, value) => {
            if (listValueSchema.isListSchema()) {
                this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);
            }
            else if (listValueSchema.isMapSchema()) {
                this.writeMap(listValueSchema, value, container, xmlns);
            }
            else if (listValueSchema.isStructSchema()) {
                const struct = this.writeStruct(listValueSchema, value, xmlns);
                container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member"));
            }
            else {
                const listItemNode = xmlBuilder.XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member");
                this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);
                container.addChildNode(listItemNode);
            }
        };
        if (flat) {
            for (const value of array) {
                if (sparse || value != null) {
                    writeItem(container, value);
                }
            }
        }
        else {
            const listNode = xmlBuilder.XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());
            if (xmlns) {
                listNode.addAttribute(xmlnsAttr, xmlns);
            }
            for (const value of array) {
                if (sparse || value != null) {
                    writeItem(listNode, value);
                }
            }
            container.addChildNode(listNode);
        }
    }
    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {
        if (!mapMember.isMemberSchema()) {
            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);
        }
        const mapTraits = mapMember.getMergedTraits();
        const mapKeySchema = mapMember.getKeySchema();
        const mapKeyTraits = mapKeySchema.getMergedTraits();
        const keyTag = mapKeyTraits.xmlName ?? "key";
        const mapValueSchema = mapMember.getValueSchema();
        const mapValueTraits = mapValueSchema.getMergedTraits();
        const valueTag = mapValueTraits.xmlName ?? "value";
        const sparse = !!mapValueTraits.sparse;
        const flat = !!mapTraits.xmlFlattened;
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);
        const addKeyValue = (entry, key, val) => {
            const keyNode = xmlBuilder.XmlNode.of(keyTag, key);
            const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);
            if (keyXmlns) {
                keyNode.addAttribute(keyXmlnsAttr, keyXmlns);
            }
            entry.addChildNode(keyNode);
            let valueNode = xmlBuilder.XmlNode.of(valueTag);
            if (mapValueSchema.isListSchema()) {
                this.writeList(mapValueSchema, val, valueNode, xmlns);
            }
            else if (mapValueSchema.isMapSchema()) {
                this.writeMap(mapValueSchema, val, valueNode, xmlns, true);
            }
            else if (mapValueSchema.isStructSchema()) {
                valueNode = this.writeStruct(mapValueSchema, val, xmlns);
            }
            else {
                this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);
            }
            entry.addChildNode(valueNode);
        };
        if (flat) {
            for (const [key, val] of Object.entries(map)) {
                if (sparse || val != null) {
                    const entry = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
                    addKeyValue(entry, key, val);
                    container.addChildNode(entry);
                }
            }
        }
        else {
            let mapNode;
            if (!containerIsMap) {
                mapNode = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
                if (xmlns) {
                    mapNode.addAttribute(xmlnsAttr, xmlns);
                }
                container.addChildNode(mapNode);
            }
            for (const [key, val] of Object.entries(map)) {
                if (sparse || val != null) {
                    const entry = xmlBuilder.XmlNode.of("entry");
                    addKeyValue(entry, key, val);
                    (containerIsMap ? container : mapNode).addChildNode(entry);
                }
            }
        }
    }
    writeSimple(_schema, value) {
        if (null === value) {
            throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
        }
        const ns = schema.NormalizedSchema.of(_schema);
        let nodeContents = null;
        if (value && typeof value === "object") {
            if (ns.isBlobSchema()) {
                nodeContents = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
            }
            else if (ns.isTimestampSchema() && value instanceof Date) {
                const format = protocols.determineTimestampFormat(ns, this.settings);
                switch (format) {
                    case 5:
                        nodeContents = value.toISOString().replace(".000Z", "Z");
                        break;
                    case 6:
                        nodeContents = smithyClient.dateToUtcString(value);
                        break;
                    case 7:
                        nodeContents = String(value.getTime() / 1000);
                        break;
                    default:
                        console.warn("Missing timestamp format, using http date", value);
                        nodeContents = smithyClient.dateToUtcString(value);
                        break;
                }
            }
            else if (ns.isBigDecimalSchema() && value) {
                if (value instanceof serde.NumericValue) {
                    return value.string;
                }
                return String(value);
            }
            else if (ns.isMapSchema() || ns.isListSchema()) {
                throw new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
            }
            else {
                throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);
            }
        }
        if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {
            nodeContents = String(value);
        }
        if (ns.isStringSchema()) {
            if (value === undefined && ns.isIdempotencyToken()) {
                nodeContents = serde.generateIdempotencyToken();
            }
            else {
                nodeContents = String(value);
            }
        }
        if (nodeContents === null) {
            throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);
        }
        return nodeContents;
    }
    writeSimpleInto(_schema, value, into, parentXmlns) {
        const nodeContents = this.writeSimple(_schema, value);
        const ns = schema.NormalizedSchema.of(_schema);
        const content = new xmlBuilder.XmlText(nodeContents);
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
        if (xmlns) {
            into.addAttribute(xmlnsAttr, xmlns);
        }
        into.addChildNode(content);
    }
    getXmlnsAttribute(ns, parentXmlns) {
        const traits = ns.getMergedTraits();
        const [prefix, xmlns] = traits.xmlNamespace ?? [];
        if (xmlns && xmlns !== parentXmlns) {
            return [prefix ? `xmlns:${prefix}` : "xmlns", xmlns];
        }
        return [void 0, void 0];
    }
}

class XmlCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    createSerializer() {
        const serializer = new XmlShapeSerializer(this.settings);
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
    }
    createDeserializer() {
        const deserializer = new XmlShapeDeserializer(this.settings);
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
    }
}

class AwsRestXmlProtocol extends protocols.HttpBindingProtocol {
    codec;
    serializer;
    deserializer;
    mixin = new ProtocolLib();
    constructor(options) {
        super(options);
        const settings = {
            timestampFormat: {
                useTrait: true,
                default: 5,
            },
            httpBindings: true,
            xmlNamespace: options.xmlNamespace,
            serviceNamespace: options.defaultNamespace,
        };
        this.codec = new XmlCodec(settings);
        this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
        this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getPayloadCodec() {
        return this.codec;
    }
    getShapeId() {
        return "aws.protocols#restXml";
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
        if (!request.headers["content-type"]) {
            const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
            if (contentType) {
                request.headers["content-type"] = contentType;
            }
        }
        if (typeof request.body === "string" &&
            request.headers["content-type"] === this.getDefaultContentType() &&
            !request.body.startsWith("<?xml ") &&
            !this.hasUnstructuredPayloadBinding(inputSchema)) {
            request.body = '<?xml version="1.0" encoding="UTF-8"?>' + request.body;
        }
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        const errorIdentifier = loadRestXmlErrorCode(response, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.Error?.message ?? dataObject.Error?.Message ?? dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            const target = member.getMergedTraits().xmlName ?? name;
            const value = dataObject.Error?.[target] ?? dataObject[target];
            output[name] = this.codec.createDeserializer().readSchema(member, value);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
    getDefaultContentType() {
        return "application/xml";
    }
    hasUnstructuredPayloadBinding(ns) {
        for (const [, member] of ns.structIterator()) {
            if (member.getMergedTraits().httpPayload) {
                return !(member.isStructSchema() || member.isMapSchema() || member.isListSchema());
            }
        }
        return false;
    }
}

exports.AWSSDKSigV4Signer = AWSSDKSigV4Signer;
exports.AwsEc2QueryProtocol = AwsEc2QueryProtocol;
exports.AwsJson1_0Protocol = AwsJson1_0Protocol;
exports.AwsJson1_1Protocol = AwsJson1_1Protocol;
exports.AwsJsonRpcProtocol = AwsJsonRpcProtocol;
exports.AwsQueryProtocol = AwsQueryProtocol;
exports.AwsRestJsonProtocol = AwsRestJsonProtocol;
exports.AwsRestXmlProtocol = AwsRestXmlProtocol;
exports.AwsSdkSigV4ASigner = AwsSdkSigV4ASigner;
exports.AwsSdkSigV4Signer = AwsSdkSigV4Signer;
exports.AwsSmithyRpcV2CborProtocol = AwsSmithyRpcV2CborProtocol;
exports.JsonCodec = JsonCodec;
exports.JsonShapeDeserializer = JsonShapeDeserializer;
exports.JsonShapeSerializer = JsonShapeSerializer;
exports.NODE_AUTH_SCHEME_PREFERENCE_OPTIONS = NODE_AUTH_SCHEME_PREFERENCE_OPTIONS;
exports.NODE_SIGV4A_CONFIG_OPTIONS = NODE_SIGV4A_CONFIG_OPTIONS;
exports.XmlCodec = XmlCodec;
exports.XmlShapeDeserializer = XmlShapeDeserializer;
exports.XmlShapeSerializer = XmlShapeSerializer;
exports._toBool = _toBool;
exports._toNum = _toNum;
exports._toStr = _toStr;
exports.awsExpectUnion = awsExpectUnion;
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
exports.getBearerTokenEnvKey = getBearerTokenEnvKey;
exports.loadRestJsonErrorCode = loadRestJsonErrorCode;
exports.loadRestXmlErrorCode = loadRestXmlErrorCode;
exports.parseJsonBody = parseJsonBody;
exports.parseJsonErrorBody = parseJsonErrorBody;
exports.parseXmlBody = parseXmlBody;
exports.parseXmlErrorBody = parseXmlErrorBody;
exports.resolveAWSSDKSigV4Config = resolveAWSSDKSigV4Config;
exports.resolveAwsSdkSigV4AConfig = resolveAwsSdkSigV4AConfig;
exports.resolveAwsSdkSigV4Config = resolveAwsSdkSigV4Config;
exports.setCredentialFeature = setCredentialFeature;
exports.setFeature = setFeature;
exports.setTokenFeature = setTokenFeature;
exports.state = state;
exports.validateSigningProperties = validateSigningProperties;


/***/ }),

/***/ 2825:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const state = {
    warningEmitted: false,
};
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !state.warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 20) {
        state.warningEmitted = true;
        process.emitWarning(`NodeDeprecationWarning: The AWS SDK for JavaScript (v3) will
no longer support Node.js ${version} in January 2026.

To continue receiving updates to AWS services, bug fixes, and security
updates please upgrade to a supported Node.js LTS version.

More information can be found at: https://a.co/c895JFp`);
    }
};

function setCredentialFeature(credentials, feature, value) {
    if (!credentials.$source) {
        credentials.$source = {};
    }
    credentials.$source[feature] = value;
    return credentials;
}

function setFeature(context, feature, value) {
    if (!context.__aws_sdk_context) {
        context.__aws_sdk_context = {
            features: {},
        };
    }
    else if (!context.__aws_sdk_context.features) {
        context.__aws_sdk_context.features = {};
    }
    context.__aws_sdk_context.features[feature] = value;
}

function setTokenFeature(token, feature, value) {
    if (!token.$source) {
        token.$source = {};
    }
    token.$source[feature] = value;
    return token;
}

exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
exports.setCredentialFeature = setCredentialFeature;
exports.setFeature = setFeature;
exports.setTokenFeature = setTokenFeature;
exports.state = state;


/***/ }),

/***/ 785:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var cbor = __nccwpck_require__(804);
var schema = __nccwpck_require__(9826);
var smithyClient = __nccwpck_require__(3570);
var protocols = __nccwpck_require__(2241);
var serde = __nccwpck_require__(7669);
var utilBase64 = __nccwpck_require__(5600);
var utilUtf8 = __nccwpck_require__(1895);
var xmlBuilder = __nccwpck_require__(2329);

class ProtocolLib {
    queryCompat;
    constructor(queryCompat = false) {
        this.queryCompat = queryCompat;
    }
    resolveRestContentType(defaultContentType, inputSchema) {
        const members = inputSchema.getMemberSchemas();
        const httpPayloadMember = Object.values(members).find((m) => {
            return !!m.getMergedTraits().httpPayload;
        });
        if (httpPayloadMember) {
            const mediaType = httpPayloadMember.getMergedTraits().mediaType;
            if (mediaType) {
                return mediaType;
            }
            else if (httpPayloadMember.isStringSchema()) {
                return "text/plain";
            }
            else if (httpPayloadMember.isBlobSchema()) {
                return "application/octet-stream";
            }
            else {
                return defaultContentType;
            }
        }
        else if (!inputSchema.isUnitSchema()) {
            const hasBody = Object.values(members).find((m) => {
                const { httpQuery, httpQueryParams, httpHeader, httpLabel, httpPrefixHeaders } = m.getMergedTraits();
                const noPrefixHeaders = httpPrefixHeaders === void 0;
                return !httpQuery && !httpQueryParams && !httpHeader && !httpLabel && noPrefixHeaders;
            });
            if (hasBody) {
                return defaultContentType;
            }
        }
    }
    async getErrorSchemaOrThrowBaseException(errorIdentifier, defaultNamespace, response, dataObject, metadata, getErrorSchema) {
        let namespace = defaultNamespace;
        let errorName = errorIdentifier;
        if (errorIdentifier.includes("#")) {
            [namespace, errorName] = errorIdentifier.split("#");
        }
        const errorMetadata = {
            $metadata: metadata,
            $fault: response.statusCode < 500 ? "client" : "server",
        };
        const registry = schema.TypeRegistry.for(namespace);
        try {
            const errorSchema = getErrorSchema?.(registry, errorName) ?? registry.getSchema(errorIdentifier);
            return { errorSchema, errorMetadata };
        }
        catch (e) {
            dataObject.message = dataObject.message ?? dataObject.Message ?? "UnknownError";
            const synthetic = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
            const baseExceptionSchema = synthetic.getBaseException();
            if (baseExceptionSchema) {
                const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema) ?? Error;
                throw this.decorateServiceException(Object.assign(new ErrorCtor({ name: errorName }), errorMetadata), dataObject);
            }
            throw this.decorateServiceException(Object.assign(new Error(errorName), errorMetadata), dataObject);
        }
    }
    decorateServiceException(exception, additions = {}) {
        if (this.queryCompat) {
            const msg = exception.Message ?? additions.Message;
            const error = smithyClient.decorateServiceException(exception, additions);
            if (msg) {
                error.message = msg;
            }
            error.Error = {
                ...error.Error,
                Type: error.Error.Type,
                Code: error.Error.Code,
                Message: error.Error.message ?? error.Error.Message ?? msg,
            };
            const reqId = error.$metadata.requestId;
            if (reqId) {
                error.RequestId = reqId;
            }
            return error;
        }
        return smithyClient.decorateServiceException(exception, additions);
    }
    setQueryCompatError(output, response) {
        const queryErrorHeader = response.headers?.["x-amzn-query-error"];
        if (output !== undefined && queryErrorHeader != null) {
            const [Code, Type] = queryErrorHeader.split(";");
            const entries = Object.entries(output);
            const Error = {
                Code,
                Type,
            };
            Object.assign(output, Error);
            for (const [k, v] of entries) {
                Error[k === "message" ? "Message" : k] = v;
            }
            delete Error.__type;
            output.Error = Error;
        }
    }
    queryCompatOutput(queryCompatErrorData, errorData) {
        if (queryCompatErrorData.Error) {
            errorData.Error = queryCompatErrorData.Error;
        }
        if (queryCompatErrorData.Type) {
            errorData.Type = queryCompatErrorData.Type;
        }
        if (queryCompatErrorData.Code) {
            errorData.Code = queryCompatErrorData.Code;
        }
    }
    findQueryCompatibleError(registry, errorName) {
        try {
            return registry.getSchema(errorName);
        }
        catch (e) {
            return registry.find((schema$1) => schema.NormalizedSchema.of(schema$1).getMergedTraits().awsQueryError?.[0] === errorName);
        }
    }
}

class AwsSmithyRpcV2CborProtocol extends cbor.SmithyRpcV2CborProtocol {
    awsQueryCompatible;
    mixin;
    constructor({ defaultNamespace, awsQueryCompatible, }) {
        super({ defaultNamespace });
        this.awsQueryCompatible = !!awsQueryCompatible;
        this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        if (this.awsQueryCompatible) {
            request.headers["x-amzn-query-mode"] = "true";
        }
        return request;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        if (this.awsQueryCompatible) {
            this.mixin.setQueryCompatError(dataObject, response);
        }
        const errorName = (() => {
            const compatHeader = response.headers["x-amzn-query-error"];
            if (compatHeader && this.awsQueryCompatible) {
                return compatHeader.split(";")[0];
            }
            return cbor.loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
        })();
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorName, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            if (dataObject[name] != null) {
                output[name] = this.deserializer.readValue(member, dataObject[name]);
            }
        }
        if (this.awsQueryCompatible) {
            this.mixin.queryCompatOutput(dataObject, output);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
}

const _toStr = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "number" || typeof val === "bigint") {
        const warning = new Error(`Received number ${val} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val);
    }
    if (typeof val === "boolean") {
        const warning = new Error(`Received boolean ${val} where a string was expected.`);
        warning.name = "Warning";
        console.warn(warning);
        return String(val);
    }
    return val;
};
const _toBool = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "string") {
        const lowercase = val.toLowerCase();
        if (val !== "" && lowercase !== "false" && lowercase !== "true") {
            const warning = new Error(`Received string "${val}" where a boolean was expected.`);
            warning.name = "Warning";
            console.warn(warning);
        }
        return val !== "" && lowercase !== "false";
    }
    return val;
};
const _toNum = (val) => {
    if (val == null) {
        return val;
    }
    if (typeof val === "string") {
        const num = Number(val);
        if (num.toString() !== val) {
            const warning = new Error(`Received string "${val}" where a number was expected.`);
            warning.name = "Warning";
            console.warn(warning);
            return val;
        }
        return num;
    }
    return val;
};

class SerdeContextConfig {
    serdeContext;
    setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
    }
}

function* serializingStructIterator(ns, sourceObject) {
    if (ns.isUnitSchema()) {
        return;
    }
    const struct = ns.getSchema();
    for (let i = 0; i < struct[4].length; ++i) {
        const key = struct[4][i];
        const memberSchema = struct[5][i];
        const memberNs = new schema.NormalizedSchema([memberSchema, 0], key);
        if (!(key in sourceObject) && !memberNs.isIdempotencyToken()) {
            continue;
        }
        yield [key, memberNs];
    }
}
function* deserializingStructIterator(ns, sourceObject, nameTrait) {
    if (ns.isUnitSchema()) {
        return;
    }
    const struct = ns.getSchema();
    let keysRemaining = Object.keys(sourceObject).filter((k) => k !== "__type").length;
    for (let i = 0; i < struct[4].length; ++i) {
        if (keysRemaining === 0) {
            break;
        }
        const key = struct[4][i];
        const memberSchema = struct[5][i];
        const memberNs = new schema.NormalizedSchema([memberSchema, 0], key);
        let serializationKey = key;
        if (nameTrait) {
            serializationKey = memberNs.getMergedTraits()[nameTrait] ?? key;
        }
        if (!(serializationKey in sourceObject)) {
            continue;
        }
        yield [key, memberNs];
        keysRemaining -= 1;
    }
}

class UnionSerde {
    from;
    to;
    keys;
    constructor(from, to) {
        this.from = from;
        this.to = to;
        this.keys = new Set(Object.keys(this.from).filter((k) => k !== "__type"));
    }
    mark(key) {
        this.keys.delete(key);
    }
    hasUnknown() {
        return this.keys.size === 1 && Object.keys(this.to).length === 0;
    }
    writeUnknown() {
        if (this.hasUnknown()) {
            const k = this.keys.values().next().value;
            const v = this.from[k];
            this.to.$unknown = [k, v];
        }
    }
}

function jsonReviver(key, value, context) {
    if (context?.source) {
        const numericString = context.source;
        if (typeof value === "number") {
            if (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER || numericString !== String(value)) {
                const isFractional = numericString.includes(".");
                if (isFractional) {
                    return new serde.NumericValue(numericString, "bigDecimal");
                }
                else {
                    return BigInt(numericString);
                }
            }
        }
    }
    return value;
}

const collectBodyString = (streamBody, context) => smithyClient.collectBody(streamBody, context).then((body) => (context?.utf8Encoder ?? utilUtf8.toUtf8)(body));

const parseJsonBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        try {
            return JSON.parse(encoded);
        }
        catch (e) {
            if (e?.name === "SyntaxError") {
                Object.defineProperty(e, "$responseBodyText", {
                    value: encoded,
                });
            }
            throw e;
        }
    }
    return {};
});
const parseJsonErrorBody = async (errorBody, context) => {
    const value = await parseJsonBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data && typeof data === "object") {
        const codeKey = findKey(data, "code");
        if (codeKey && data[codeKey] !== undefined) {
            return sanitizeErrorCode(data[codeKey]);
        }
        if (data["__type"] !== undefined) {
            return sanitizeErrorCode(data["__type"]);
        }
    }
};

class JsonShapeDeserializer extends SerdeContextConfig {
    settings;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    async read(schema, data) {
        return this._read(schema, typeof data === "string" ? JSON.parse(data, jsonReviver) : await parseJsonBody(data, this.serdeContext));
    }
    readObject(schema, data) {
        return this._read(schema, data);
    }
    _read(schema$1, value) {
        const isObject = value !== null && typeof value === "object";
        const ns = schema.NormalizedSchema.of(schema$1);
        if (isObject) {
            if (ns.isStructSchema()) {
                const record = value;
                const union = ns.isUnionSchema();
                const out = {};
                let nameMap = void 0;
                const { jsonName } = this.settings;
                if (jsonName) {
                    nameMap = {};
                }
                let unionSerde;
                if (union) {
                    unionSerde = new UnionSerde(record, out);
                }
                for (const [memberName, memberSchema] of deserializingStructIterator(ns, record, jsonName ? "jsonName" : false)) {
                    let fromKey = memberName;
                    if (jsonName) {
                        fromKey = memberSchema.getMergedTraits().jsonName ?? fromKey;
                        nameMap[fromKey] = memberName;
                    }
                    if (union) {
                        unionSerde.mark(fromKey);
                    }
                    if (record[fromKey] != null) {
                        out[memberName] = this._read(memberSchema, record[fromKey]);
                    }
                }
                if (union) {
                    unionSerde.writeUnknown();
                }
                else if (typeof record.__type === "string") {
                    for (const [k, v] of Object.entries(record)) {
                        const t = jsonName ? nameMap[k] ?? k : k;
                        if (!(t in out)) {
                            out[t] = v;
                        }
                    }
                }
                return out;
            }
            if (Array.isArray(value) && ns.isListSchema()) {
                const listMember = ns.getValueSchema();
                const out = [];
                const sparse = !!ns.getMergedTraits().sparse;
                for (const item of value) {
                    if (sparse || item != null) {
                        out.push(this._read(listMember, item));
                    }
                }
                return out;
            }
            if (ns.isMapSchema()) {
                const mapMember = ns.getValueSchema();
                const out = {};
                const sparse = !!ns.getMergedTraits().sparse;
                for (const [_k, _v] of Object.entries(value)) {
                    if (sparse || _v != null) {
                        out[_k] = this._read(mapMember, _v);
                    }
                }
                return out;
            }
        }
        if (ns.isBlobSchema() && typeof value === "string") {
            return utilBase64.fromBase64(value);
        }
        const mediaType = ns.getMergedTraits().mediaType;
        if (ns.isStringSchema() && typeof value === "string" && mediaType) {
            const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
            if (isJson) {
                return serde.LazyJsonString.from(value);
            }
            return value;
        }
        if (ns.isTimestampSchema() && value != null) {
            const format = protocols.determineTimestampFormat(ns, this.settings);
            switch (format) {
                case 5:
                    return serde.parseRfc3339DateTimeWithOffset(value);
                case 6:
                    return serde.parseRfc7231DateTime(value);
                case 7:
                    return serde.parseEpochTimestamp(value);
                default:
                    console.warn("Missing timestamp format, parsing value with Date constructor:", value);
                    return new Date(value);
            }
        }
        if (ns.isBigIntegerSchema() && (typeof value === "number" || typeof value === "string")) {
            return BigInt(value);
        }
        if (ns.isBigDecimalSchema() && value != undefined) {
            if (value instanceof serde.NumericValue) {
                return value;
            }
            const untyped = value;
            if (untyped.type === "bigDecimal" && "string" in untyped) {
                return new serde.NumericValue(untyped.string, untyped.type);
            }
            return new serde.NumericValue(String(value), "bigDecimal");
        }
        if (ns.isNumericSchema() && typeof value === "string") {
            switch (value) {
                case "Infinity":
                    return Infinity;
                case "-Infinity":
                    return -Infinity;
                case "NaN":
                    return NaN;
            }
            return value;
        }
        if (ns.isDocumentSchema()) {
            if (isObject) {
                const out = Array.isArray(value) ? [] : {};
                for (const [k, v] of Object.entries(value)) {
                    if (v instanceof serde.NumericValue) {
                        out[k] = v;
                    }
                    else {
                        out[k] = this._read(ns, v);
                    }
                }
                return out;
            }
            else {
                return structuredClone(value);
            }
        }
        return value;
    }
}

const NUMERIC_CONTROL_CHAR = String.fromCharCode(925);
class JsonReplacer {
    values = new Map();
    counter = 0;
    stage = 0;
    createReplacer() {
        if (this.stage === 1) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer already created.");
        }
        if (this.stage === 2) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        }
        this.stage = 1;
        return (key, value) => {
            if (value instanceof serde.NumericValue) {
                const v = `${NUMERIC_CONTROL_CHAR + "nv" + this.counter++}_` + value.string;
                this.values.set(`"${v}"`, value.string);
                return v;
            }
            if (typeof value === "bigint") {
                const s = value.toString();
                const v = `${NUMERIC_CONTROL_CHAR + "b" + this.counter++}_` + s;
                this.values.set(`"${v}"`, s);
                return v;
            }
            return value;
        };
    }
    replaceInJson(json) {
        if (this.stage === 0) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer not created yet.");
        }
        if (this.stage === 2) {
            throw new Error("@aws-sdk/core/protocols - JsonReplacer exhausted.");
        }
        this.stage = 2;
        if (this.counter === 0) {
            return json;
        }
        for (const [key, value] of this.values) {
            json = json.replace(key, value);
        }
        return json;
    }
}

class JsonShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    useReplacer = false;
    rootSchema;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    write(schema$1, value) {
        this.rootSchema = schema.NormalizedSchema.of(schema$1);
        this.buffer = this._write(this.rootSchema, value);
    }
    writeDiscriminatedDocument(schema$1, value) {
        this.write(schema$1, value);
        if (typeof this.buffer === "object") {
            this.buffer.__type = schema.NormalizedSchema.of(schema$1).getName(true);
        }
    }
    flush() {
        const { rootSchema, useReplacer } = this;
        this.rootSchema = undefined;
        this.useReplacer = false;
        if (rootSchema?.isStructSchema() || rootSchema?.isDocumentSchema()) {
            if (!useReplacer) {
                return JSON.stringify(this.buffer);
            }
            const replacer = new JsonReplacer();
            return replacer.replaceInJson(JSON.stringify(this.buffer, replacer.createReplacer(), 0));
        }
        return this.buffer;
    }
    _write(schema$1, value, container) {
        const isObject = value !== null && typeof value === "object";
        const ns = schema.NormalizedSchema.of(schema$1);
        if (isObject) {
            if (ns.isStructSchema()) {
                const record = value;
                const out = {};
                const { jsonName } = this.settings;
                let nameMap = void 0;
                if (jsonName) {
                    nameMap = {};
                }
                for (const [memberName, memberSchema] of serializingStructIterator(ns, record)) {
                    const serializableValue = this._write(memberSchema, record[memberName], ns);
                    if (serializableValue !== undefined) {
                        let targetKey = memberName;
                        if (jsonName) {
                            targetKey = memberSchema.getMergedTraits().jsonName ?? memberName;
                            nameMap[memberName] = targetKey;
                        }
                        out[targetKey] = serializableValue;
                    }
                }
                if (ns.isUnionSchema() && Object.keys(out).length === 0) {
                    const { $unknown } = record;
                    if (Array.isArray($unknown)) {
                        const [k, v] = $unknown;
                        out[k] = this._write(15, v);
                    }
                }
                else if (typeof record.__type === "string") {
                    for (const [k, v] of Object.entries(record)) {
                        const targetKey = jsonName ? nameMap[k] ?? k : k;
                        if (!(targetKey in out)) {
                            out[targetKey] = this._write(15, v);
                        }
                    }
                }
                return out;
            }
            if (Array.isArray(value) && ns.isListSchema()) {
                const listMember = ns.getValueSchema();
                const out = [];
                const sparse = !!ns.getMergedTraits().sparse;
                for (const item of value) {
                    if (sparse || item != null) {
                        out.push(this._write(listMember, item));
                    }
                }
                return out;
            }
            if (ns.isMapSchema()) {
                const mapMember = ns.getValueSchema();
                const out = {};
                const sparse = !!ns.getMergedTraits().sparse;
                for (const [_k, _v] of Object.entries(value)) {
                    if (sparse || _v != null) {
                        out[_k] = this._write(mapMember, _v);
                    }
                }
                return out;
            }
            if (value instanceof Uint8Array && (ns.isBlobSchema() || ns.isDocumentSchema())) {
                if (ns === this.rootSchema) {
                    return value;
                }
                return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
            }
            if (value instanceof Date && (ns.isTimestampSchema() || ns.isDocumentSchema())) {
                const format = protocols.determineTimestampFormat(ns, this.settings);
                switch (format) {
                    case 5:
                        return value.toISOString().replace(".000Z", "Z");
                    case 6:
                        return serde.dateToUtcString(value);
                    case 7:
                        return value.getTime() / 1000;
                    default:
                        console.warn("Missing timestamp format, using epoch seconds", value);
                        return value.getTime() / 1000;
                }
            }
            if (value instanceof serde.NumericValue) {
                this.useReplacer = true;
            }
        }
        if (value === null && container?.isStructSchema()) {
            return void 0;
        }
        if (ns.isStringSchema()) {
            if (typeof value === "undefined" && ns.isIdempotencyToken()) {
                return serde.generateIdempotencyToken();
            }
            const mediaType = ns.getMergedTraits().mediaType;
            if (value != null && mediaType) {
                const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
                if (isJson) {
                    return serde.LazyJsonString.from(value);
                }
            }
            return value;
        }
        if (typeof value === "number" && ns.isNumericSchema()) {
            if (Math.abs(value) === Infinity || isNaN(value)) {
                return String(value);
            }
            return value;
        }
        if (typeof value === "string" && ns.isBlobSchema()) {
            if (ns === this.rootSchema) {
                return value;
            }
            return (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
        }
        if (typeof value === "bigint") {
            this.useReplacer = true;
        }
        if (ns.isDocumentSchema()) {
            if (isObject) {
                const out = Array.isArray(value) ? [] : {};
                for (const [k, v] of Object.entries(value)) {
                    if (v instanceof serde.NumericValue) {
                        this.useReplacer = true;
                        out[k] = v;
                    }
                    else {
                        out[k] = this._write(ns, v);
                    }
                }
                return out;
            }
            else {
                return structuredClone(value);
            }
        }
        return value;
    }
}

class JsonCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    createSerializer() {
        const serializer = new JsonShapeSerializer(this.settings);
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
    }
    createDeserializer() {
        const deserializer = new JsonShapeDeserializer(this.settings);
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
    }
}

class AwsJsonRpcProtocol extends protocols.RpcProtocol {
    serializer;
    deserializer;
    serviceTarget;
    codec;
    mixin;
    awsQueryCompatible;
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec, }) {
        super({
            defaultNamespace,
        });
        this.serviceTarget = serviceTarget;
        this.codec =
            jsonCodec ??
                new JsonCodec({
                    timestampFormat: {
                        useTrait: true,
                        default: 7,
                    },
                    jsonName: false,
                });
        this.serializer = this.codec.createSerializer();
        this.deserializer = this.codec.createDeserializer();
        this.awsQueryCompatible = !!awsQueryCompatible;
        this.mixin = new ProtocolLib(this.awsQueryCompatible);
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        if (!request.path.endsWith("/")) {
            request.path += "/";
        }
        Object.assign(request.headers, {
            "content-type": `application/x-amz-json-${this.getJsonRpcVersion()}`,
            "x-amz-target": `${this.serviceTarget}.${operationSchema.name}`,
        });
        if (this.awsQueryCompatible) {
            request.headers["x-amzn-query-mode"] = "true";
        }
        if (schema.deref(operationSchema.input) === "unit" || !request.body) {
            request.body = "{}";
        }
        return request;
    }
    getPayloadCodec() {
        return this.codec;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        if (this.awsQueryCompatible) {
            this.mixin.setQueryCompatError(dataObject, response);
        }
        const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata, this.awsQueryCompatible ? this.mixin.findQueryCompatibleError : undefined);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            if (dataObject[name] != null) {
                output[name] = this.codec.createDeserializer().readObject(member, dataObject[name]);
            }
        }
        if (this.awsQueryCompatible) {
            this.mixin.queryCompatOutput(dataObject, output);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
}

class AwsJson1_0Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec, }) {
        super({
            defaultNamespace,
            serviceTarget,
            awsQueryCompatible,
            jsonCodec,
        });
    }
    getShapeId() {
        return "aws.protocols#awsJson1_0";
    }
    getJsonRpcVersion() {
        return "1.0";
    }
    getDefaultContentType() {
        return "application/x-amz-json-1.0";
    }
}

class AwsJson1_1Protocol extends AwsJsonRpcProtocol {
    constructor({ defaultNamespace, serviceTarget, awsQueryCompatible, jsonCodec, }) {
        super({
            defaultNamespace,
            serviceTarget,
            awsQueryCompatible,
            jsonCodec,
        });
    }
    getShapeId() {
        return "aws.protocols#awsJson1_1";
    }
    getJsonRpcVersion() {
        return "1.1";
    }
    getDefaultContentType() {
        return "application/x-amz-json-1.1";
    }
}

class AwsRestJsonProtocol extends protocols.HttpBindingProtocol {
    serializer;
    deserializer;
    codec;
    mixin = new ProtocolLib();
    constructor({ defaultNamespace }) {
        super({
            defaultNamespace,
        });
        const settings = {
            timestampFormat: {
                useTrait: true,
                default: 7,
            },
            httpBindings: true,
            jsonName: true,
        };
        this.codec = new JsonCodec(settings);
        this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
        this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getShapeId() {
        return "aws.protocols#restJson1";
    }
    getPayloadCodec() {
        return this.codec;
    }
    setSerdeContext(serdeContext) {
        this.codec.setSerdeContext(serdeContext);
        super.setSerdeContext(serdeContext);
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
        if (!request.headers["content-type"]) {
            const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
            if (contentType) {
                request.headers["content-type"] = contentType;
            }
        }
        if (request.body == null && request.headers["content-type"] === this.getDefaultContentType()) {
            request.body = "{}";
        }
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        const output = await super.deserializeResponse(operationSchema, context, response);
        const outputSchema = schema.NormalizedSchema.of(operationSchema.output);
        for (const [name, member] of outputSchema.structIterator()) {
            if (member.getMemberTraits().httpPayload && !(name in output)) {
                output[name] = null;
            }
        }
        return output;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        const errorIdentifier = loadRestJsonErrorCode(response, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            const target = member.getMergedTraits().jsonName ?? name;
            output[name] = this.codec.createDeserializer().readObject(member, dataObject[target]);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
    getDefaultContentType() {
        return "application/json";
    }
}

const awsExpectUnion = (value) => {
    if (value == null) {
        return undefined;
    }
    if (typeof value === "object" && "__type" in value) {
        delete value.__type;
    }
    return smithyClient.expectUnion(value);
};

class XmlShapeDeserializer extends SerdeContextConfig {
    settings;
    stringDeserializer;
    constructor(settings) {
        super();
        this.settings = settings;
        this.stringDeserializer = new protocols.FromStringShapeDeserializer(settings);
    }
    setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
        this.stringDeserializer.setSerdeContext(serdeContext);
    }
    read(schema$1, bytes, key) {
        const ns = schema.NormalizedSchema.of(schema$1);
        const memberSchemas = ns.getMemberSchemas();
        const isEventPayload = ns.isStructSchema() &&
            ns.isMemberSchema() &&
            !!Object.values(memberSchemas).find((memberNs) => {
                return !!memberNs.getMemberTraits().eventPayload;
            });
        if (isEventPayload) {
            const output = {};
            const memberName = Object.keys(memberSchemas)[0];
            const eventMemberSchema = memberSchemas[memberName];
            if (eventMemberSchema.isBlobSchema()) {
                output[memberName] = bytes;
            }
            else {
                output[memberName] = this.read(memberSchemas[memberName], bytes);
            }
            return output;
        }
        const xmlString = (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)(bytes);
        const parsedObject = this.parseXml(xmlString);
        return this.readSchema(schema$1, key ? parsedObject[key] : parsedObject);
    }
    readSchema(_schema, value) {
        const ns = schema.NormalizedSchema.of(_schema);
        if (ns.isUnitSchema()) {
            return;
        }
        const traits = ns.getMergedTraits();
        if (ns.isListSchema() && !Array.isArray(value)) {
            return this.readSchema(ns, [value]);
        }
        if (value == null) {
            return value;
        }
        if (typeof value === "object") {
            const sparse = !!traits.sparse;
            const flat = !!traits.xmlFlattened;
            if (ns.isListSchema()) {
                const listValue = ns.getValueSchema();
                const buffer = [];
                const sourceKey = listValue.getMergedTraits().xmlName ?? "member";
                const source = flat ? value : (value[0] ?? value)[sourceKey];
                const sourceArray = Array.isArray(source) ? source : [source];
                for (const v of sourceArray) {
                    if (v != null || sparse) {
                        buffer.push(this.readSchema(listValue, v));
                    }
                }
                return buffer;
            }
            const buffer = {};
            if (ns.isMapSchema()) {
                const keyNs = ns.getKeySchema();
                const memberNs = ns.getValueSchema();
                let entries;
                if (flat) {
                    entries = Array.isArray(value) ? value : [value];
                }
                else {
                    entries = Array.isArray(value.entry) ? value.entry : [value.entry];
                }
                const keyProperty = keyNs.getMergedTraits().xmlName ?? "key";
                const valueProperty = memberNs.getMergedTraits().xmlName ?? "value";
                for (const entry of entries) {
                    const key = entry[keyProperty];
                    const value = entry[valueProperty];
                    if (value != null || sparse) {
                        buffer[key] = this.readSchema(memberNs, value);
                    }
                }
                return buffer;
            }
            if (ns.isStructSchema()) {
                const union = ns.isUnionSchema();
                let unionSerde;
                if (union) {
                    unionSerde = new UnionSerde(value, buffer);
                }
                for (const [memberName, memberSchema] of ns.structIterator()) {
                    const memberTraits = memberSchema.getMergedTraits();
                    const xmlObjectKey = !memberTraits.httpPayload
                        ? memberSchema.getMemberTraits().xmlName ?? memberName
                        : memberTraits.xmlName ?? memberSchema.getName();
                    if (union) {
                        unionSerde.mark(xmlObjectKey);
                    }
                    if (value[xmlObjectKey] != null) {
                        buffer[memberName] = this.readSchema(memberSchema, value[xmlObjectKey]);
                    }
                }
                if (union) {
                    unionSerde.writeUnknown();
                }
                return buffer;
            }
            if (ns.isDocumentSchema()) {
                return value;
            }
            throw new Error(`@aws-sdk/core/protocols - xml deserializer unhandled schema type for ${ns.getName(true)}`);
        }
        if (ns.isListSchema()) {
            return [];
        }
        if (ns.isMapSchema() || ns.isStructSchema()) {
            return {};
        }
        return this.stringDeserializer.read(ns, value);
    }
    parseXml(xml) {
        if (xml.length) {
            let parsedObj;
            try {
                parsedObj = xmlBuilder.parseXML(xml);
            }
            catch (e) {
                if (e && typeof e === "object") {
                    Object.defineProperty(e, "$responseBodyText", {
                        value: xml,
                    });
                }
                throw e;
            }
            const textNodeName = "#text";
            const key = Object.keys(parsedObj)[0];
            const parsedObjToReturn = parsedObj[key];
            if (parsedObjToReturn[textNodeName]) {
                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
                delete parsedObjToReturn[textNodeName];
            }
            return smithyClient.getValueFromTextNode(parsedObjToReturn);
        }
        return {};
    }
}

class QueryShapeSerializer extends SerdeContextConfig {
    settings;
    buffer;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    write(schema$1, value, prefix = "") {
        if (this.buffer === undefined) {
            this.buffer = "";
        }
        const ns = schema.NormalizedSchema.of(schema$1);
        if (prefix && !prefix.endsWith(".")) {
            prefix += ".";
        }
        if (ns.isBlobSchema()) {
            if (typeof value === "string" || value instanceof Uint8Array) {
                this.writeKey(prefix);
                this.writeValue((this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value));
            }
        }
        else if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isStringSchema()) {
            if (value != null) {
                this.writeKey(prefix);
                this.writeValue(String(value));
            }
            else if (ns.isIdempotencyToken()) {
                this.writeKey(prefix);
                this.writeValue(serde.generateIdempotencyToken());
            }
        }
        else if (ns.isBigIntegerSchema()) {
            if (value != null) {
                this.writeKey(prefix);
                this.writeValue(String(value));
            }
        }
        else if (ns.isBigDecimalSchema()) {
            if (value != null) {
                this.writeKey(prefix);
                this.writeValue(value instanceof serde.NumericValue ? value.string : String(value));
            }
        }
        else if (ns.isTimestampSchema()) {
            if (value instanceof Date) {
                this.writeKey(prefix);
                const format = protocols.determineTimestampFormat(ns, this.settings);
                switch (format) {
                    case 5:
                        this.writeValue(value.toISOString().replace(".000Z", "Z"));
                        break;
                    case 6:
                        this.writeValue(smithyClient.dateToUtcString(value));
                        break;
                    case 7:
                        this.writeValue(String(value.getTime() / 1000));
                        break;
                }
            }
        }
        else if (ns.isDocumentSchema()) {
            if (Array.isArray(value)) {
                this.write(64 | 15, value, prefix);
            }
            else if (value instanceof Date) {
                this.write(4, value, prefix);
            }
            else if (value instanceof Uint8Array) {
                this.write(21, value, prefix);
            }
            else if (value && typeof value === "object") {
                this.write(128 | 15, value, prefix);
            }
            else {
                this.writeKey(prefix);
                this.writeValue(String(value));
            }
        }
        else if (ns.isListSchema()) {
            if (Array.isArray(value)) {
                if (value.length === 0) {
                    if (this.settings.serializeEmptyLists) {
                        this.writeKey(prefix);
                        this.writeValue("");
                    }
                }
                else {
                    const member = ns.getValueSchema();
                    const flat = this.settings.flattenLists || ns.getMergedTraits().xmlFlattened;
                    let i = 1;
                    for (const item of value) {
                        if (item == null) {
                            continue;
                        }
                        const suffix = this.getKey("member", member.getMergedTraits().xmlName);
                        const key = flat ? `${prefix}${i}` : `${prefix}${suffix}.${i}`;
                        this.write(member, item, key);
                        ++i;
                    }
                }
            }
        }
        else if (ns.isMapSchema()) {
            if (value && typeof value === "object") {
                const keySchema = ns.getKeySchema();
                const memberSchema = ns.getValueSchema();
                const flat = ns.getMergedTraits().xmlFlattened;
                let i = 1;
                for (const [k, v] of Object.entries(value)) {
                    if (v == null) {
                        continue;
                    }
                    const keySuffix = this.getKey("key", keySchema.getMergedTraits().xmlName);
                    const key = flat ? `${prefix}${i}.${keySuffix}` : `${prefix}entry.${i}.${keySuffix}`;
                    const valueSuffix = this.getKey("value", memberSchema.getMergedTraits().xmlName);
                    const valueKey = flat ? `${prefix}${i}.${valueSuffix}` : `${prefix}entry.${i}.${valueSuffix}`;
                    this.write(keySchema, k, key);
                    this.write(memberSchema, v, valueKey);
                    ++i;
                }
            }
        }
        else if (ns.isStructSchema()) {
            if (value && typeof value === "object") {
                let didWriteMember = false;
                for (const [memberName, member] of serializingStructIterator(ns, value)) {
                    if (value[memberName] == null && !member.isIdempotencyToken()) {
                        continue;
                    }
                    const suffix = this.getKey(memberName, member.getMergedTraits().xmlName);
                    const key = `${prefix}${suffix}`;
                    this.write(member, value[memberName], key);
                    didWriteMember = true;
                }
                if (!didWriteMember && ns.isUnionSchema()) {
                    const { $unknown } = value;
                    if (Array.isArray($unknown)) {
                        const [k, v] = $unknown;
                        const key = `${prefix}${k}`;
                        this.write(15, v, key);
                    }
                }
            }
        }
        else if (ns.isUnitSchema()) ;
        else {
            throw new Error(`@aws-sdk/core/protocols - QuerySerializer unrecognized schema type ${ns.getName(true)}`);
        }
    }
    flush() {
        if (this.buffer === undefined) {
            throw new Error("@aws-sdk/core/protocols - QuerySerializer cannot flush with nothing written to buffer.");
        }
        const str = this.buffer;
        delete this.buffer;
        return str;
    }
    getKey(memberName, xmlName) {
        const key = xmlName ?? memberName;
        if (this.settings.capitalizeKeys) {
            return key[0].toUpperCase() + key.slice(1);
        }
        return key;
    }
    writeKey(key) {
        if (key.endsWith(".")) {
            key = key.slice(0, key.length - 1);
        }
        this.buffer += `&${protocols.extendedEncodeURIComponent(key)}=`;
    }
    writeValue(value) {
        this.buffer += protocols.extendedEncodeURIComponent(value);
    }
}

class AwsQueryProtocol extends protocols.RpcProtocol {
    options;
    serializer;
    deserializer;
    mixin = new ProtocolLib();
    constructor(options) {
        super({
            defaultNamespace: options.defaultNamespace,
        });
        this.options = options;
        const settings = {
            timestampFormat: {
                useTrait: true,
                default: 5,
            },
            httpBindings: false,
            xmlNamespace: options.xmlNamespace,
            serviceNamespace: options.defaultNamespace,
            serializeEmptyLists: true,
        };
        this.serializer = new QueryShapeSerializer(settings);
        this.deserializer = new XmlShapeDeserializer(settings);
    }
    getShapeId() {
        return "aws.protocols#awsQuery";
    }
    setSerdeContext(serdeContext) {
        this.serializer.setSerdeContext(serdeContext);
        this.deserializer.setSerdeContext(serdeContext);
    }
    getPayloadCodec() {
        throw new Error("AWSQuery protocol has no payload codec.");
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        if (!request.path.endsWith("/")) {
            request.path += "/";
        }
        Object.assign(request.headers, {
            "content-type": `application/x-www-form-urlencoded`,
        });
        if (schema.deref(operationSchema.input) === "unit" || !request.body) {
            request.body = "";
        }
        const action = operationSchema.name.split("#")[1] ?? operationSchema.name;
        request.body = `Action=${action}&Version=${this.options.version}` + request.body;
        if (request.body.endsWith("&")) {
            request.body = request.body.slice(-1);
        }
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        const deserializer = this.deserializer;
        const ns = schema.NormalizedSchema.of(operationSchema.output);
        const dataObject = {};
        if (response.statusCode >= 300) {
            const bytes = await protocols.collectBody(response.body, context);
            if (bytes.byteLength > 0) {
                Object.assign(dataObject, await deserializer.read(15, bytes));
            }
            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
        }
        for (const header in response.headers) {
            const value = response.headers[header];
            delete response.headers[header];
            response.headers[header.toLowerCase()] = value;
        }
        const shortName = operationSchema.name.split("#")[1] ?? operationSchema.name;
        const awsQueryResultKey = ns.isStructSchema() && this.useNestedResult() ? shortName + "Result" : undefined;
        const bytes = await protocols.collectBody(response.body, context);
        if (bytes.byteLength > 0) {
            Object.assign(dataObject, await deserializer.read(ns, bytes, awsQueryResultKey));
        }
        const output = {
            $metadata: this.deserializeMetadata(response),
            ...dataObject,
        };
        return output;
    }
    useNestedResult() {
        return true;
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        const errorIdentifier = this.loadQueryErrorCode(response, dataObject) ?? "Unknown";
        const errorData = this.loadQueryError(dataObject);
        const message = this.loadQueryErrorMessage(dataObject);
        errorData.message = message;
        errorData.Error = {
            Type: errorData.Type,
            Code: errorData.Code,
            Message: message,
        };
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, errorData, metadata, this.mixin.findQueryCompatibleError);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        const output = {
            Type: errorData.Error.Type,
            Code: errorData.Error.Code,
            Error: errorData.Error,
        };
        for (const [name, member] of ns.structIterator()) {
            const target = member.getMergedTraits().xmlName ?? name;
            const value = errorData[target] ?? dataObject[target];
            output[name] = this.deserializer.readSchema(member, value);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
    loadQueryErrorCode(output, data) {
        const code = (data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error)?.Code;
        if (code !== undefined) {
            return code;
        }
        if (output.statusCode == 404) {
            return "NotFound";
        }
    }
    loadQueryError(data) {
        return data.Errors?.[0]?.Error ?? data.Errors?.Error ?? data.Error;
    }
    loadQueryErrorMessage(data) {
        const errorData = this.loadQueryError(data);
        return errorData?.message ?? errorData?.Message ?? data.message ?? data.Message ?? "Unknown";
    }
    getDefaultContentType() {
        return "application/x-www-form-urlencoded";
    }
}

class AwsEc2QueryProtocol extends AwsQueryProtocol {
    options;
    constructor(options) {
        super(options);
        this.options = options;
        const ec2Settings = {
            capitalizeKeys: true,
            flattenLists: true,
            serializeEmptyLists: false,
        };
        Object.assign(this.serializer.settings, ec2Settings);
    }
    useNestedResult() {
        return false;
    }
}

const parseXmlBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        let parsedObj;
        try {
            parsedObj = xmlBuilder.parseXML(encoded);
        }
        catch (e) {
            if (e && typeof e === "object") {
                Object.defineProperty(e, "$responseBodyText", {
                    value: encoded,
                });
            }
            throw e;
        }
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return smithyClient.getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseXmlErrorBody = async (errorBody, context) => {
    const value = await parseXmlBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const loadRestXmlErrorCode = (output, data) => {
    if (data?.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (data?.Code !== undefined) {
        return data.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};

class XmlShapeSerializer extends SerdeContextConfig {
    settings;
    stringBuffer;
    byteBuffer;
    buffer;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    write(schema$1, value) {
        const ns = schema.NormalizedSchema.of(schema$1);
        if (ns.isStringSchema() && typeof value === "string") {
            this.stringBuffer = value;
        }
        else if (ns.isBlobSchema()) {
            this.byteBuffer =
                "byteLength" in value
                    ? value
                    : (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
        }
        else {
            this.buffer = this.writeStruct(ns, value, undefined);
            const traits = ns.getMergedTraits();
            if (traits.httpPayload && !traits.xmlName) {
                this.buffer.withName(ns.getName());
            }
        }
    }
    flush() {
        if (this.byteBuffer !== undefined) {
            const bytes = this.byteBuffer;
            delete this.byteBuffer;
            return bytes;
        }
        if (this.stringBuffer !== undefined) {
            const str = this.stringBuffer;
            delete this.stringBuffer;
            return str;
        }
        const buffer = this.buffer;
        if (this.settings.xmlNamespace) {
            if (!buffer?.attributes?.["xmlns"]) {
                buffer.addAttribute("xmlns", this.settings.xmlNamespace);
            }
        }
        delete this.buffer;
        return buffer.toString();
    }
    writeStruct(ns, value, parentXmlns) {
        const traits = ns.getMergedTraits();
        const name = ns.isMemberSchema() && !traits.httpPayload
            ? ns.getMemberTraits().xmlName ?? ns.getMemberName()
            : traits.xmlName ?? ns.getName();
        if (!name || !ns.isStructSchema()) {
            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write struct with empty name or non-struct, schema=${ns.getName(true)}.`);
        }
        const structXmlNode = xmlBuilder.XmlNode.of(name);
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
        for (const [memberName, memberSchema] of serializingStructIterator(ns, value)) {
            const val = value[memberName];
            if (val != null || memberSchema.isIdempotencyToken()) {
                if (memberSchema.getMergedTraits().xmlAttribute) {
                    structXmlNode.addAttribute(memberSchema.getMergedTraits().xmlName ?? memberName, this.writeSimple(memberSchema, val));
                    continue;
                }
                if (memberSchema.isListSchema()) {
                    this.writeList(memberSchema, val, structXmlNode, xmlns);
                }
                else if (memberSchema.isMapSchema()) {
                    this.writeMap(memberSchema, val, structXmlNode, xmlns);
                }
                else if (memberSchema.isStructSchema()) {
                    structXmlNode.addChildNode(this.writeStruct(memberSchema, val, xmlns));
                }
                else {
                    const memberNode = xmlBuilder.XmlNode.of(memberSchema.getMergedTraits().xmlName ?? memberSchema.getMemberName());
                    this.writeSimpleInto(memberSchema, val, memberNode, xmlns);
                    structXmlNode.addChildNode(memberNode);
                }
            }
        }
        const { $unknown } = value;
        if ($unknown && ns.isUnionSchema() && Array.isArray($unknown) && Object.keys(value).length === 1) {
            const [k, v] = $unknown;
            const node = xmlBuilder.XmlNode.of(k);
            if (typeof v !== "string") {
                if (value instanceof xmlBuilder.XmlNode || value instanceof xmlBuilder.XmlText) {
                    structXmlNode.addChildNode(value);
                }
                else {
                    throw new Error(`@aws-sdk - $unknown union member in XML requires ` +
                        `value of type string, @aws-sdk/xml-builder::XmlNode or XmlText.`);
                }
            }
            this.writeSimpleInto(0, v, node, xmlns);
            structXmlNode.addChildNode(node);
        }
        if (xmlns) {
            structXmlNode.addAttribute(xmlnsAttr, xmlns);
        }
        return structXmlNode;
    }
    writeList(listMember, array, container, parentXmlns) {
        if (!listMember.isMemberSchema()) {
            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member list: ${listMember.getName(true)}`);
        }
        const listTraits = listMember.getMergedTraits();
        const listValueSchema = listMember.getValueSchema();
        const listValueTraits = listValueSchema.getMergedTraits();
        const sparse = !!listValueTraits.sparse;
        const flat = !!listTraits.xmlFlattened;
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(listMember, parentXmlns);
        const writeItem = (container, value) => {
            if (listValueSchema.isListSchema()) {
                this.writeList(listValueSchema, Array.isArray(value) ? value : [value], container, xmlns);
            }
            else if (listValueSchema.isMapSchema()) {
                this.writeMap(listValueSchema, value, container, xmlns);
            }
            else if (listValueSchema.isStructSchema()) {
                const struct = this.writeStruct(listValueSchema, value, xmlns);
                container.addChildNode(struct.withName(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member"));
            }
            else {
                const listItemNode = xmlBuilder.XmlNode.of(flat ? listTraits.xmlName ?? listMember.getMemberName() : listValueTraits.xmlName ?? "member");
                this.writeSimpleInto(listValueSchema, value, listItemNode, xmlns);
                container.addChildNode(listItemNode);
            }
        };
        if (flat) {
            for (const value of array) {
                if (sparse || value != null) {
                    writeItem(container, value);
                }
            }
        }
        else {
            const listNode = xmlBuilder.XmlNode.of(listTraits.xmlName ?? listMember.getMemberName());
            if (xmlns) {
                listNode.addAttribute(xmlnsAttr, xmlns);
            }
            for (const value of array) {
                if (sparse || value != null) {
                    writeItem(listNode, value);
                }
            }
            container.addChildNode(listNode);
        }
    }
    writeMap(mapMember, map, container, parentXmlns, containerIsMap = false) {
        if (!mapMember.isMemberSchema()) {
            throw new Error(`@aws-sdk/core/protocols - xml serializer, cannot write non-member map: ${mapMember.getName(true)}`);
        }
        const mapTraits = mapMember.getMergedTraits();
        const mapKeySchema = mapMember.getKeySchema();
        const mapKeyTraits = mapKeySchema.getMergedTraits();
        const keyTag = mapKeyTraits.xmlName ?? "key";
        const mapValueSchema = mapMember.getValueSchema();
        const mapValueTraits = mapValueSchema.getMergedTraits();
        const valueTag = mapValueTraits.xmlName ?? "value";
        const sparse = !!mapValueTraits.sparse;
        const flat = !!mapTraits.xmlFlattened;
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(mapMember, parentXmlns);
        const addKeyValue = (entry, key, val) => {
            const keyNode = xmlBuilder.XmlNode.of(keyTag, key);
            const [keyXmlnsAttr, keyXmlns] = this.getXmlnsAttribute(mapKeySchema, xmlns);
            if (keyXmlns) {
                keyNode.addAttribute(keyXmlnsAttr, keyXmlns);
            }
            entry.addChildNode(keyNode);
            let valueNode = xmlBuilder.XmlNode.of(valueTag);
            if (mapValueSchema.isListSchema()) {
                this.writeList(mapValueSchema, val, valueNode, xmlns);
            }
            else if (mapValueSchema.isMapSchema()) {
                this.writeMap(mapValueSchema, val, valueNode, xmlns, true);
            }
            else if (mapValueSchema.isStructSchema()) {
                valueNode = this.writeStruct(mapValueSchema, val, xmlns);
            }
            else {
                this.writeSimpleInto(mapValueSchema, val, valueNode, xmlns);
            }
            entry.addChildNode(valueNode);
        };
        if (flat) {
            for (const [key, val] of Object.entries(map)) {
                if (sparse || val != null) {
                    const entry = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
                    addKeyValue(entry, key, val);
                    container.addChildNode(entry);
                }
            }
        }
        else {
            let mapNode;
            if (!containerIsMap) {
                mapNode = xmlBuilder.XmlNode.of(mapTraits.xmlName ?? mapMember.getMemberName());
                if (xmlns) {
                    mapNode.addAttribute(xmlnsAttr, xmlns);
                }
                container.addChildNode(mapNode);
            }
            for (const [key, val] of Object.entries(map)) {
                if (sparse || val != null) {
                    const entry = xmlBuilder.XmlNode.of("entry");
                    addKeyValue(entry, key, val);
                    (containerIsMap ? container : mapNode).addChildNode(entry);
                }
            }
        }
    }
    writeSimple(_schema, value) {
        if (null === value) {
            throw new Error("@aws-sdk/core/protocols - (XML serializer) cannot write null value.");
        }
        const ns = schema.NormalizedSchema.of(_schema);
        let nodeContents = null;
        if (value && typeof value === "object") {
            if (ns.isBlobSchema()) {
                nodeContents = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
            }
            else if (ns.isTimestampSchema() && value instanceof Date) {
                const format = protocols.determineTimestampFormat(ns, this.settings);
                switch (format) {
                    case 5:
                        nodeContents = value.toISOString().replace(".000Z", "Z");
                        break;
                    case 6:
                        nodeContents = smithyClient.dateToUtcString(value);
                        break;
                    case 7:
                        nodeContents = String(value.getTime() / 1000);
                        break;
                    default:
                        console.warn("Missing timestamp format, using http date", value);
                        nodeContents = smithyClient.dateToUtcString(value);
                        break;
                }
            }
            else if (ns.isBigDecimalSchema() && value) {
                if (value instanceof serde.NumericValue) {
                    return value.string;
                }
                return String(value);
            }
            else if (ns.isMapSchema() || ns.isListSchema()) {
                throw new Error("@aws-sdk/core/protocols - xml serializer, cannot call _write() on List/Map schema, call writeList or writeMap() instead.");
            }
            else {
                throw new Error(`@aws-sdk/core/protocols - xml serializer, unhandled schema type for object value and schema: ${ns.getName(true)}`);
            }
        }
        if (ns.isBooleanSchema() || ns.isNumericSchema() || ns.isBigIntegerSchema() || ns.isBigDecimalSchema()) {
            nodeContents = String(value);
        }
        if (ns.isStringSchema()) {
            if (value === undefined && ns.isIdempotencyToken()) {
                nodeContents = serde.generateIdempotencyToken();
            }
            else {
                nodeContents = String(value);
            }
        }
        if (nodeContents === null) {
            throw new Error(`Unhandled schema-value pair ${ns.getName(true)}=${value}`);
        }
        return nodeContents;
    }
    writeSimpleInto(_schema, value, into, parentXmlns) {
        const nodeContents = this.writeSimple(_schema, value);
        const ns = schema.NormalizedSchema.of(_schema);
        const content = new xmlBuilder.XmlText(nodeContents);
        const [xmlnsAttr, xmlns] = this.getXmlnsAttribute(ns, parentXmlns);
        if (xmlns) {
            into.addAttribute(xmlnsAttr, xmlns);
        }
        into.addChildNode(content);
    }
    getXmlnsAttribute(ns, parentXmlns) {
        const traits = ns.getMergedTraits();
        const [prefix, xmlns] = traits.xmlNamespace ?? [];
        if (xmlns && xmlns !== parentXmlns) {
            return [prefix ? `xmlns:${prefix}` : "xmlns", xmlns];
        }
        return [void 0, void 0];
    }
}

class XmlCodec extends SerdeContextConfig {
    settings;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    createSerializer() {
        const serializer = new XmlShapeSerializer(this.settings);
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
    }
    createDeserializer() {
        const deserializer = new XmlShapeDeserializer(this.settings);
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
    }
}

class AwsRestXmlProtocol extends protocols.HttpBindingProtocol {
    codec;
    serializer;
    deserializer;
    mixin = new ProtocolLib();
    constructor(options) {
        super(options);
        const settings = {
            timestampFormat: {
                useTrait: true,
                default: 5,
            },
            httpBindings: true,
            xmlNamespace: options.xmlNamespace,
            serviceNamespace: options.defaultNamespace,
        };
        this.codec = new XmlCodec(settings);
        this.serializer = new protocols.HttpInterceptingShapeSerializer(this.codec.createSerializer(), settings);
        this.deserializer = new protocols.HttpInterceptingShapeDeserializer(this.codec.createDeserializer(), settings);
    }
    getPayloadCodec() {
        return this.codec;
    }
    getShapeId() {
        return "aws.protocols#restXml";
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        const inputSchema = schema.NormalizedSchema.of(operationSchema.input);
        if (!request.headers["content-type"]) {
            const contentType = this.mixin.resolveRestContentType(this.getDefaultContentType(), inputSchema);
            if (contentType) {
                request.headers["content-type"] = contentType;
            }
        }
        if (typeof request.body === "string" &&
            request.headers["content-type"] === this.getDefaultContentType() &&
            !request.body.startsWith("<?xml ") &&
            !this.hasUnstructuredPayloadBinding(inputSchema)) {
            request.body = '<?xml version="1.0" encoding="UTF-8"?>' + request.body;
        }
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        const errorIdentifier = loadRestXmlErrorCode(response, dataObject) ?? "Unknown";
        const { errorSchema, errorMetadata } = await this.mixin.getErrorSchemaOrThrowBaseException(errorIdentifier, this.options.defaultNamespace, response, dataObject, metadata);
        const ns = schema.NormalizedSchema.of(errorSchema);
        const message = dataObject.Error?.message ?? dataObject.Error?.Message ?? dataObject.message ?? dataObject.Message ?? "Unknown";
        const ErrorCtor = schema.TypeRegistry.for(errorSchema[1]).getErrorCtor(errorSchema) ?? Error;
        const exception = new ErrorCtor(message);
        await this.deserializeHttpMessage(errorSchema, context, response, dataObject);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            const target = member.getMergedTraits().xmlName ?? name;
            const value = dataObject.Error?.[target] ?? dataObject[target];
            output[name] = this.codec.createDeserializer().readSchema(member, value);
        }
        throw this.mixin.decorateServiceException(Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output), dataObject);
    }
    getDefaultContentType() {
        return "application/xml";
    }
    hasUnstructuredPayloadBinding(ns) {
        for (const [, member] of ns.structIterator()) {
            if (member.getMergedTraits().httpPayload) {
                return !(member.isStructSchema() || member.isMapSchema() || member.isListSchema());
            }
        }
        return false;
    }
}

exports.AwsEc2QueryProtocol = AwsEc2QueryProtocol;
exports.AwsJson1_0Protocol = AwsJson1_0Protocol;
exports.AwsJson1_1Protocol = AwsJson1_1Protocol;
exports.AwsJsonRpcProtocol = AwsJsonRpcProtocol;
exports.AwsQueryProtocol = AwsQueryProtocol;
exports.AwsRestJsonProtocol = AwsRestJsonProtocol;
exports.AwsRestXmlProtocol = AwsRestXmlProtocol;
exports.AwsSmithyRpcV2CborProtocol = AwsSmithyRpcV2CborProtocol;
exports.JsonCodec = JsonCodec;
exports.JsonShapeDeserializer = JsonShapeDeserializer;
exports.JsonShapeSerializer = JsonShapeSerializer;
exports.XmlCodec = XmlCodec;
exports.XmlShapeDeserializer = XmlShapeDeserializer;
exports.XmlShapeSerializer = XmlShapeSerializer;
exports._toBool = _toBool;
exports._toNum = _toNum;
exports._toStr = _toStr;
exports.awsExpectUnion = awsExpectUnion;
exports.loadRestJsonErrorCode = loadRestJsonErrorCode;
exports.loadRestXmlErrorCode = loadRestXmlErrorCode;
exports.parseJsonBody = parseJsonBody;
exports.parseJsonErrorBody = parseJsonErrorBody;
exports.parseXmlBody = parseXmlBody;
exports.parseXmlErrorBody = parseXmlErrorBody;


/***/ }),

/***/ 5972:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var client = __nccwpck_require__(2825);
var propertyProvider = __nccwpck_require__(9721);

const ENV_KEY = "AWS_ACCESS_KEY_ID";
const ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
const ENV_SESSION = "AWS_SESSION_TOKEN";
const ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
const ENV_CREDENTIAL_SCOPE = "AWS_CREDENTIAL_SCOPE";
const ENV_ACCOUNT_ID = "AWS_ACCOUNT_ID";
const fromEnv = (init) => async () => {
    init?.logger?.debug("@aws-sdk/credential-provider-env - fromEnv");
    const accessKeyId = process.env[ENV_KEY];
    const secretAccessKey = process.env[ENV_SECRET];
    const sessionToken = process.env[ENV_SESSION];
    const expiry = process.env[ENV_EXPIRATION];
    const credentialScope = process.env[ENV_CREDENTIAL_SCOPE];
    const accountId = process.env[ENV_ACCOUNT_ID];
    if (accessKeyId && secretAccessKey) {
        const credentials = {
            accessKeyId,
            secretAccessKey,
            ...(sessionToken && { sessionToken }),
            ...(expiry && { expiration: new Date(expiry) }),
            ...(credentialScope && { credentialScope }),
            ...(accountId && { accountId }),
        };
        client.setCredentialFeature(credentials, "CREDENTIALS_ENV_VARS", "g");
        return credentials;
    }
    throw new propertyProvider.CredentialsProviderError("Unable to find environment variable credentials.", { logger: init?.logger });
};

exports.ENV_ACCOUNT_ID = ENV_ACCOUNT_ID;
exports.ENV_CREDENTIAL_SCOPE = ENV_CREDENTIAL_SCOPE;
exports.ENV_EXPIRATION = ENV_EXPIRATION;
exports.ENV_KEY = ENV_KEY;
exports.ENV_SECRET = ENV_SECRET;
exports.ENV_SESSION = ENV_SESSION;
exports.fromEnv = fromEnv;


/***/ }),

/***/ 5531:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var credentialProviderEnv = __nccwpck_require__(5972);
var propertyProvider = __nccwpck_require__(9721);
var sharedIniFileLoader = __nccwpck_require__(3507);

const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const remoteProvider = async (init) => {
    const { ENV_CMDS_FULL_URI, ENV_CMDS_RELATIVE_URI, fromContainerMetadata, fromInstanceMetadata } = await __nccwpck_require__.e(/* import() */ 477).then(__nccwpck_require__.t.bind(__nccwpck_require__, 7477, 19));
    if (process.env[ENV_CMDS_RELATIVE_URI] || process.env[ENV_CMDS_FULL_URI]) {
        init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromHttp/fromContainerMetadata");
        const { fromHttp } = await __nccwpck_require__.e(/* import() */ 290).then(__nccwpck_require__.bind(__nccwpck_require__, 7290));
        return propertyProvider.chain(fromHttp(init), fromContainerMetadata(init));
    }
    if (process.env[ENV_IMDS_DISABLED] && process.env[ENV_IMDS_DISABLED] !== "false") {
        return async () => {
            throw new propertyProvider.CredentialsProviderError("EC2 Instance Metadata Service access disabled", { logger: init.logger });
        };
    }
    init.logger?.debug("@aws-sdk/credential-provider-node - remoteProvider::fromInstanceMetadata");
    return fromInstanceMetadata(init);
};

function memoizeChain(providers, treatAsExpired) {
    const chain = internalCreateChain(providers);
    let activeLock;
    let passiveLock;
    let credentials;
    const provider = async (options) => {
        if (options?.forceRefresh) {
            return await chain(options);
        }
        if (credentials?.expiration) {
            if (credentials?.expiration?.getTime() < Date.now()) {
                credentials = undefined;
            }
        }
        if (activeLock) {
            await activeLock;
        }
        else if (!credentials || treatAsExpired?.(credentials)) {
            if (credentials) {
                if (!passiveLock) {
                    passiveLock = chain(options).then((c) => {
                        credentials = c;
                        passiveLock = undefined;
                    });
                }
            }
            else {
                activeLock = chain(options).then((c) => {
                    credentials = c;
                    activeLock = undefined;
                });
                return provider(options);
            }
        }
        return credentials;
    };
    return provider;
}
const internalCreateChain = (providers) => async (awsIdentityProperties) => {
    let lastProviderError;
    for (const provider of providers) {
        try {
            return await provider(awsIdentityProperties);
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

let multipleCredentialSourceWarningEmitted = false;
const defaultProvider = (init = {}) => memoizeChain([
    async () => {
        const profile = init.profile ?? process.env[sharedIniFileLoader.ENV_PROFILE];
        if (profile) {
            const envStaticCredentialsAreSet = process.env[credentialProviderEnv.ENV_KEY] && process.env[credentialProviderEnv.ENV_SECRET];
            if (envStaticCredentialsAreSet) {
                if (!multipleCredentialSourceWarningEmitted) {
                    const warnFn = init.logger?.warn && init.logger?.constructor?.name !== "NoOpLogger"
                        ? init.logger.warn.bind(init.logger)
                        : console.warn;
                    warnFn(`@aws-sdk/credential-provider-node - defaultProvider::fromEnv WARNING:
    Multiple credential sources detected: 
    Both AWS_PROFILE and the pair AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY static credentials are set.
    This SDK will proceed with the AWS_PROFILE value.
    
    However, a future version may change this behavior to prefer the ENV static credentials.
    Please ensure that your environment only sets either the AWS_PROFILE or the
    AWS_ACCESS_KEY_ID/AWS_SECRET_ACCESS_KEY pair.
`);
                    multipleCredentialSourceWarningEmitted = true;
                }
            }
            throw new propertyProvider.CredentialsProviderError("AWS_PROFILE is set, skipping fromEnv provider.", {
                logger: init.logger,
                tryNextLink: true,
            });
        }
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromEnv");
        return credentialProviderEnv.fromEnv(init)();
    },
    async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromSSO");
        const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoSession } = init;
        if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
            throw new propertyProvider.CredentialsProviderError("Skipping SSO provider in default chain (inputs do not include SSO fields).", { logger: init.logger });
        }
        const { fromSSO } = await __nccwpck_require__.e(/* import() */ 414).then(__nccwpck_require__.t.bind(__nccwpck_require__, 6414, 19));
        return fromSSO(init)(awsIdentityProperties);
    },
    async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromIni");
        const { fromIni } = await __nccwpck_require__.e(/* import() */ 203).then(__nccwpck_require__.t.bind(__nccwpck_require__, 4203, 19));
        return fromIni(init)(awsIdentityProperties);
    },
    async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromProcess");
        const { fromProcess } = await __nccwpck_require__.e(/* import() */ 969).then(__nccwpck_require__.t.bind(__nccwpck_require__, 9969, 19));
        return fromProcess(init)(awsIdentityProperties);
    },
    async (awsIdentityProperties) => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::fromTokenFile");
        const { fromTokenFile } = await __nccwpck_require__.e(/* import() */ 646).then(__nccwpck_require__.t.bind(__nccwpck_require__, 5646, 23));
        return fromTokenFile(init)(awsIdentityProperties);
    },
    async () => {
        init.logger?.debug("@aws-sdk/credential-provider-node - defaultProvider::remoteProvider");
        return (await remoteProvider(init))();
    },
    async () => {
        throw new propertyProvider.CredentialsProviderError("Could not load credentials from any providers", {
            tryNextLink: false,
            logger: init.logger,
        });
    },
], credentialsTreatedAsExpired);
const credentialsWillNeedRefresh = (credentials) => credentials?.expiration !== undefined;
const credentialsTreatedAsExpired = (credentials) => credentials?.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000;

exports.credentialsTreatedAsExpired = credentialsTreatedAsExpired;
exports.credentialsWillNeedRefresh = credentialsWillNeedRefresh;
exports.defaultProvider = defaultProvider;


/***/ }),

/***/ 2545:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var protocolHttp = __nccwpck_require__(4418);

function resolveHostHeaderConfig(input) {
    return input;
}
const hostHeaderMiddleware = (options) => (next) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request))
        return next(args);
    const { request } = args;
    const { handlerProtocol = "" } = options.requestHandler.metadata || {};
    if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
        delete request.headers["host"];
        request.headers[":authority"] = request.hostname + (request.port ? ":" + request.port : "");
    }
    else if (!request.headers["host"]) {
        let host = request.hostname;
        if (request.port != null)
            host += `:${request.port}`;
        request.headers["host"] = host;
    }
    return next(args);
};
const hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: ["HOST"],
    override: true,
};
const getHostHeaderPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
    },
});

exports.getHostHeaderPlugin = getHostHeaderPlugin;
exports.hostHeaderMiddleware = hostHeaderMiddleware;
exports.hostHeaderMiddlewareOptions = hostHeaderMiddlewareOptions;
exports.resolveHostHeaderConfig = resolveHostHeaderConfig;


/***/ }),

/***/ 14:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const loggerMiddleware = () => (next, context) => async (args) => {
    try {
        const response = await next(args);
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog ?? context.outputFilterSensitiveLog;
        const { $metadata, ...outputWithoutMetadata } = response.output;
        logger?.info?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            output: outputFilterSensitiveLog(outputWithoutMetadata),
            metadata: $metadata,
        });
        return response;
    }
    catch (error) {
        const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
        const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
        const inputFilterSensitiveLog = overrideInputFilterSensitiveLog ?? context.inputFilterSensitiveLog;
        logger?.error?.({
            clientName,
            commandName,
            input: inputFilterSensitiveLog(args.input),
            error,
            metadata: error.$metadata,
        });
        throw error;
    }
};
const loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: ["LOGGER"],
    step: "initialize",
    override: true,
};
const getLoggerPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
    },
});

exports.getLoggerPlugin = getLoggerPlugin;
exports.loggerMiddleware = loggerMiddleware;
exports.loggerMiddlewareOptions = loggerMiddlewareOptions;


/***/ }),

/***/ 5525:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var recursionDetectionMiddleware = __nccwpck_require__(7767);

const recursionDetectionMiddlewareOptions = {
    step: "build",
    tags: ["RECURSION_DETECTION"],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low",
};

const getRecursionDetectionPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(recursionDetectionMiddleware.recursionDetectionMiddleware(), recursionDetectionMiddlewareOptions);
    },
});

exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;
Object.keys(recursionDetectionMiddleware).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return recursionDetectionMiddleware[k]; }
    });
});


/***/ }),

/***/ 7767:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.recursionDetectionMiddleware = void 0;
const lambda_invoke_store_1 = __nccwpck_require__(2589);
const protocol_http_1 = __nccwpck_require__(4418);
const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (!protocol_http_1.HttpRequest.isInstance(request)) {
        return next(args);
    }
    const traceIdHeader = Object.keys(request.headers ?? {}).find((h) => h.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ??
        TRACE_ID_HEADER_NAME;
    if (request.headers.hasOwnProperty(traceIdHeader)) {
        return next(args);
    }
    const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
    const traceIdFromEnv = process.env[ENV_TRACE_ID];
    const invokeStore = await lambda_invoke_store_1.InvokeStore.getInstanceAsync();
    const traceIdFromInvokeStore = invokeStore?.getXRayTraceId();
    const traceId = traceIdFromInvokeStore ?? traceIdFromEnv;
    const nonEmptyString = (str) => typeof str === "string" && str.length > 0;
    if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
        request.headers[TRACE_ID_HEADER_NAME] = traceId;
    }
    return next({
        ...args,
        request,
    });
};
exports.recursionDetectionMiddleware = recursionDetectionMiddleware;


/***/ }),

/***/ 4688:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var core = __nccwpck_require__(5829);
var utilEndpoints = __nccwpck_require__(3350);
var protocolHttp = __nccwpck_require__(4418);
var core$1 = __nccwpck_require__(9963);

const DEFAULT_UA_APP_ID = undefined;
function isValidUserAgentAppId(appId) {
    if (appId === undefined) {
        return true;
    }
    return typeof appId === "string" && appId.length <= 50;
}
function resolveUserAgentConfig(input) {
    const normalizedAppIdProvider = core.normalizeProvider(input.userAgentAppId ?? DEFAULT_UA_APP_ID);
    const { customUserAgent } = input;
    return Object.assign(input, {
        customUserAgent: typeof customUserAgent === "string" ? [[customUserAgent]] : customUserAgent,
        userAgentAppId: async () => {
            const appId = await normalizedAppIdProvider();
            if (!isValidUserAgentAppId(appId)) {
                const logger = input.logger?.constructor?.name === "NoOpLogger" || !input.logger ? console : input.logger;
                if (typeof appId !== "string") {
                    logger?.warn("userAgentAppId must be a string or undefined.");
                }
                else if (appId.length > 50) {
                    logger?.warn("The provided userAgentAppId exceeds the maximum length of 50 characters.");
                }
            }
            return appId;
        },
    });
}

const ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
async function checkFeatures(context, config, args) {
    const request = args.request;
    if (request?.headers?.["smithy-protocol"] === "rpc-v2-cbor") {
        core$1.setFeature(context, "PROTOCOL_RPC_V2_CBOR", "M");
    }
    if (typeof config.retryStrategy === "function") {
        const retryStrategy = await config.retryStrategy();
        if (typeof retryStrategy.acquireInitialRetryToken === "function") {
            if (retryStrategy.constructor?.name?.includes("Adaptive")) {
                core$1.setFeature(context, "RETRY_MODE_ADAPTIVE", "F");
            }
            else {
                core$1.setFeature(context, "RETRY_MODE_STANDARD", "E");
            }
        }
        else {
            core$1.setFeature(context, "RETRY_MODE_LEGACY", "D");
        }
    }
    if (typeof config.accountIdEndpointMode === "function") {
        const endpointV2 = context.endpointV2;
        if (String(endpointV2?.url?.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX)) {
            core$1.setFeature(context, "ACCOUNT_ID_ENDPOINT", "O");
        }
        switch (await config.accountIdEndpointMode?.()) {
            case "disabled":
                core$1.setFeature(context, "ACCOUNT_ID_MODE_DISABLED", "Q");
                break;
            case "preferred":
                core$1.setFeature(context, "ACCOUNT_ID_MODE_PREFERRED", "P");
                break;
            case "required":
                core$1.setFeature(context, "ACCOUNT_ID_MODE_REQUIRED", "R");
                break;
        }
    }
    const identity = context.__smithy_context?.selectedHttpAuthScheme?.identity;
    if (identity?.$source) {
        const credentials = identity;
        if (credentials.accountId) {
            core$1.setFeature(context, "RESOLVED_ACCOUNT_ID", "T");
        }
        for (const [key, value] of Object.entries(credentials.$source ?? {})) {
            core$1.setFeature(context, key, value);
        }
    }
}

const USER_AGENT = "user-agent";
const X_AMZ_USER_AGENT = "x-amz-user-agent";
const SPACE = " ";
const UA_NAME_SEPARATOR = "/";
const UA_NAME_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w]/g;
const UA_VALUE_ESCAPE_REGEX = /[^!$%&'*+\-.^_`|~\w#]/g;
const UA_ESCAPE_CHAR = "-";

const BYTE_LIMIT = 1024;
function encodeFeatures(features) {
    let buffer = "";
    for (const key in features) {
        const val = features[key];
        if (buffer.length + val.length + 1 <= BYTE_LIMIT) {
            if (buffer.length) {
                buffer += "," + val;
            }
            else {
                buffer += val;
            }
            continue;
        }
        break;
    }
    return buffer;
}

const userAgentMiddleware = (options) => (next, context) => async (args) => {
    const { request } = args;
    if (!protocolHttp.HttpRequest.isInstance(request)) {
        return next(args);
    }
    const { headers } = request;
    const userAgent = context?.userAgent?.map(escapeUserAgent) || [];
    const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
    await checkFeatures(context, options, args);
    const awsContext = context;
    defaultUserAgent.push(`m/${encodeFeatures(Object.assign({}, context.__smithy_context?.features, awsContext.__aws_sdk_context?.features))}`);
    const customUserAgent = options?.customUserAgent?.map(escapeUserAgent) || [];
    const appId = await options.userAgentAppId();
    if (appId) {
        defaultUserAgent.push(escapeUserAgent([`app`, `${appId}`]));
    }
    const prefix = utilEndpoints.getUserAgentPrefix();
    const sdkUserAgentValue = (prefix ? [prefix] : [])
        .concat([...defaultUserAgent, ...userAgent, ...customUserAgent])
        .join(SPACE);
    const normalUAValue = [
        ...defaultUserAgent.filter((section) => section.startsWith("aws-sdk-")),
        ...customUserAgent,
    ].join(SPACE);
    if (options.runtime !== "browser") {
        if (normalUAValue) {
            headers[X_AMZ_USER_AGENT] = headers[X_AMZ_USER_AGENT]
                ? `${headers[USER_AGENT]} ${normalUAValue}`
                : normalUAValue;
        }
        headers[USER_AGENT] = sdkUserAgentValue;
    }
    else {
        headers[X_AMZ_USER_AGENT] = sdkUserAgentValue;
    }
    return next({
        ...args,
        request,
    });
};
const escapeUserAgent = (userAgentPair) => {
    const name = userAgentPair[0]
        .split(UA_NAME_SEPARATOR)
        .map((part) => part.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR))
        .join(UA_NAME_SEPARATOR);
    const version = userAgentPair[1]?.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
        uaName = uaName.toLowerCase();
    }
    return [prefix, uaName, version]
        .filter((item) => item && item.length > 0)
        .reduce((acc, item, index) => {
        switch (index) {
            case 0:
                return item;
            case 1:
                return `${acc}/${item}`;
            default:
                return `${acc}#${item}`;
        }
    }, "");
};
const getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: ["SET_USER_AGENT", "USER_AGENT"],
    override: true,
};
const getUserAgentPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
    },
});

exports.DEFAULT_UA_APP_ID = DEFAULT_UA_APP_ID;
exports.getUserAgentMiddlewareOptions = getUserAgentMiddlewareOptions;
exports.getUserAgentPlugin = getUserAgentPlugin;
exports.resolveUserAgentConfig = resolveUserAgentConfig;
exports.userAgentMiddleware = userAgentMiddleware;


/***/ }),

/***/ 8156:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var stsRegionDefaultResolver = __nccwpck_require__(3161);
var configResolver = __nccwpck_require__(3098);

const getAwsRegionExtensionConfiguration = (runtimeConfig) => {
    return {
        setRegion(region) {
            runtimeConfig.region = region;
        },
        region() {
            return runtimeConfig.region;
        },
    };
};
const resolveAwsRegionExtensionConfiguration = (awsRegionExtensionConfiguration) => {
    return {
        region: awsRegionExtensionConfiguration.region(),
    };
};

Object.defineProperty(exports, "NODE_REGION_CONFIG_FILE_OPTIONS", ({
    enumerable: true,
    get: function () { return configResolver.NODE_REGION_CONFIG_FILE_OPTIONS; }
}));
Object.defineProperty(exports, "NODE_REGION_CONFIG_OPTIONS", ({
    enumerable: true,
    get: function () { return configResolver.NODE_REGION_CONFIG_OPTIONS; }
}));
Object.defineProperty(exports, "REGION_ENV_NAME", ({
    enumerable: true,
    get: function () { return configResolver.REGION_ENV_NAME; }
}));
Object.defineProperty(exports, "REGION_INI_NAME", ({
    enumerable: true,
    get: function () { return configResolver.REGION_INI_NAME; }
}));
Object.defineProperty(exports, "resolveRegionConfig", ({
    enumerable: true,
    get: function () { return configResolver.resolveRegionConfig; }
}));
exports.getAwsRegionExtensionConfiguration = getAwsRegionExtensionConfiguration;
exports.resolveAwsRegionExtensionConfiguration = resolveAwsRegionExtensionConfiguration;
Object.keys(stsRegionDefaultResolver).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return stsRegionDefaultResolver[k]; }
    });
});


/***/ }),

/***/ 3161:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.warning = void 0;
exports.stsRegionDefaultResolver = stsRegionDefaultResolver;
const config_resolver_1 = __nccwpck_require__(3098);
const node_config_provider_1 = __nccwpck_require__(3461);
function stsRegionDefaultResolver(loaderConfig = {}) {
    return (0, node_config_provider_1.loadConfig)({
        ...config_resolver_1.NODE_REGION_CONFIG_OPTIONS,
        async default() {
            if (!exports.warning.silence) {
                console.warn("@aws-sdk - WARN - default STS region of us-east-1 used. See @aws-sdk/credential-providers README and set a region explicitly.");
            }
            return "us-east-1";
        },
    }, { ...config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS, ...loaderConfig });
}
exports.warning = {
    silence: false,
};


/***/ }),

/***/ 3350:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilEndpoints = __nccwpck_require__(5473);
var urlParser = __nccwpck_require__(4681);

const isVirtualHostableS3Bucket = (value, allowSubDomains = false) => {
    if (allowSubDomains) {
        for (const label of value.split(".")) {
            if (!isVirtualHostableS3Bucket(label)) {
                return false;
            }
        }
        return true;
    }
    if (!utilEndpoints.isValidHostLabel(value)) {
        return false;
    }
    if (value.length < 3 || value.length > 63) {
        return false;
    }
    if (value !== value.toLowerCase()) {
        return false;
    }
    if (utilEndpoints.isIpAddress(value)) {
        return false;
    }
    return true;
};

const ARN_DELIMITER = ":";
const RESOURCE_DELIMITER = "/";
const parseArn = (value) => {
    const segments = value.split(ARN_DELIMITER);
    if (segments.length < 6)
        return null;
    const [arn, partition, service, region, accountId, ...resourcePath] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourcePath.join(ARN_DELIMITER) === "")
        return null;
    const resourceId = resourcePath.map((resource) => resource.split(RESOURCE_DELIMITER)).flat();
    return {
        partition,
        service,
        region,
        accountId,
        resourceId,
    };
};

var partitions = [
	{
		id: "aws",
		outputs: {
			dnsSuffix: "amazonaws.com",
			dualStackDnsSuffix: "api.aws",
			implicitGlobalRegion: "us-east-1",
			name: "aws",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
		regions: {
			"af-south-1": {
				description: "Africa (Cape Town)"
			},
			"ap-east-1": {
				description: "Asia Pacific (Hong Kong)"
			},
			"ap-east-2": {
				description: "Asia Pacific (Taipei)"
			},
			"ap-northeast-1": {
				description: "Asia Pacific (Tokyo)"
			},
			"ap-northeast-2": {
				description: "Asia Pacific (Seoul)"
			},
			"ap-northeast-3": {
				description: "Asia Pacific (Osaka)"
			},
			"ap-south-1": {
				description: "Asia Pacific (Mumbai)"
			},
			"ap-south-2": {
				description: "Asia Pacific (Hyderabad)"
			},
			"ap-southeast-1": {
				description: "Asia Pacific (Singapore)"
			},
			"ap-southeast-2": {
				description: "Asia Pacific (Sydney)"
			},
			"ap-southeast-3": {
				description: "Asia Pacific (Jakarta)"
			},
			"ap-southeast-4": {
				description: "Asia Pacific (Melbourne)"
			},
			"ap-southeast-5": {
				description: "Asia Pacific (Malaysia)"
			},
			"ap-southeast-6": {
				description: "Asia Pacific (New Zealand)"
			},
			"ap-southeast-7": {
				description: "Asia Pacific (Thailand)"
			},
			"aws-global": {
				description: "aws global region"
			},
			"ca-central-1": {
				description: "Canada (Central)"
			},
			"ca-west-1": {
				description: "Canada West (Calgary)"
			},
			"eu-central-1": {
				description: "Europe (Frankfurt)"
			},
			"eu-central-2": {
				description: "Europe (Zurich)"
			},
			"eu-north-1": {
				description: "Europe (Stockholm)"
			},
			"eu-south-1": {
				description: "Europe (Milan)"
			},
			"eu-south-2": {
				description: "Europe (Spain)"
			},
			"eu-west-1": {
				description: "Europe (Ireland)"
			},
			"eu-west-2": {
				description: "Europe (London)"
			},
			"eu-west-3": {
				description: "Europe (Paris)"
			},
			"il-central-1": {
				description: "Israel (Tel Aviv)"
			},
			"me-central-1": {
				description: "Middle East (UAE)"
			},
			"me-south-1": {
				description: "Middle East (Bahrain)"
			},
			"mx-central-1": {
				description: "Mexico (Central)"
			},
			"sa-east-1": {
				description: "South America (Sao Paulo)"
			},
			"us-east-1": {
				description: "US East (N. Virginia)"
			},
			"us-east-2": {
				description: "US East (Ohio)"
			},
			"us-west-1": {
				description: "US West (N. California)"
			},
			"us-west-2": {
				description: "US West (Oregon)"
			}
		}
	},
	{
		id: "aws-cn",
		outputs: {
			dnsSuffix: "amazonaws.com.cn",
			dualStackDnsSuffix: "api.amazonwebservices.com.cn",
			implicitGlobalRegion: "cn-northwest-1",
			name: "aws-cn",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^cn\\-\\w+\\-\\d+$",
		regions: {
			"aws-cn-global": {
				description: "aws-cn global region"
			},
			"cn-north-1": {
				description: "China (Beijing)"
			},
			"cn-northwest-1": {
				description: "China (Ningxia)"
			}
		}
	},
	{
		id: "aws-eusc",
		outputs: {
			dnsSuffix: "amazonaws.eu",
			dualStackDnsSuffix: "api.amazonwebservices.eu",
			implicitGlobalRegion: "eusc-de-east-1",
			name: "aws-eusc",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
		regions: {
			"eusc-de-east-1": {
				description: "AWS European Sovereign Cloud (Germany)"
			}
		}
	},
	{
		id: "aws-iso",
		outputs: {
			dnsSuffix: "c2s.ic.gov",
			dualStackDnsSuffix: "api.aws.ic.gov",
			implicitGlobalRegion: "us-iso-east-1",
			name: "aws-iso",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
		regions: {
			"aws-iso-global": {
				description: "aws-iso global region"
			},
			"us-iso-east-1": {
				description: "US ISO East"
			},
			"us-iso-west-1": {
				description: "US ISO WEST"
			}
		}
	},
	{
		id: "aws-iso-b",
		outputs: {
			dnsSuffix: "sc2s.sgov.gov",
			dualStackDnsSuffix: "api.aws.scloud",
			implicitGlobalRegion: "us-isob-east-1",
			name: "aws-iso-b",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
		regions: {
			"aws-iso-b-global": {
				description: "aws-iso-b global region"
			},
			"us-isob-east-1": {
				description: "US ISOB East (Ohio)"
			},
			"us-isob-west-1": {
				description: "US ISOB West"
			}
		}
	},
	{
		id: "aws-iso-e",
		outputs: {
			dnsSuffix: "cloud.adc-e.uk",
			dualStackDnsSuffix: "api.cloud-aws.adc-e.uk",
			implicitGlobalRegion: "eu-isoe-west-1",
			name: "aws-iso-e",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
		regions: {
			"aws-iso-e-global": {
				description: "aws-iso-e global region"
			},
			"eu-isoe-west-1": {
				description: "EU ISOE West"
			}
		}
	},
	{
		id: "aws-iso-f",
		outputs: {
			dnsSuffix: "csp.hci.ic.gov",
			dualStackDnsSuffix: "api.aws.hci.ic.gov",
			implicitGlobalRegion: "us-isof-south-1",
			name: "aws-iso-f",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
		regions: {
			"aws-iso-f-global": {
				description: "aws-iso-f global region"
			},
			"us-isof-east-1": {
				description: "US ISOF EAST"
			},
			"us-isof-south-1": {
				description: "US ISOF SOUTH"
			}
		}
	},
	{
		id: "aws-us-gov",
		outputs: {
			dnsSuffix: "amazonaws.com",
			dualStackDnsSuffix: "api.aws",
			implicitGlobalRegion: "us-gov-west-1",
			name: "aws-us-gov",
			supportsDualStack: true,
			supportsFIPS: true
		},
		regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
		regions: {
			"aws-us-gov-global": {
				description: "aws-us-gov global region"
			},
			"us-gov-east-1": {
				description: "AWS GovCloud (US-East)"
			},
			"us-gov-west-1": {
				description: "AWS GovCloud (US-West)"
			}
		}
	}
];
var version = "1.1";
var partitionsInfo = {
	partitions: partitions,
	version: version
};

let selectedPartitionsInfo = partitionsInfo;
let selectedUserAgentPrefix = "";
const partition = (value) => {
    const { partitions } = selectedPartitionsInfo;
    for (const partition of partitions) {
        const { regions, outputs } = partition;
        for (const [region, regionData] of Object.entries(regions)) {
            if (region === value) {
                return {
                    ...outputs,
                    ...regionData,
                };
            }
        }
    }
    for (const partition of partitions) {
        const { regionRegex, outputs } = partition;
        if (new RegExp(regionRegex).test(value)) {
            return {
                ...outputs,
            };
        }
    }
    const DEFAULT_PARTITION = partitions.find((partition) => partition.id === "aws");
    if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex," +
            " and default partition with id 'aws' doesn't exist.");
    }
    return {
        ...DEFAULT_PARTITION.outputs,
    };
};
const setPartitionInfo = (partitionsInfo, userAgentPrefix = "") => {
    selectedPartitionsInfo = partitionsInfo;
    selectedUserAgentPrefix = userAgentPrefix;
};
const useDefaultPartitionInfo = () => {
    setPartitionInfo(partitionsInfo, "");
};
const getUserAgentPrefix = () => selectedUserAgentPrefix;

const awsEndpointFunctions = {
    isVirtualHostableS3Bucket: isVirtualHostableS3Bucket,
    parseArn: parseArn,
    partition: partition,
};
utilEndpoints.customEndpointFunctions.aws = awsEndpointFunctions;

const resolveDefaultAwsRegionalEndpointsConfig = (input) => {
    if (typeof input.endpointProvider !== "function") {
        throw new Error("@aws-sdk/util-endpoint - endpointProvider and endpoint missing in config for this client.");
    }
    const { endpoint } = input;
    if (endpoint === undefined) {
        input.endpoint = async () => {
            return toEndpointV1(input.endpointProvider({
                Region: typeof input.region === "function" ? await input.region() : input.region,
                UseDualStack: typeof input.useDualstackEndpoint === "function"
                    ? await input.useDualstackEndpoint()
                    : input.useDualstackEndpoint,
                UseFIPS: typeof input.useFipsEndpoint === "function" ? await input.useFipsEndpoint() : input.useFipsEndpoint,
                Endpoint: undefined,
            }, { logger: input.logger }));
        };
    }
    return input;
};
const toEndpointV1 = (endpoint) => urlParser.parseUrl(endpoint.url);

Object.defineProperty(exports, "EndpointError", ({
    enumerable: true,
    get: function () { return utilEndpoints.EndpointError; }
}));
Object.defineProperty(exports, "isIpAddress", ({
    enumerable: true,
    get: function () { return utilEndpoints.isIpAddress; }
}));
Object.defineProperty(exports, "resolveEndpoint", ({
    enumerable: true,
    get: function () { return utilEndpoints.resolveEndpoint; }
}));
exports.awsEndpointFunctions = awsEndpointFunctions;
exports.getUserAgentPrefix = getUserAgentPrefix;
exports.partition = partition;
exports.resolveDefaultAwsRegionalEndpointsConfig = resolveDefaultAwsRegionalEndpointsConfig;
exports.setPartitionInfo = setPartitionInfo;
exports.toEndpointV1 = toEndpointV1;
exports.useDefaultPartitionInfo = useDefaultPartitionInfo;


/***/ }),

/***/ 8095:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var os = __nccwpck_require__(2037);
var process = __nccwpck_require__(7282);
var middlewareUserAgent = __nccwpck_require__(4688);

const crtAvailability = {
    isCrtAvailable: false,
};

const isCrtAvailable = () => {
    if (crtAvailability.isCrtAvailable) {
        return ["md/crt-avail"];
    }
    return null;
};

const createDefaultUserAgentProvider = ({ serviceId, clientVersion }) => {
    return async (config) => {
        const sections = [
            ["aws-sdk-js", clientVersion],
            ["ua", "2.1"],
            [`os/${os.platform()}`, os.release()],
            ["lang/js"],
            ["md/nodejs", `${process.versions.node}`],
        ];
        const crtAvailable = isCrtAvailable();
        if (crtAvailable) {
            sections.push(crtAvailable);
        }
        if (serviceId) {
            sections.push([`api/${serviceId}`, clientVersion]);
        }
        if (process.env.AWS_EXECUTION_ENV) {
            sections.push([`exec-env/${process.env.AWS_EXECUTION_ENV}`]);
        }
        const appId = await config?.userAgentAppId?.();
        const resolvedUserAgent = appId ? [...sections, [`app/${appId}`]] : [...sections];
        return resolvedUserAgent;
    };
};
const defaultUserAgent = createDefaultUserAgentProvider;

const UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
const UA_APP_ID_INI_NAME = "sdk_ua_app_id";
const UA_APP_ID_INI_NAME_DEPRECATED = "sdk-ua-app-id";
const NODE_APP_ID_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[UA_APP_ID_ENV_NAME],
    configFileSelector: (profile) => profile[UA_APP_ID_INI_NAME] ?? profile[UA_APP_ID_INI_NAME_DEPRECATED],
    default: middlewareUserAgent.DEFAULT_UA_APP_ID,
};

exports.NODE_APP_ID_CONFIG_OPTIONS = NODE_APP_ID_CONFIG_OPTIONS;
exports.UA_APP_ID_ENV_NAME = UA_APP_ID_ENV_NAME;
exports.UA_APP_ID_INI_NAME = UA_APP_ID_INI_NAME;
exports.createDefaultUserAgentProvider = createDefaultUserAgentProvider;
exports.crtAvailability = crtAvailability;
exports.defaultUserAgent = defaultUserAgent;


/***/ }),

/***/ 2329:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var xmlParser = __nccwpck_require__(5015);

function escapeAttribute(value) {
    return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}

function escapeElement(value) {
    return value
        .replace(/&/g, "&amp;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\r/g, "&#x0D;")
        .replace(/\n/g, "&#x0A;")
        .replace(/\u0085/g, "&#x85;")
        .replace(/\u2028/, "&#x2028;");
}

class XmlText {
    value;
    constructor(value) {
        this.value = value;
    }
    toString() {
        return escapeElement("" + this.value);
    }
}

class XmlNode {
    name;
    children;
    attributes = {};
    static of(name, childText, withName) {
        const node = new XmlNode(name);
        if (childText !== undefined) {
            node.addChildNode(new XmlText(childText));
        }
        if (withName !== undefined) {
            node.withName(withName);
        }
        return node;
    }
    constructor(name, children = []) {
        this.name = name;
        this.children = children;
    }
    withName(name) {
        this.name = name;
        return this;
    }
    addAttribute(name, value) {
        this.attributes[name] = value;
        return this;
    }
    addChildNode(child) {
        this.children.push(child);
        return this;
    }
    removeAttribute(name) {
        delete this.attributes[name];
        return this;
    }
    n(name) {
        this.name = name;
        return this;
    }
    c(child) {
        this.children.push(child);
        return this;
    }
    a(name, value) {
        if (value != null) {
            this.attributes[name] = value;
        }
        return this;
    }
    cc(input, field, withName = field) {
        if (input[field] != null) {
            const node = XmlNode.of(field, input[field]).withName(withName);
            this.c(node);
        }
    }
    l(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
            const nodes = valueProvider();
            nodes.map((node) => {
                node.withName(memberName);
                this.c(node);
            });
        }
    }
    lc(input, listName, memberName, valueProvider) {
        if (input[listName] != null) {
            const nodes = valueProvider();
            const containerNode = new XmlNode(memberName);
            nodes.map((node) => {
                containerNode.c(node);
            });
            this.c(containerNode);
        }
    }
    toString() {
        const hasChildren = Boolean(this.children.length);
        let xmlText = `<${this.name}`;
        const attributes = this.attributes;
        for (const attributeName of Object.keys(attributes)) {
            const attribute = attributes[attributeName];
            if (attribute != null) {
                xmlText += ` ${attributeName}="${escapeAttribute("" + attribute)}"`;
            }
        }
        return (xmlText += !hasChildren ? "/>" : `>${this.children.map((c) => c.toString()).join("")}</${this.name}>`);
    }
}

Object.defineProperty(exports, "parseXML", ({
    enumerable: true,
    get: function () { return xmlParser.parseXML; }
}));
exports.XmlNode = XmlNode;
exports.XmlText = XmlText;


/***/ }),

/***/ 5015:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseXML = parseXML;
const fast_xml_parser_1 = __nccwpck_require__(4577);
const parser = new fast_xml_parser_1.XMLParser({
    attributeNamePrefix: "",
    htmlEntities: true,
    ignoreAttributes: false,
    ignoreDeclaration: true,
    parseTagValue: false,
    trimValues: false,
    tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
});
parser.addEntity("#xD", "\r");
parser.addEntity("#10", "\n");
function parseXML(xmlString) {
    return parser.parse(xmlString, true);
}


/***/ }),

/***/ 2589:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


const PROTECTED_KEYS = {
    REQUEST_ID: Symbol.for("_AWS_LAMBDA_REQUEST_ID"),
    X_RAY_TRACE_ID: Symbol.for("_AWS_LAMBDA_X_RAY_TRACE_ID"),
    TENANT_ID: Symbol.for("_AWS_LAMBDA_TENANT_ID"),
};
const NO_GLOBAL_AWS_LAMBDA = ["true", "1"].includes(process.env?.AWS_LAMBDA_NODEJS_NO_GLOBAL_AWSLAMBDA ?? "");
if (!NO_GLOBAL_AWS_LAMBDA) {
    globalThis.awslambda = globalThis.awslambda || {};
}
class InvokeStoreBase {
    static PROTECTED_KEYS = PROTECTED_KEYS;
    isProtectedKey(key) {
        return Object.values(PROTECTED_KEYS).includes(key);
    }
    getRequestId() {
        return this.get(PROTECTED_KEYS.REQUEST_ID) ?? "-";
    }
    getXRayTraceId() {
        return this.get(PROTECTED_KEYS.X_RAY_TRACE_ID);
    }
    getTenantId() {
        return this.get(PROTECTED_KEYS.TENANT_ID);
    }
}
class InvokeStoreSingle extends InvokeStoreBase {
    currentContext;
    getContext() {
        return this.currentContext;
    }
    hasContext() {
        return this.currentContext !== undefined;
    }
    get(key) {
        return this.currentContext?.[key];
    }
    set(key, value) {
        if (this.isProtectedKey(key)) {
            throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
        }
        this.currentContext = this.currentContext || {};
        this.currentContext[key] = value;
    }
    run(context, fn) {
        this.currentContext = context;
        return fn();
    }
}
class InvokeStoreMulti extends InvokeStoreBase {
    als;
    static async create() {
        const instance = new InvokeStoreMulti();
        const asyncHooks = await Promise.resolve(/* import() */).then(__nccwpck_require__.t.bind(__nccwpck_require__, 2761, 23));
        instance.als = new asyncHooks.AsyncLocalStorage();
        return instance;
    }
    getContext() {
        return this.als.getStore();
    }
    hasContext() {
        return this.als.getStore() !== undefined;
    }
    get(key) {
        return this.als.getStore()?.[key];
    }
    set(key, value) {
        if (this.isProtectedKey(key)) {
            throw new Error(`Cannot modify protected Lambda context field: ${String(key)}`);
        }
        const store = this.als.getStore();
        if (!store) {
            throw new Error("No context available");
        }
        store[key] = value;
    }
    run(context, fn) {
        return this.als.run(context, fn);
    }
}
exports.InvokeStore = void 0;
(function (InvokeStore) {
    let instance = null;
    async function getInstanceAsync() {
        if (!instance) {
            instance = (async () => {
                const isMulti = "AWS_LAMBDA_MAX_CONCURRENCY" in process.env;
                const newInstance = isMulti
                    ? await InvokeStoreMulti.create()
                    : new InvokeStoreSingle();
                if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda?.InvokeStore) {
                    return globalThis.awslambda.InvokeStore;
                }
                else if (!NO_GLOBAL_AWS_LAMBDA && globalThis.awslambda) {
                    globalThis.awslambda.InvokeStore = newInstance;
                    return newInstance;
                }
                else {
                    return newInstance;
                }
            })();
        }
        return instance;
    }
    InvokeStore.getInstanceAsync = getInstanceAsync;
    InvokeStore._testing = process.env.AWS_LAMBDA_BENCHMARK_MODE === "1"
        ? {
            reset: () => {
                instance = null;
                if (globalThis.awslambda?.InvokeStore) {
                    delete globalThis.awslambda.InvokeStore;
                }
                globalThis.awslambda = { InvokeStore: undefined };
            },
        }
        : undefined;
})(exports.InvokeStore || (exports.InvokeStore = {}));

exports.InvokeStoreBase = InvokeStoreBase;


/***/ }),

/***/ 3098:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilConfigProvider = __nccwpck_require__(3375);
var utilMiddleware = __nccwpck_require__(2390);
var utilEndpoints = __nccwpck_require__(5473);

const ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
const CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
const DEFAULT_USE_DUALSTACK_ENDPOINT = false;
const NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_DUALSTACK_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
    default: false,
};

const ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
const CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
const DEFAULT_USE_FIPS_ENDPOINT = false;
const NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => utilConfigProvider.booleanSelector(env, ENV_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.ENV),
    configFileSelector: (profile) => utilConfigProvider.booleanSelector(profile, CONFIG_USE_FIPS_ENDPOINT, utilConfigProvider.SelectorType.CONFIG),
    default: false,
};

const resolveCustomEndpointsConfig = (input) => {
    const { tls, endpoint, urlParser, useDualstackEndpoint } = input;
    return Object.assign(input, {
        tls: tls ?? true,
        endpoint: utilMiddleware.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: utilMiddleware.normalizeProvider(useDualstackEndpoint ?? false),
    });
};

const getEndpointFromRegion = async (input) => {
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
        throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = (await input.regionInfoProvider(region, { useDualstackEndpoint, useFipsEndpoint })) ?? {};
    if (!hostname) {
        throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
};

const resolveEndpointsConfig = (input) => {
    const useDualstackEndpoint = utilMiddleware.normalizeProvider(input.useDualstackEndpoint ?? false);
    const { endpoint, useFipsEndpoint, urlParser, tls } = input;
    return Object.assign(input, {
        tls: tls ?? true,
        endpoint: endpoint
            ? utilMiddleware.normalizeProvider(typeof endpoint === "string" ? urlParser(endpoint) : endpoint)
            : () => getEndpointFromRegion({ ...input, useDualstackEndpoint, useFipsEndpoint }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint,
    });
};

const REGION_ENV_NAME = "AWS_REGION";
const REGION_INI_NAME = "region";
const NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[REGION_ENV_NAME],
    configFileSelector: (profile) => profile[REGION_INI_NAME],
    default: () => {
        throw new Error("Region is missing");
    },
};
const NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials",
};

const validRegions = new Set();
const checkRegion = (region, check = utilEndpoints.isValidHostLabel) => {
    if (!validRegions.has(region) && !check(region)) {
        if (region === "*") {
            console.warn(`@smithy/config-resolver WARN - Please use the caller region instead of "*". See "sigv4a" in https://github.com/aws/aws-sdk-js-v3/blob/main/supplemental-docs/CLIENTS.md.`);
        }
        else {
            throw new Error(`Region not accepted: region="${region}" is not a valid hostname component.`);
        }
    }
    else {
        validRegions.add(region);
    }
};

const isFipsRegion = (region) => typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));

const getRealRegion = (region) => isFipsRegion(region)
    ? ["fips-aws-global", "aws-fips"].includes(region)
        ? "us-east-1"
        : region.replace(/fips-(dkr-|prod-)?|-fips/, "")
    : region;

const resolveRegionConfig = (input) => {
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return Object.assign(input, {
        region: async () => {
            const providedRegion = typeof region === "function" ? await region() : region;
            const realRegion = getRealRegion(providedRegion);
            checkRegion(realRegion);
            return realRegion;
        },
        useFipsEndpoint: async () => {
            const providedRegion = typeof region === "string" ? region : await region();
            if (isFipsRegion(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        },
    });
};

const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint }) => variants.find(({ tags }) => useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))?.hostname;

const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname }) => regionHostname
    ? regionHostname
    : partitionHostname
        ? partitionHostname.replace("{region}", resolvedRegion)
        : undefined;

const getResolvedPartition = (region, { partitionHash }) => Object.keys(partitionHash || {}).find((key) => partitionHash[key].regions.includes(region)) ?? "aws";

const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint }) => {
    if (signingRegion) {
        return signingRegion;
    }
    else if (useFipsEndpoint) {
        const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
        const regionRegexmatchArray = hostname.match(regionRegexJs);
        if (regionRegexmatchArray) {
            return regionRegexmatchArray[0].slice(1, -1);
        }
    }
};

const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash, }) => {
    const partition = getResolvedPartition(region, { partitionHash });
    const resolvedRegion = region in regionHash ? region : partitionHash[partition]?.endpoint ?? region;
    const hostnameOptions = { useFipsEndpoint, useDualstackEndpoint };
    const regionHostname = getHostnameFromVariants(regionHash[resolvedRegion]?.variants, hostnameOptions);
    const partitionHostname = getHostnameFromVariants(partitionHash[partition]?.variants, hostnameOptions);
    const hostname = getResolvedHostname(resolvedRegion, { regionHostname, partitionHostname });
    if (hostname === undefined) {
        throw new Error(`Endpoint resolution failed for: ${{ resolvedRegion, useFipsEndpoint, useDualstackEndpoint }}`);
    }
    const signingRegion = getResolvedSigningRegion(hostname, {
        signingRegion: regionHash[resolvedRegion]?.signingRegion,
        regionRegex: partitionHash[partition].regionRegex,
        useFipsEndpoint,
    });
    return {
        partition,
        signingService,
        hostname,
        ...(signingRegion && { signingRegion }),
        ...(regionHash[resolvedRegion]?.signingService && {
            signingService: regionHash[resolvedRegion].signingService,
        }),
    };
};

exports.CONFIG_USE_DUALSTACK_ENDPOINT = CONFIG_USE_DUALSTACK_ENDPOINT;
exports.CONFIG_USE_FIPS_ENDPOINT = CONFIG_USE_FIPS_ENDPOINT;
exports.DEFAULT_USE_DUALSTACK_ENDPOINT = DEFAULT_USE_DUALSTACK_ENDPOINT;
exports.DEFAULT_USE_FIPS_ENDPOINT = DEFAULT_USE_FIPS_ENDPOINT;
exports.ENV_USE_DUALSTACK_ENDPOINT = ENV_USE_DUALSTACK_ENDPOINT;
exports.ENV_USE_FIPS_ENDPOINT = ENV_USE_FIPS_ENDPOINT;
exports.NODE_REGION_CONFIG_FILE_OPTIONS = NODE_REGION_CONFIG_FILE_OPTIONS;
exports.NODE_REGION_CONFIG_OPTIONS = NODE_REGION_CONFIG_OPTIONS;
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS;
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS;
exports.REGION_ENV_NAME = REGION_ENV_NAME;
exports.REGION_INI_NAME = REGION_INI_NAME;
exports.getRegionInfo = getRegionInfo;
exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;
exports.resolveEndpointsConfig = resolveEndpointsConfig;
exports.resolveRegionConfig = resolveRegionConfig;


/***/ }),

/***/ 5829:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var types = __nccwpck_require__(5756);
var utilMiddleware = __nccwpck_require__(2390);
var middlewareSerde = __nccwpck_require__(1238);
var protocolHttp = __nccwpck_require__(4418);
var protocols = __nccwpck_require__(2241);

const getSmithyContext = (context) => context[types.SMITHY_CONTEXT_KEY] || (context[types.SMITHY_CONTEXT_KEY] = {});

const resolveAuthOptions = (candidateAuthOptions, authSchemePreference) => {
    if (!authSchemePreference || authSchemePreference.length === 0) {
        return candidateAuthOptions;
    }
    const preferredAuthOptions = [];
    for (const preferredSchemeName of authSchemePreference) {
        for (const candidateAuthOption of candidateAuthOptions) {
            const candidateAuthSchemeName = candidateAuthOption.schemeId.split("#")[1];
            if (candidateAuthSchemeName === preferredSchemeName) {
                preferredAuthOptions.push(candidateAuthOption);
            }
        }
    }
    for (const candidateAuthOption of candidateAuthOptions) {
        if (!preferredAuthOptions.find(({ schemeId }) => schemeId === candidateAuthOption.schemeId)) {
            preferredAuthOptions.push(candidateAuthOption);
        }
    }
    return preferredAuthOptions;
};

function convertHttpAuthSchemesToMap(httpAuthSchemes) {
    const map = new Map();
    for (const scheme of httpAuthSchemes) {
        map.set(scheme.schemeId, scheme);
    }
    return map;
}
const httpAuthSchemeMiddleware = (config, mwOptions) => (next, context) => async (args) => {
    const options = config.httpAuthSchemeProvider(await mwOptions.httpAuthSchemeParametersProvider(config, context, args.input));
    const authSchemePreference = config.authSchemePreference ? await config.authSchemePreference() : [];
    const resolvedOptions = resolveAuthOptions(options, authSchemePreference);
    const authSchemes = convertHttpAuthSchemesToMap(config.httpAuthSchemes);
    const smithyContext = utilMiddleware.getSmithyContext(context);
    const failureReasons = [];
    for (const option of resolvedOptions) {
        const scheme = authSchemes.get(option.schemeId);
        if (!scheme) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` was not enabled for this service.`);
            continue;
        }
        const identityProvider = scheme.identityProvider(await mwOptions.identityProviderConfigProvider(config));
        if (!identityProvider) {
            failureReasons.push(`HttpAuthScheme \`${option.schemeId}\` did not have an IdentityProvider configured.`);
            continue;
        }
        const { identityProperties = {}, signingProperties = {} } = option.propertiesExtractor?.(config, context) || {};
        option.identityProperties = Object.assign(option.identityProperties || {}, identityProperties);
        option.signingProperties = Object.assign(option.signingProperties || {}, signingProperties);
        smithyContext.selectedHttpAuthScheme = {
            httpAuthOption: option,
            identity: await identityProvider(option.identityProperties),
            signer: scheme.signer,
        };
        break;
    }
    if (!smithyContext.selectedHttpAuthScheme) {
        throw new Error(failureReasons.join("\n"));
    }
    return next(args);
};

const httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: "endpointV2Middleware",
};
const getHttpAuthSchemeEndpointRuleSetPlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
            httpAuthSchemeParametersProvider,
            identityProviderConfigProvider,
        }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
    },
});

const httpAuthSchemeMiddlewareOptions = {
    step: "serialize",
    tags: ["HTTP_AUTH_SCHEME"],
    name: "httpAuthSchemeMiddleware",
    override: true,
    relation: "before",
    toMiddleware: middlewareSerde.serializerMiddlewareOption.name,
};
const getHttpAuthSchemePlugin = (config, { httpAuthSchemeParametersProvider, identityProviderConfigProvider, }) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpAuthSchemeMiddleware(config, {
            httpAuthSchemeParametersProvider,
            identityProviderConfigProvider,
        }), httpAuthSchemeMiddlewareOptions);
    },
});

const defaultErrorHandler = (signingProperties) => (error) => {
    throw error;
};
const defaultSuccessHandler = (httpResponse, signingProperties) => { };
const httpSigningMiddleware = (config) => (next, context) => async (args) => {
    if (!protocolHttp.HttpRequest.isInstance(args.request)) {
        return next(args);
    }
    const smithyContext = utilMiddleware.getSmithyContext(context);
    const scheme = smithyContext.selectedHttpAuthScheme;
    if (!scheme) {
        throw new Error(`No HttpAuthScheme was selected: unable to sign request`);
    }
    const { httpAuthOption: { signingProperties = {} }, identity, signer, } = scheme;
    const output = await next({
        ...args,
        request: await signer.sign(args.request, identity, signingProperties),
    }).catch((signer.errorHandler || defaultErrorHandler)(signingProperties));
    (signer.successHandler || defaultSuccessHandler)(output.response, signingProperties);
    return output;
};

const httpSigningMiddlewareOptions = {
    step: "finalizeRequest",
    tags: ["HTTP_SIGNING"],
    name: "httpSigningMiddleware",
    aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
    override: true,
    relation: "after",
    toMiddleware: "retryMiddleware",
};
const getHttpSigningPlugin = (config) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
    },
});

const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

const makePagedClientRequest = async (CommandCtor, client, input, withCommand = (_) => _, ...args) => {
    let command = new CommandCtor(input);
    command = withCommand(command) ?? command;
    return await client.send(command, ...args);
};
function createPaginator(ClientCtor, CommandCtor, inputTokenName, outputTokenName, pageSizeTokenName) {
    return async function* paginateOperation(config, input, ...additionalArguments) {
        const _input = input;
        let token = config.startingToken ?? _input[inputTokenName];
        let hasNext = true;
        let page;
        while (hasNext) {
            _input[inputTokenName] = token;
            if (pageSizeTokenName) {
                _input[pageSizeTokenName] = _input[pageSizeTokenName] ?? config.pageSize;
            }
            if (config.client instanceof ClientCtor) {
                page = await makePagedClientRequest(CommandCtor, config.client, input, config.withCommand, ...additionalArguments);
            }
            else {
                throw new Error(`Invalid client, expected instance of ${ClientCtor.name}`);
            }
            yield page;
            const prevToken = token;
            token = get(page, outputTokenName);
            hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
        }
        return undefined;
    };
}
const get = (fromObject, path) => {
    let cursor = fromObject;
    const pathComponents = path.split(".");
    for (const step of pathComponents) {
        if (!cursor || typeof cursor !== "object") {
            return undefined;
        }
        cursor = cursor[step];
    }
    return cursor;
};

function setFeature(context, feature, value) {
    if (!context.__smithy_context) {
        context.__smithy_context = {
            features: {},
        };
    }
    else if (!context.__smithy_context.features) {
        context.__smithy_context.features = {};
    }
    context.__smithy_context.features[feature] = value;
}

class DefaultIdentityProviderConfig {
    authSchemes = new Map();
    constructor(config) {
        for (const [key, value] of Object.entries(config)) {
            if (value !== undefined) {
                this.authSchemes.set(key, value);
            }
        }
    }
    getIdentityProvider(schemeId) {
        return this.authSchemes.get(schemeId);
    }
}

class HttpApiKeyAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        if (!signingProperties) {
            throw new Error("request could not be signed with `apiKey` since the `name` and `in` signer properties are missing");
        }
        if (!signingProperties.name) {
            throw new Error("request could not be signed with `apiKey` since the `name` signer property is missing");
        }
        if (!signingProperties.in) {
            throw new Error("request could not be signed with `apiKey` since the `in` signer property is missing");
        }
        if (!identity.apiKey) {
            throw new Error("request could not be signed with `apiKey` since the `apiKey` is not defined");
        }
        const clonedRequest = protocolHttp.HttpRequest.clone(httpRequest);
        if (signingProperties.in === types.HttpApiKeyAuthLocation.QUERY) {
            clonedRequest.query[signingProperties.name] = identity.apiKey;
        }
        else if (signingProperties.in === types.HttpApiKeyAuthLocation.HEADER) {
            clonedRequest.headers[signingProperties.name] = signingProperties.scheme
                ? `${signingProperties.scheme} ${identity.apiKey}`
                : identity.apiKey;
        }
        else {
            throw new Error("request can only be signed with `apiKey` locations `query` or `header`, " +
                "but found: `" +
                signingProperties.in +
                "`");
        }
        return clonedRequest;
    }
}

class HttpBearerAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        const clonedRequest = protocolHttp.HttpRequest.clone(httpRequest);
        if (!identity.token) {
            throw new Error("request could not be signed with `token` since the `token` is not defined");
        }
        clonedRequest.headers["Authorization"] = `Bearer ${identity.token}`;
        return clonedRequest;
    }
}

class NoAuthSigner {
    async sign(httpRequest, identity, signingProperties) {
        return httpRequest;
    }
}

const createIsIdentityExpiredFunction = (expirationMs) => function isIdentityExpired(identity) {
    return doesIdentityRequireRefresh(identity) && identity.expiration.getTime() - Date.now() < expirationMs;
};
const EXPIRATION_MS = 300_000;
const isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS);
const doesIdentityRequireRefresh = (identity) => identity.expiration !== undefined;
const memoizeIdentityProvider = (provider, isExpired, requiresRefresh) => {
    if (provider === undefined) {
        return undefined;
    }
    const normalizedProvider = typeof provider !== "function" ? async () => Promise.resolve(provider) : provider;
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async (options) => {
        if (!pending) {
            pending = normalizedProvider(options);
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider(options);
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider(options);
        }
        if (isConstant) {
            return resolved;
        }
        if (!requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider(options);
            return resolved;
        }
        return resolved;
    };
};

Object.defineProperty(exports, "requestBuilder", ({
    enumerable: true,
    get: function () { return protocols.requestBuilder; }
}));
exports.DefaultIdentityProviderConfig = DefaultIdentityProviderConfig;
exports.EXPIRATION_MS = EXPIRATION_MS;
exports.HttpApiKeyAuthSigner = HttpApiKeyAuthSigner;
exports.HttpBearerAuthSigner = HttpBearerAuthSigner;
exports.NoAuthSigner = NoAuthSigner;
exports.createIsIdentityExpiredFunction = createIsIdentityExpiredFunction;
exports.createPaginator = createPaginator;
exports.doesIdentityRequireRefresh = doesIdentityRequireRefresh;
exports.getHttpAuthSchemeEndpointRuleSetPlugin = getHttpAuthSchemeEndpointRuleSetPlugin;
exports.getHttpAuthSchemePlugin = getHttpAuthSchemePlugin;
exports.getHttpSigningPlugin = getHttpSigningPlugin;
exports.getSmithyContext = getSmithyContext;
exports.httpAuthSchemeEndpointRuleSetMiddlewareOptions = httpAuthSchemeEndpointRuleSetMiddlewareOptions;
exports.httpAuthSchemeMiddleware = httpAuthSchemeMiddleware;
exports.httpAuthSchemeMiddlewareOptions = httpAuthSchemeMiddlewareOptions;
exports.httpSigningMiddleware = httpSigningMiddleware;
exports.httpSigningMiddlewareOptions = httpSigningMiddlewareOptions;
exports.isIdentityExpired = isIdentityExpired;
exports.memoizeIdentityProvider = memoizeIdentityProvider;
exports.normalizeProvider = normalizeProvider;
exports.setFeature = setFeature;


/***/ }),

/***/ 804:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var serde = __nccwpck_require__(7669);
var utilUtf8 = __nccwpck_require__(1895);
var protocols = __nccwpck_require__(2241);
var protocolHttp = __nccwpck_require__(4418);
var utilBodyLengthBrowser = __nccwpck_require__(713);
var schema = __nccwpck_require__(9826);
var utilMiddleware = __nccwpck_require__(2390);
var utilBase64 = __nccwpck_require__(5600);

const majorUint64 = 0;
const majorNegativeInt64 = 1;
const majorUnstructuredByteString = 2;
const majorUtf8String = 3;
const majorList = 4;
const majorMap = 5;
const majorTag = 6;
const majorSpecial = 7;
const specialFalse = 20;
const specialTrue = 21;
const specialNull = 22;
const specialUndefined = 23;
const extendedOneByte = 24;
const extendedFloat16 = 25;
const extendedFloat32 = 26;
const extendedFloat64 = 27;
const minorIndefinite = 31;
function alloc(size) {
    return typeof Buffer !== "undefined" ? Buffer.alloc(size) : new Uint8Array(size);
}
const tagSymbol = Symbol("@smithy/core/cbor::tagSymbol");
function tag(data) {
    data[tagSymbol] = true;
    return data;
}

const USE_TEXT_DECODER = typeof TextDecoder !== "undefined";
const USE_BUFFER$1 = typeof Buffer !== "undefined";
let payload = alloc(0);
let dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
const textDecoder = USE_TEXT_DECODER ? new TextDecoder() : null;
let _offset = 0;
function setPayload(bytes) {
    payload = bytes;
    dataView$1 = new DataView(payload.buffer, payload.byteOffset, payload.byteLength);
}
function decode(at, to) {
    if (at >= to) {
        throw new Error("unexpected end of (decode) payload.");
    }
    const major = (payload[at] & 0b1110_0000) >> 5;
    const minor = payload[at] & 0b0001_1111;
    switch (major) {
        case majorUint64:
        case majorNegativeInt64:
        case majorTag:
            let unsignedInt;
            let offset;
            if (minor < 24) {
                unsignedInt = minor;
                offset = 1;
            }
            else {
                switch (minor) {
                    case extendedOneByte:
                    case extendedFloat16:
                    case extendedFloat32:
                    case extendedFloat64:
                        const countLength = minorValueToArgumentLength[minor];
                        const countOffset = (countLength + 1);
                        offset = countOffset;
                        if (to - at < countOffset) {
                            throw new Error(`countLength ${countLength} greater than remaining buf len.`);
                        }
                        const countIndex = at + 1;
                        if (countLength === 1) {
                            unsignedInt = payload[countIndex];
                        }
                        else if (countLength === 2) {
                            unsignedInt = dataView$1.getUint16(countIndex);
                        }
                        else if (countLength === 4) {
                            unsignedInt = dataView$1.getUint32(countIndex);
                        }
                        else {
                            unsignedInt = dataView$1.getBigUint64(countIndex);
                        }
                        break;
                    default:
                        throw new Error(`unexpected minor value ${minor}.`);
                }
            }
            if (major === majorUint64) {
                _offset = offset;
                return castBigInt(unsignedInt);
            }
            else if (major === majorNegativeInt64) {
                let negativeInt;
                if (typeof unsignedInt === "bigint") {
                    negativeInt = BigInt(-1) - unsignedInt;
                }
                else {
                    negativeInt = -1 - unsignedInt;
                }
                _offset = offset;
                return castBigInt(negativeInt);
            }
            else {
                if (minor === 2 || minor === 3) {
                    const length = decodeCount(at + offset, to);
                    let b = BigInt(0);
                    const start = at + offset + _offset;
                    for (let i = start; i < start + length; ++i) {
                        b = (b << BigInt(8)) | BigInt(payload[i]);
                    }
                    _offset = offset + _offset + length;
                    return minor === 3 ? -b - BigInt(1) : b;
                }
                else if (minor === 4) {
                    const decimalFraction = decode(at + offset, to);
                    const [exponent, mantissa] = decimalFraction;
                    const normalizer = mantissa < 0 ? -1 : 1;
                    const mantissaStr = "0".repeat(Math.abs(exponent) + 1) + String(BigInt(normalizer) * BigInt(mantissa));
                    let numericString;
                    const sign = mantissa < 0 ? "-" : "";
                    numericString =
                        exponent === 0
                            ? mantissaStr
                            : mantissaStr.slice(0, mantissaStr.length + exponent) + "." + mantissaStr.slice(exponent);
                    numericString = numericString.replace(/^0+/g, "");
                    if (numericString === "") {
                        numericString = "0";
                    }
                    if (numericString[0] === ".") {
                        numericString = "0" + numericString;
                    }
                    numericString = sign + numericString;
                    _offset = offset + _offset;
                    return serde.nv(numericString);
                }
                else {
                    const value = decode(at + offset, to);
                    const valueOffset = _offset;
                    _offset = offset + valueOffset;
                    return tag({ tag: castBigInt(unsignedInt), value });
                }
            }
        case majorUtf8String:
        case majorMap:
        case majorList:
        case majorUnstructuredByteString:
            if (minor === minorIndefinite) {
                switch (major) {
                    case majorUtf8String:
                        return decodeUtf8StringIndefinite(at, to);
                    case majorMap:
                        return decodeMapIndefinite(at, to);
                    case majorList:
                        return decodeListIndefinite(at, to);
                    case majorUnstructuredByteString:
                        return decodeUnstructuredByteStringIndefinite(at, to);
                }
            }
            else {
                switch (major) {
                    case majorUtf8String:
                        return decodeUtf8String(at, to);
                    case majorMap:
                        return decodeMap(at, to);
                    case majorList:
                        return decodeList(at, to);
                    case majorUnstructuredByteString:
                        return decodeUnstructuredByteString(at, to);
                }
            }
        default:
            return decodeSpecial(at, to);
    }
}
function bytesToUtf8(bytes, at, to) {
    if (USE_BUFFER$1 && bytes.constructor?.name === "Buffer") {
        return bytes.toString("utf-8", at, to);
    }
    if (textDecoder) {
        return textDecoder.decode(bytes.subarray(at, to));
    }
    return utilUtf8.toUtf8(bytes.subarray(at, to));
}
function demote(bigInteger) {
    const num = Number(bigInteger);
    if (num < Number.MIN_SAFE_INTEGER || Number.MAX_SAFE_INTEGER < num) {
        console.warn(new Error(`@smithy/core/cbor - truncating BigInt(${bigInteger}) to ${num} with loss of precision.`));
    }
    return num;
}
const minorValueToArgumentLength = {
    [extendedOneByte]: 1,
    [extendedFloat16]: 2,
    [extendedFloat32]: 4,
    [extendedFloat64]: 8,
};
function bytesToFloat16(a, b) {
    const sign = a >> 7;
    const exponent = (a & 0b0111_1100) >> 2;
    const fraction = ((a & 0b0000_0011) << 8) | b;
    const scalar = sign === 0 ? 1 : -1;
    let exponentComponent;
    let summation;
    if (exponent === 0b00000) {
        if (fraction === 0b00000_00000) {
            return 0;
        }
        else {
            exponentComponent = Math.pow(2, 1 - 15);
            summation = 0;
        }
    }
    else if (exponent === 0b11111) {
        if (fraction === 0b00000_00000) {
            return scalar * Infinity;
        }
        else {
            return NaN;
        }
    }
    else {
        exponentComponent = Math.pow(2, exponent - 15);
        summation = 1;
    }
    summation += fraction / 1024;
    return scalar * (exponentComponent * summation);
}
function decodeCount(at, to) {
    const minor = payload[at] & 0b0001_1111;
    if (minor < 24) {
        _offset = 1;
        return minor;
    }
    if (minor === extendedOneByte ||
        minor === extendedFloat16 ||
        minor === extendedFloat32 ||
        minor === extendedFloat64) {
        const countLength = minorValueToArgumentLength[minor];
        _offset = (countLength + 1);
        if (to - at < _offset) {
            throw new Error(`countLength ${countLength} greater than remaining buf len.`);
        }
        const countIndex = at + 1;
        if (countLength === 1) {
            return payload[countIndex];
        }
        else if (countLength === 2) {
            return dataView$1.getUint16(countIndex);
        }
        else if (countLength === 4) {
            return dataView$1.getUint32(countIndex);
        }
        return demote(dataView$1.getBigUint64(countIndex));
    }
    throw new Error(`unexpected minor value ${minor}.`);
}
function decodeUtf8String(at, to) {
    const length = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    if (to - at < length) {
        throw new Error(`string len ${length} greater than remaining buf len.`);
    }
    const value = bytesToUtf8(payload, at, at + length);
    _offset = offset + length;
    return value;
}
function decodeUtf8StringIndefinite(at, to) {
    at += 1;
    const vector = [];
    for (const base = at; at < to;) {
        if (payload[at] === 0b1111_1111) {
            const data = alloc(vector.length);
            data.set(vector, 0);
            _offset = at - base + 2;
            return bytesToUtf8(data, 0, data.length);
        }
        const major = (payload[at] & 0b1110_0000) >> 5;
        const minor = payload[at] & 0b0001_1111;
        if (major !== majorUtf8String) {
            throw new Error(`unexpected major type ${major} in indefinite string.`);
        }
        if (minor === minorIndefinite) {
            throw new Error("nested indefinite string.");
        }
        const bytes = decodeUnstructuredByteString(at, to);
        const length = _offset;
        at += length;
        for (let i = 0; i < bytes.length; ++i) {
            vector.push(bytes[i]);
        }
    }
    throw new Error("expected break marker.");
}
function decodeUnstructuredByteString(at, to) {
    const length = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    if (to - at < length) {
        throw new Error(`unstructured byte string len ${length} greater than remaining buf len.`);
    }
    const value = payload.subarray(at, at + length);
    _offset = offset + length;
    return value;
}
function decodeUnstructuredByteStringIndefinite(at, to) {
    at += 1;
    const vector = [];
    for (const base = at; at < to;) {
        if (payload[at] === 0b1111_1111) {
            const data = alloc(vector.length);
            data.set(vector, 0);
            _offset = at - base + 2;
            return data;
        }
        const major = (payload[at] & 0b1110_0000) >> 5;
        const minor = payload[at] & 0b0001_1111;
        if (major !== majorUnstructuredByteString) {
            throw new Error(`unexpected major type ${major} in indefinite string.`);
        }
        if (minor === minorIndefinite) {
            throw new Error("nested indefinite string.");
        }
        const bytes = decodeUnstructuredByteString(at, to);
        const length = _offset;
        at += length;
        for (let i = 0; i < bytes.length; ++i) {
            vector.push(bytes[i]);
        }
    }
    throw new Error("expected break marker.");
}
function decodeList(at, to) {
    const listDataLength = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    const base = at;
    const list = Array(listDataLength);
    for (let i = 0; i < listDataLength; ++i) {
        const item = decode(at, to);
        const itemOffset = _offset;
        list[i] = item;
        at += itemOffset;
    }
    _offset = offset + (at - base);
    return list;
}
function decodeListIndefinite(at, to) {
    at += 1;
    const list = [];
    for (const base = at; at < to;) {
        if (payload[at] === 0b1111_1111) {
            _offset = at - base + 2;
            return list;
        }
        const item = decode(at, to);
        const n = _offset;
        at += n;
        list.push(item);
    }
    throw new Error("expected break marker.");
}
function decodeMap(at, to) {
    const mapDataLength = decodeCount(at, to);
    const offset = _offset;
    at += offset;
    const base = at;
    const map = {};
    for (let i = 0; i < mapDataLength; ++i) {
        if (at >= to) {
            throw new Error("unexpected end of map payload.");
        }
        const major = (payload[at] & 0b1110_0000) >> 5;
        if (major !== majorUtf8String) {
            throw new Error(`unexpected major type ${major} for map key at index ${at}.`);
        }
        const key = decode(at, to);
        at += _offset;
        const value = decode(at, to);
        at += _offset;
        map[key] = value;
    }
    _offset = offset + (at - base);
    return map;
}
function decodeMapIndefinite(at, to) {
    at += 1;
    const base = at;
    const map = {};
    for (; at < to;) {
        if (at >= to) {
            throw new Error("unexpected end of map payload.");
        }
        if (payload[at] === 0b1111_1111) {
            _offset = at - base + 2;
            return map;
        }
        const major = (payload[at] & 0b1110_0000) >> 5;
        if (major !== majorUtf8String) {
            throw new Error(`unexpected major type ${major} for map key.`);
        }
        const key = decode(at, to);
        at += _offset;
        const value = decode(at, to);
        at += _offset;
        map[key] = value;
    }
    throw new Error("expected break marker.");
}
function decodeSpecial(at, to) {
    const minor = payload[at] & 0b0001_1111;
    switch (minor) {
        case specialTrue:
        case specialFalse:
            _offset = 1;
            return minor === specialTrue;
        case specialNull:
            _offset = 1;
            return null;
        case specialUndefined:
            _offset = 1;
            return null;
        case extendedFloat16:
            if (to - at < 3) {
                throw new Error("incomplete float16 at end of buf.");
            }
            _offset = 3;
            return bytesToFloat16(payload[at + 1], payload[at + 2]);
        case extendedFloat32:
            if (to - at < 5) {
                throw new Error("incomplete float32 at end of buf.");
            }
            _offset = 5;
            return dataView$1.getFloat32(at + 1);
        case extendedFloat64:
            if (to - at < 9) {
                throw new Error("incomplete float64 at end of buf.");
            }
            _offset = 9;
            return dataView$1.getFloat64(at + 1);
        default:
            throw new Error(`unexpected minor value ${minor}.`);
    }
}
function castBigInt(bigInt) {
    if (typeof bigInt === "number") {
        return bigInt;
    }
    const num = Number(bigInt);
    if (Number.MIN_SAFE_INTEGER <= num && num <= Number.MAX_SAFE_INTEGER) {
        return num;
    }
    return bigInt;
}

const USE_BUFFER = typeof Buffer !== "undefined";
const initialSize = 2048;
let data = alloc(initialSize);
let dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
let cursor = 0;
function ensureSpace(bytes) {
    const remaining = data.byteLength - cursor;
    if (remaining < bytes) {
        if (cursor < 16_000_000) {
            resize(Math.max(data.byteLength * 4, data.byteLength + bytes));
        }
        else {
            resize(data.byteLength + bytes + 16_000_000);
        }
    }
}
function toUint8Array() {
    const out = alloc(cursor);
    out.set(data.subarray(0, cursor), 0);
    cursor = 0;
    return out;
}
function resize(size) {
    const old = data;
    data = alloc(size);
    if (old) {
        if (old.copy) {
            old.copy(data, 0, 0, old.byteLength);
        }
        else {
            data.set(old, 0);
        }
    }
    dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
}
function encodeHeader(major, value) {
    if (value < 24) {
        data[cursor++] = (major << 5) | value;
    }
    else if (value < 1 << 8) {
        data[cursor++] = (major << 5) | 24;
        data[cursor++] = value;
    }
    else if (value < 1 << 16) {
        data[cursor++] = (major << 5) | extendedFloat16;
        dataView.setUint16(cursor, value);
        cursor += 2;
    }
    else if (value < 2 ** 32) {
        data[cursor++] = (major << 5) | extendedFloat32;
        dataView.setUint32(cursor, value);
        cursor += 4;
    }
    else {
        data[cursor++] = (major << 5) | extendedFloat64;
        dataView.setBigUint64(cursor, typeof value === "bigint" ? value : BigInt(value));
        cursor += 8;
    }
}
function encode(_input) {
    const encodeStack = [_input];
    while (encodeStack.length) {
        const input = encodeStack.pop();
        ensureSpace(typeof input === "string" ? input.length * 4 : 64);
        if (typeof input === "string") {
            if (USE_BUFFER) {
                encodeHeader(majorUtf8String, Buffer.byteLength(input));
                cursor += data.write(input, cursor);
            }
            else {
                const bytes = utilUtf8.fromUtf8(input);
                encodeHeader(majorUtf8String, bytes.byteLength);
                data.set(bytes, cursor);
                cursor += bytes.byteLength;
            }
            continue;
        }
        else if (typeof input === "number") {
            if (Number.isInteger(input)) {
                const nonNegative = input >= 0;
                const major = nonNegative ? majorUint64 : majorNegativeInt64;
                const value = nonNegative ? input : -input - 1;
                if (value < 24) {
                    data[cursor++] = (major << 5) | value;
                }
                else if (value < 256) {
                    data[cursor++] = (major << 5) | 24;
                    data[cursor++] = value;
                }
                else if (value < 65536) {
                    data[cursor++] = (major << 5) | extendedFloat16;
                    data[cursor++] = value >> 8;
                    data[cursor++] = value;
                }
                else if (value < 4294967296) {
                    data[cursor++] = (major << 5) | extendedFloat32;
                    dataView.setUint32(cursor, value);
                    cursor += 4;
                }
                else {
                    data[cursor++] = (major << 5) | extendedFloat64;
                    dataView.setBigUint64(cursor, BigInt(value));
                    cursor += 8;
                }
                continue;
            }
            data[cursor++] = (majorSpecial << 5) | extendedFloat64;
            dataView.setFloat64(cursor, input);
            cursor += 8;
            continue;
        }
        else if (typeof input === "bigint") {
            const nonNegative = input >= 0;
            const major = nonNegative ? majorUint64 : majorNegativeInt64;
            const value = nonNegative ? input : -input - BigInt(1);
            const n = Number(value);
            if (n < 24) {
                data[cursor++] = (major << 5) | n;
            }
            else if (n < 256) {
                data[cursor++] = (major << 5) | 24;
                data[cursor++] = n;
            }
            else if (n < 65536) {
                data[cursor++] = (major << 5) | extendedFloat16;
                data[cursor++] = n >> 8;
                data[cursor++] = n & 0b1111_1111;
            }
            else if (n < 4294967296) {
                data[cursor++] = (major << 5) | extendedFloat32;
                dataView.setUint32(cursor, n);
                cursor += 4;
            }
            else if (value < BigInt("18446744073709551616")) {
                data[cursor++] = (major << 5) | extendedFloat64;
                dataView.setBigUint64(cursor, value);
                cursor += 8;
            }
            else {
                const binaryBigInt = value.toString(2);
                const bigIntBytes = new Uint8Array(Math.ceil(binaryBigInt.length / 8));
                let b = value;
                let i = 0;
                while (bigIntBytes.byteLength - ++i >= 0) {
                    bigIntBytes[bigIntBytes.byteLength - i] = Number(b & BigInt(255));
                    b >>= BigInt(8);
                }
                ensureSpace(bigIntBytes.byteLength * 2);
                data[cursor++] = nonNegative ? 0b110_00010 : 0b110_00011;
                if (USE_BUFFER) {
                    encodeHeader(majorUnstructuredByteString, Buffer.byteLength(bigIntBytes));
                }
                else {
                    encodeHeader(majorUnstructuredByteString, bigIntBytes.byteLength);
                }
                data.set(bigIntBytes, cursor);
                cursor += bigIntBytes.byteLength;
            }
            continue;
        }
        else if (input === null) {
            data[cursor++] = (majorSpecial << 5) | specialNull;
            continue;
        }
        else if (typeof input === "boolean") {
            data[cursor++] = (majorSpecial << 5) | (input ? specialTrue : specialFalse);
            continue;
        }
        else if (typeof input === "undefined") {
            throw new Error("@smithy/core/cbor: client may not serialize undefined value.");
        }
        else if (Array.isArray(input)) {
            for (let i = input.length - 1; i >= 0; --i) {
                encodeStack.push(input[i]);
            }
            encodeHeader(majorList, input.length);
            continue;
        }
        else if (typeof input.byteLength === "number") {
            ensureSpace(input.length * 2);
            encodeHeader(majorUnstructuredByteString, input.length);
            data.set(input, cursor);
            cursor += input.byteLength;
            continue;
        }
        else if (typeof input === "object") {
            if (input instanceof serde.NumericValue) {
                const decimalIndex = input.string.indexOf(".");
                const exponent = decimalIndex === -1 ? 0 : decimalIndex - input.string.length + 1;
                const mantissa = BigInt(input.string.replace(".", ""));
                data[cursor++] = 0b110_00100;
                encodeStack.push(mantissa);
                encodeStack.push(exponent);
                encodeHeader(majorList, 2);
                continue;
            }
            if (input[tagSymbol]) {
                if ("tag" in input && "value" in input) {
                    encodeStack.push(input.value);
                    encodeHeader(majorTag, input.tag);
                    continue;
                }
                else {
                    throw new Error("tag encountered with missing fields, need 'tag' and 'value', found: " + JSON.stringify(input));
                }
            }
            const keys = Object.keys(input);
            for (let i = keys.length - 1; i >= 0; --i) {
                const key = keys[i];
                encodeStack.push(input[key]);
                encodeStack.push(key);
            }
            encodeHeader(majorMap, keys.length);
            continue;
        }
        throw new Error(`data type ${input?.constructor?.name ?? typeof input} not compatible for encoding.`);
    }
}

const cbor = {
    deserialize(payload) {
        setPayload(payload);
        return decode(0, payload.length);
    },
    serialize(input) {
        try {
            encode(input);
            return toUint8Array();
        }
        catch (e) {
            toUint8Array();
            throw e;
        }
    },
    resizeEncodingBuffer(size) {
        resize(size);
    },
};

const parseCborBody = (streamBody, context) => {
    return protocols.collectBody(streamBody, context).then(async (bytes) => {
        if (bytes.length) {
            try {
                return cbor.deserialize(bytes);
            }
            catch (e) {
                Object.defineProperty(e, "$responseBodyText", {
                    value: context.utf8Encoder(bytes),
                });
                throw e;
            }
        }
        return {};
    });
};
const dateToTag = (date) => {
    return tag({
        tag: 1,
        value: date.getTime() / 1000,
    });
};
const parseCborErrorBody = async (errorBody, context) => {
    const value = await parseCborBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadSmithyRpcV2CborErrorCode = (output, data) => {
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
    const codeKey = Object.keys(data).find((key) => key.toLowerCase() === "code");
    if (codeKey && data[codeKey] !== undefined) {
        return sanitizeErrorCode(data[codeKey]);
    }
};
const checkCborResponse = (response) => {
    if (String(response.headers["smithy-protocol"]).toLowerCase() !== "rpc-v2-cbor") {
        throw new Error("Malformed RPCv2 CBOR response, status: " + response.statusCode);
    }
};
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers: {
            ...headers,
        },
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
        try {
            contents.headers["content-length"] = String(utilBodyLengthBrowser.calculateBodyLength(body));
        }
        catch (e) { }
    }
    return new protocolHttp.HttpRequest(contents);
};

class CborCodec extends protocols.SerdeContext {
    createSerializer() {
        const serializer = new CborShapeSerializer();
        serializer.setSerdeContext(this.serdeContext);
        return serializer;
    }
    createDeserializer() {
        const deserializer = new CborShapeDeserializer();
        deserializer.setSerdeContext(this.serdeContext);
        return deserializer;
    }
}
class CborShapeSerializer extends protocols.SerdeContext {
    value;
    write(schema, value) {
        this.value = this.serialize(schema, value);
    }
    serialize(schema$1, source) {
        const ns = schema.NormalizedSchema.of(schema$1);
        if (source == null) {
            if (ns.isIdempotencyToken()) {
                return serde.generateIdempotencyToken();
            }
            return source;
        }
        if (ns.isBlobSchema()) {
            if (typeof source === "string") {
                return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(source);
            }
            return source;
        }
        if (ns.isTimestampSchema()) {
            if (typeof source === "number" || typeof source === "bigint") {
                return dateToTag(new Date((Number(source) / 1000) | 0));
            }
            return dateToTag(source);
        }
        if (typeof source === "function" || typeof source === "object") {
            const sourceObject = source;
            if (ns.isListSchema() && Array.isArray(sourceObject)) {
                const sparse = !!ns.getMergedTraits().sparse;
                const newArray = [];
                let i = 0;
                for (const item of sourceObject) {
                    const value = this.serialize(ns.getValueSchema(), item);
                    if (value != null || sparse) {
                        newArray[i++] = value;
                    }
                }
                return newArray;
            }
            if (sourceObject instanceof Date) {
                return dateToTag(sourceObject);
            }
            const newObject = {};
            if (ns.isMapSchema()) {
                const sparse = !!ns.getMergedTraits().sparse;
                for (const key of Object.keys(sourceObject)) {
                    const value = this.serialize(ns.getValueSchema(), sourceObject[key]);
                    if (value != null || sparse) {
                        newObject[key] = value;
                    }
                }
            }
            else if (ns.isStructSchema()) {
                for (const [key, memberSchema] of ns.structIterator()) {
                    const value = this.serialize(memberSchema, sourceObject[key]);
                    if (value != null) {
                        newObject[key] = value;
                    }
                }
                const isUnion = ns.isUnionSchema();
                if (isUnion && Array.isArray(sourceObject.$unknown)) {
                    const [k, v] = sourceObject.$unknown;
                    newObject[k] = v;
                }
                else if (typeof sourceObject.__type === "string") {
                    for (const [k, v] of Object.entries(sourceObject)) {
                        if (!(k in newObject)) {
                            newObject[k] = this.serialize(15, v);
                        }
                    }
                }
            }
            else if (ns.isDocumentSchema()) {
                for (const key of Object.keys(sourceObject)) {
                    newObject[key] = this.serialize(ns.getValueSchema(), sourceObject[key]);
                }
            }
            else if (ns.isBigDecimalSchema()) {
                return sourceObject;
            }
            return newObject;
        }
        return source;
    }
    flush() {
        const buffer = cbor.serialize(this.value);
        this.value = undefined;
        return buffer;
    }
}
class CborShapeDeserializer extends protocols.SerdeContext {
    read(schema, bytes) {
        const data = cbor.deserialize(bytes);
        return this.readValue(schema, data);
    }
    readValue(_schema, value) {
        const ns = schema.NormalizedSchema.of(_schema);
        if (ns.isTimestampSchema()) {
            if (typeof value === "number") {
                return serde._parseEpochTimestamp(value);
            }
            if (typeof value === "object") {
                if (value.tag === 1 && "value" in value) {
                    return serde._parseEpochTimestamp(value.value);
                }
            }
        }
        if (ns.isBlobSchema()) {
            if (typeof value === "string") {
                return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(value);
            }
            return value;
        }
        if (typeof value === "undefined" ||
            typeof value === "boolean" ||
            typeof value === "number" ||
            typeof value === "string" ||
            typeof value === "bigint" ||
            typeof value === "symbol") {
            return value;
        }
        else if (typeof value === "object") {
            if (value === null) {
                return null;
            }
            if ("byteLength" in value) {
                return value;
            }
            if (value instanceof Date) {
                return value;
            }
            if (ns.isDocumentSchema()) {
                return value;
            }
            if (ns.isListSchema()) {
                const newArray = [];
                const memberSchema = ns.getValueSchema();
                const sparse = !!ns.getMergedTraits().sparse;
                for (const item of value) {
                    const itemValue = this.readValue(memberSchema, item);
                    if (itemValue != null || sparse) {
                        newArray.push(itemValue);
                    }
                }
                return newArray;
            }
            const newObject = {};
            if (ns.isMapSchema()) {
                const sparse = !!ns.getMergedTraits().sparse;
                const targetSchema = ns.getValueSchema();
                for (const key of Object.keys(value)) {
                    const itemValue = this.readValue(targetSchema, value[key]);
                    if (itemValue != null || sparse) {
                        newObject[key] = itemValue;
                    }
                }
            }
            else if (ns.isStructSchema()) {
                const isUnion = ns.isUnionSchema();
                let keys;
                if (isUnion) {
                    keys = new Set(Object.keys(value).filter((k) => k !== "__type"));
                }
                for (const [key, memberSchema] of ns.structIterator()) {
                    if (isUnion) {
                        keys.delete(key);
                    }
                    if (value[key] != null) {
                        newObject[key] = this.readValue(memberSchema, value[key]);
                    }
                }
                if (isUnion && keys?.size === 1 && Object.keys(newObject).length === 0) {
                    const k = keys.values().next().value;
                    newObject.$unknown = [k, value[k]];
                }
                else if (typeof value.__type === "string") {
                    for (const [k, v] of Object.entries(value)) {
                        if (!(k in newObject)) {
                            newObject[k] = v;
                        }
                    }
                }
            }
            else if (value instanceof serde.NumericValue) {
                return value;
            }
            return newObject;
        }
        else {
            return value;
        }
    }
}

class SmithyRpcV2CborProtocol extends protocols.RpcProtocol {
    codec = new CborCodec();
    serializer = this.codec.createSerializer();
    deserializer = this.codec.createDeserializer();
    constructor({ defaultNamespace }) {
        super({ defaultNamespace });
    }
    getShapeId() {
        return "smithy.protocols#rpcv2Cbor";
    }
    getPayloadCodec() {
        return this.codec;
    }
    async serializeRequest(operationSchema, input, context) {
        const request = await super.serializeRequest(operationSchema, input, context);
        Object.assign(request.headers, {
            "content-type": this.getDefaultContentType(),
            "smithy-protocol": "rpc-v2-cbor",
            accept: this.getDefaultContentType(),
        });
        if (schema.deref(operationSchema.input) === "unit") {
            delete request.body;
            delete request.headers["content-type"];
        }
        else {
            if (!request.body) {
                this.serializer.write(15, {});
                request.body = this.serializer.flush();
            }
            try {
                request.headers["content-length"] = String(request.body.byteLength);
            }
            catch (e) { }
        }
        const { service, operation } = utilMiddleware.getSmithyContext(context);
        const path = `/service/${service}/operation/${operation}`;
        if (request.path.endsWith("/")) {
            request.path += path.slice(1);
        }
        else {
            request.path += path;
        }
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        return super.deserializeResponse(operationSchema, context, response);
    }
    async handleError(operationSchema, context, response, dataObject, metadata) {
        const errorName = loadSmithyRpcV2CborErrorCode(response, dataObject) ?? "Unknown";
        let namespace = this.options.defaultNamespace;
        if (errorName.includes("#")) {
            [namespace] = errorName.split("#");
        }
        const errorMetadata = {
            $metadata: metadata,
            $fault: response.statusCode <= 500 ? "client" : "server",
        };
        const registry = schema.TypeRegistry.for(namespace);
        let errorSchema;
        try {
            errorSchema = registry.getSchema(errorName);
        }
        catch (e) {
            if (dataObject.Message) {
                dataObject.message = dataObject.Message;
            }
            const synthetic = schema.TypeRegistry.for("smithy.ts.sdk.synthetic." + namespace);
            const baseExceptionSchema = synthetic.getBaseException();
            if (baseExceptionSchema) {
                const ErrorCtor = synthetic.getErrorCtor(baseExceptionSchema);
                throw Object.assign(new ErrorCtor({ name: errorName }), errorMetadata, dataObject);
            }
            throw Object.assign(new Error(errorName), errorMetadata, dataObject);
        }
        const ns = schema.NormalizedSchema.of(errorSchema);
        const ErrorCtor = registry.getErrorCtor(errorSchema);
        const message = dataObject.message ?? dataObject.Message ?? "Unknown";
        const exception = new ErrorCtor(message);
        const output = {};
        for (const [name, member] of ns.structIterator()) {
            output[name] = this.deserializer.readValue(member, dataObject[name]);
        }
        throw Object.assign(exception, errorMetadata, {
            $fault: ns.getMergedTraits().error,
            message,
        }, output);
    }
    getDefaultContentType() {
        return "application/cbor";
    }
}

exports.CborCodec = CborCodec;
exports.CborShapeDeserializer = CborShapeDeserializer;
exports.CborShapeSerializer = CborShapeSerializer;
exports.SmithyRpcV2CborProtocol = SmithyRpcV2CborProtocol;
exports.buildHttpRpcRequest = buildHttpRpcRequest;
exports.cbor = cbor;
exports.checkCborResponse = checkCborResponse;
exports.dateToTag = dateToTag;
exports.loadSmithyRpcV2CborErrorCode = loadSmithyRpcV2CborErrorCode;
exports.parseCborBody = parseCborBody;
exports.parseCborErrorBody = parseCborErrorBody;
exports.tag = tag;
exports.tagSymbol = tagSymbol;


/***/ }),

/***/ 2241:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilStream = __nccwpck_require__(6607);
var schema = __nccwpck_require__(9826);
var serde = __nccwpck_require__(7669);
var protocolHttp = __nccwpck_require__(4418);
var utilBase64 = __nccwpck_require__(5600);
var utilUtf8 = __nccwpck_require__(1895);

const collectBody = async (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return utilStream.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return utilStream.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return utilStream.Uint8ArrayBlobAdapter.mutate(await fromContext);
};

function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}

class SerdeContext {
    serdeContext;
    setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
    }
}

class HttpProtocol extends SerdeContext {
    options;
    constructor(options) {
        super();
        this.options = options;
    }
    getRequestType() {
        return protocolHttp.HttpRequest;
    }
    getResponseType() {
        return protocolHttp.HttpResponse;
    }
    setSerdeContext(serdeContext) {
        this.serdeContext = serdeContext;
        this.serializer.setSerdeContext(serdeContext);
        this.deserializer.setSerdeContext(serdeContext);
        if (this.getPayloadCodec()) {
            this.getPayloadCodec().setSerdeContext(serdeContext);
        }
    }
    updateServiceEndpoint(request, endpoint) {
        if ("url" in endpoint) {
            request.protocol = endpoint.url.protocol;
            request.hostname = endpoint.url.hostname;
            request.port = endpoint.url.port ? Number(endpoint.url.port) : undefined;
            request.path = endpoint.url.pathname;
            request.fragment = endpoint.url.hash || void 0;
            request.username = endpoint.url.username || void 0;
            request.password = endpoint.url.password || void 0;
            if (!request.query) {
                request.query = {};
            }
            for (const [k, v] of endpoint.url.searchParams.entries()) {
                request.query[k] = v;
            }
            return request;
        }
        else {
            request.protocol = endpoint.protocol;
            request.hostname = endpoint.hostname;
            request.port = endpoint.port ? Number(endpoint.port) : undefined;
            request.path = endpoint.path;
            request.query = {
                ...endpoint.query,
            };
            return request;
        }
    }
    setHostPrefix(request, operationSchema, input) {
        if (this.serdeContext?.disableHostPrefix) {
            return;
        }
        const inputNs = schema.NormalizedSchema.of(operationSchema.input);
        const opTraits = schema.translateTraits(operationSchema.traits ?? {});
        if (opTraits.endpoint) {
            let hostPrefix = opTraits.endpoint?.[0];
            if (typeof hostPrefix === "string") {
                const hostLabelInputs = [...inputNs.structIterator()].filter(([, member]) => member.getMergedTraits().hostLabel);
                for (const [name] of hostLabelInputs) {
                    const replacement = input[name];
                    if (typeof replacement !== "string") {
                        throw new Error(`@smithy/core/schema - ${name} in input must be a string as hostLabel.`);
                    }
                    hostPrefix = hostPrefix.replace(`{${name}}`, replacement);
                }
                request.hostname = hostPrefix + request.hostname;
            }
        }
    }
    deserializeMetadata(output) {
        return {
            httpStatusCode: output.statusCode,
            requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
            extendedRequestId: output.headers["x-amz-id-2"],
            cfId: output.headers["x-amz-cf-id"],
        };
    }
    async serializeEventStream({ eventStream, requestSchema, initialRequest, }) {
        const eventStreamSerde = await this.loadEventStreamCapability();
        return eventStreamSerde.serializeEventStream({
            eventStream,
            requestSchema,
            initialRequest,
        });
    }
    async deserializeEventStream({ response, responseSchema, initialResponseContainer, }) {
        const eventStreamSerde = await this.loadEventStreamCapability();
        return eventStreamSerde.deserializeEventStream({
            response,
            responseSchema,
            initialResponseContainer,
        });
    }
    async loadEventStreamCapability() {
        const { EventStreamSerde } = await __nccwpck_require__.e(/* import() */ 702).then(__nccwpck_require__.t.bind(__nccwpck_require__, 3702, 19));
        return new EventStreamSerde({
            marshaller: this.getEventStreamMarshaller(),
            serializer: this.serializer,
            deserializer: this.deserializer,
            serdeContext: this.serdeContext,
            defaultContentType: this.getDefaultContentType(),
        });
    }
    getDefaultContentType() {
        throw new Error(`@smithy/core/protocols - ${this.constructor.name} getDefaultContentType() implementation missing.`);
    }
    async deserializeHttpMessage(schema, context, response, arg4, arg5) {
        return [];
    }
    getEventStreamMarshaller() {
        const context = this.serdeContext;
        if (!context.eventStreamMarshaller) {
            throw new Error("@smithy/core - HttpProtocol: eventStreamMarshaller missing in serdeContext.");
        }
        return context.eventStreamMarshaller;
    }
}

class HttpBindingProtocol extends HttpProtocol {
    async serializeRequest(operationSchema, _input, context) {
        const input = {
            ...(_input ?? {}),
        };
        const serializer = this.serializer;
        const query = {};
        const headers = {};
        const endpoint = await context.endpoint();
        const ns = schema.NormalizedSchema.of(operationSchema?.input);
        const schema$1 = ns.getSchema();
        let hasNonHttpBindingMember = false;
        let payload;
        const request = new protocolHttp.HttpRequest({
            protocol: "",
            hostname: "",
            port: undefined,
            path: "",
            fragment: undefined,
            query: query,
            headers: headers,
            body: undefined,
        });
        if (endpoint) {
            this.updateServiceEndpoint(request, endpoint);
            this.setHostPrefix(request, operationSchema, input);
            const opTraits = schema.translateTraits(operationSchema.traits);
            if (opTraits.http) {
                request.method = opTraits.http[0];
                const [path, search] = opTraits.http[1].split("?");
                if (request.path == "/") {
                    request.path = path;
                }
                else {
                    request.path += path;
                }
                const traitSearchParams = new URLSearchParams(search ?? "");
                Object.assign(query, Object.fromEntries(traitSearchParams));
            }
        }
        for (const [memberName, memberNs] of ns.structIterator()) {
            const memberTraits = memberNs.getMergedTraits() ?? {};
            const inputMemberValue = input[memberName];
            if (inputMemberValue == null && !memberNs.isIdempotencyToken()) {
                if (memberTraits.httpLabel) {
                    if (request.path.includes(`{${memberName}+}`) || request.path.includes(`{${memberName}}`)) {
                        throw new Error(`No value provided for input HTTP label: ${memberName}.`);
                    }
                }
                continue;
            }
            if (memberTraits.httpPayload) {
                const isStreaming = memberNs.isStreaming();
                if (isStreaming) {
                    const isEventStream = memberNs.isStructSchema();
                    if (isEventStream) {
                        if (input[memberName]) {
                            payload = await this.serializeEventStream({
                                eventStream: input[memberName],
                                requestSchema: ns,
                            });
                        }
                    }
                    else {
                        payload = inputMemberValue;
                    }
                }
                else {
                    serializer.write(memberNs, inputMemberValue);
                    payload = serializer.flush();
                }
                delete input[memberName];
            }
            else if (memberTraits.httpLabel) {
                serializer.write(memberNs, inputMemberValue);
                const replacement = serializer.flush();
                if (request.path.includes(`{${memberName}+}`)) {
                    request.path = request.path.replace(`{${memberName}+}`, replacement.split("/").map(extendedEncodeURIComponent).join("/"));
                }
                else if (request.path.includes(`{${memberName}}`)) {
                    request.path = request.path.replace(`{${memberName}}`, extendedEncodeURIComponent(replacement));
                }
                delete input[memberName];
            }
            else if (memberTraits.httpHeader) {
                serializer.write(memberNs, inputMemberValue);
                headers[memberTraits.httpHeader.toLowerCase()] = String(serializer.flush());
                delete input[memberName];
            }
            else if (typeof memberTraits.httpPrefixHeaders === "string") {
                for (const [key, val] of Object.entries(inputMemberValue)) {
                    const amalgam = memberTraits.httpPrefixHeaders + key;
                    serializer.write([memberNs.getValueSchema(), { httpHeader: amalgam }], val);
                    headers[amalgam.toLowerCase()] = serializer.flush();
                }
                delete input[memberName];
            }
            else if (memberTraits.httpQuery || memberTraits.httpQueryParams) {
                this.serializeQuery(memberNs, inputMemberValue, query);
                delete input[memberName];
            }
            else {
                hasNonHttpBindingMember = true;
            }
        }
        if (hasNonHttpBindingMember && input) {
            serializer.write(schema$1, input);
            payload = serializer.flush();
        }
        request.headers = headers;
        request.query = query;
        request.body = payload;
        return request;
    }
    serializeQuery(ns, data, query) {
        const serializer = this.serializer;
        const traits = ns.getMergedTraits();
        if (traits.httpQueryParams) {
            for (const [key, val] of Object.entries(data)) {
                if (!(key in query)) {
                    const valueSchema = ns.getValueSchema();
                    Object.assign(valueSchema.getMergedTraits(), {
                        ...traits,
                        httpQuery: key,
                        httpQueryParams: undefined,
                    });
                    this.serializeQuery(valueSchema, val, query);
                }
            }
            return;
        }
        if (ns.isListSchema()) {
            const sparse = !!ns.getMergedTraits().sparse;
            const buffer = [];
            for (const item of data) {
                serializer.write([ns.getValueSchema(), traits], item);
                const serializable = serializer.flush();
                if (sparse || serializable !== undefined) {
                    buffer.push(serializable);
                }
            }
            query[traits.httpQuery] = buffer;
        }
        else {
            serializer.write([ns, traits], data);
            query[traits.httpQuery] = serializer.flush();
        }
    }
    async deserializeResponse(operationSchema, context, response) {
        const deserializer = this.deserializer;
        const ns = schema.NormalizedSchema.of(operationSchema.output);
        const dataObject = {};
        if (response.statusCode >= 300) {
            const bytes = await collectBody(response.body, context);
            if (bytes.byteLength > 0) {
                Object.assign(dataObject, await deserializer.read(15, bytes));
            }
            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
            throw new Error("@smithy/core/protocols - HTTP Protocol error handler failed to throw.");
        }
        for (const header in response.headers) {
            const value = response.headers[header];
            delete response.headers[header];
            response.headers[header.toLowerCase()] = value;
        }
        const nonHttpBindingMembers = await this.deserializeHttpMessage(ns, context, response, dataObject);
        if (nonHttpBindingMembers.length) {
            const bytes = await collectBody(response.body, context);
            if (bytes.byteLength > 0) {
                const dataFromBody = await deserializer.read(ns, bytes);
                for (const member of nonHttpBindingMembers) {
                    dataObject[member] = dataFromBody[member];
                }
            }
        }
        else if (nonHttpBindingMembers.discardResponseBody) {
            await collectBody(response.body, context);
        }
        dataObject.$metadata = this.deserializeMetadata(response);
        return dataObject;
    }
    async deserializeHttpMessage(schema$1, context, response, arg4, arg5) {
        let dataObject;
        if (arg4 instanceof Set) {
            dataObject = arg5;
        }
        else {
            dataObject = arg4;
        }
        let discardResponseBody = true;
        const deserializer = this.deserializer;
        const ns = schema.NormalizedSchema.of(schema$1);
        const nonHttpBindingMembers = [];
        for (const [memberName, memberSchema] of ns.structIterator()) {
            const memberTraits = memberSchema.getMemberTraits();
            if (memberTraits.httpPayload) {
                discardResponseBody = false;
                const isStreaming = memberSchema.isStreaming();
                if (isStreaming) {
                    const isEventStream = memberSchema.isStructSchema();
                    if (isEventStream) {
                        dataObject[memberName] = await this.deserializeEventStream({
                            response,
                            responseSchema: ns,
                        });
                    }
                    else {
                        dataObject[memberName] = utilStream.sdkStreamMixin(response.body);
                    }
                }
                else if (response.body) {
                    const bytes = await collectBody(response.body, context);
                    if (bytes.byteLength > 0) {
                        dataObject[memberName] = await deserializer.read(memberSchema, bytes);
                    }
                }
            }
            else if (memberTraits.httpHeader) {
                const key = String(memberTraits.httpHeader).toLowerCase();
                const value = response.headers[key];
                if (null != value) {
                    if (memberSchema.isListSchema()) {
                        const headerListValueSchema = memberSchema.getValueSchema();
                        headerListValueSchema.getMergedTraits().httpHeader = key;
                        let sections;
                        if (headerListValueSchema.isTimestampSchema() &&
                            headerListValueSchema.getSchema() === 4) {
                            sections = serde.splitEvery(value, ",", 2);
                        }
                        else {
                            sections = serde.splitHeader(value);
                        }
                        const list = [];
                        for (const section of sections) {
                            list.push(await deserializer.read(headerListValueSchema, section.trim()));
                        }
                        dataObject[memberName] = list;
                    }
                    else {
                        dataObject[memberName] = await deserializer.read(memberSchema, value);
                    }
                }
            }
            else if (memberTraits.httpPrefixHeaders !== undefined) {
                dataObject[memberName] = {};
                for (const [header, value] of Object.entries(response.headers)) {
                    if (header.startsWith(memberTraits.httpPrefixHeaders)) {
                        const valueSchema = memberSchema.getValueSchema();
                        valueSchema.getMergedTraits().httpHeader = header;
                        dataObject[memberName][header.slice(memberTraits.httpPrefixHeaders.length)] = await deserializer.read(valueSchema, value);
                    }
                }
            }
            else if (memberTraits.httpResponseCode) {
                dataObject[memberName] = response.statusCode;
            }
            else {
                nonHttpBindingMembers.push(memberName);
            }
        }
        nonHttpBindingMembers.discardResponseBody = discardResponseBody;
        return nonHttpBindingMembers;
    }
}

class RpcProtocol extends HttpProtocol {
    async serializeRequest(operationSchema, input, context) {
        const serializer = this.serializer;
        const query = {};
        const headers = {};
        const endpoint = await context.endpoint();
        const ns = schema.NormalizedSchema.of(operationSchema?.input);
        const schema$1 = ns.getSchema();
        let payload;
        const request = new protocolHttp.HttpRequest({
            protocol: "",
            hostname: "",
            port: undefined,
            path: "/",
            fragment: undefined,
            query: query,
            headers: headers,
            body: undefined,
        });
        if (endpoint) {
            this.updateServiceEndpoint(request, endpoint);
            this.setHostPrefix(request, operationSchema, input);
        }
        const _input = {
            ...input,
        };
        if (input) {
            const eventStreamMember = ns.getEventStreamMember();
            if (eventStreamMember) {
                if (_input[eventStreamMember]) {
                    const initialRequest = {};
                    for (const [memberName, memberSchema] of ns.structIterator()) {
                        if (memberName !== eventStreamMember && _input[memberName]) {
                            serializer.write(memberSchema, _input[memberName]);
                            initialRequest[memberName] = serializer.flush();
                        }
                    }
                    payload = await this.serializeEventStream({
                        eventStream: _input[eventStreamMember],
                        requestSchema: ns,
                        initialRequest,
                    });
                }
            }
            else {
                serializer.write(schema$1, _input);
                payload = serializer.flush();
            }
        }
        request.headers = headers;
        request.query = query;
        request.body = payload;
        request.method = "POST";
        return request;
    }
    async deserializeResponse(operationSchema, context, response) {
        const deserializer = this.deserializer;
        const ns = schema.NormalizedSchema.of(operationSchema.output);
        const dataObject = {};
        if (response.statusCode >= 300) {
            const bytes = await collectBody(response.body, context);
            if (bytes.byteLength > 0) {
                Object.assign(dataObject, await deserializer.read(15, bytes));
            }
            await this.handleError(operationSchema, context, response, dataObject, this.deserializeMetadata(response));
            throw new Error("@smithy/core/protocols - RPC Protocol error handler failed to throw.");
        }
        for (const header in response.headers) {
            const value = response.headers[header];
            delete response.headers[header];
            response.headers[header.toLowerCase()] = value;
        }
        const eventStreamMember = ns.getEventStreamMember();
        if (eventStreamMember) {
            dataObject[eventStreamMember] = await this.deserializeEventStream({
                response,
                responseSchema: ns,
                initialResponseContainer: dataObject,
            });
        }
        else {
            const bytes = await collectBody(response.body, context);
            if (bytes.byteLength > 0) {
                Object.assign(dataObject, await deserializer.read(ns, bytes));
            }
        }
        dataObject.$metadata = this.deserializeMetadata(response);
        return dataObject;
    }
}

const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel) => {
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel
            ? labelValue
                .split("/")
                .map((segment) => extendedEncodeURIComponent(segment))
                .join("/")
            : extendedEncodeURIComponent(labelValue));
    }
    else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};

function requestBuilder(input, context) {
    return new RequestBuilder(input, context);
}
class RequestBuilder {
    input;
    context;
    query = {};
    method = "";
    headers = {};
    path = "";
    body = null;
    hostname = "";
    resolvePathStack = [];
    constructor(input, context) {
        this.input = input;
        this.context = context;
    }
    async build() {
        const { hostname, protocol = "https", port, path: basePath } = await this.context.endpoint();
        this.path = basePath;
        for (const resolvePath of this.resolvePathStack) {
            resolvePath(this.path);
        }
        return new protocolHttp.HttpRequest({
            protocol,
            hostname: this.hostname || hostname,
            port,
            method: this.method,
            path: this.path,
            query: this.query,
            body: this.body,
            headers: this.headers,
        });
    }
    hn(hostname) {
        this.hostname = hostname;
        return this;
    }
    bp(uriLabel) {
        this.resolvePathStack.push((basePath) => {
            this.path = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + uriLabel;
        });
        return this;
    }
    p(memberName, labelValueProvider, uriLabel, isGreedyLabel) {
        this.resolvePathStack.push((path) => {
            this.path = resolvedPath(path, this.input, memberName, labelValueProvider, uriLabel, isGreedyLabel);
        });
        return this;
    }
    h(headers) {
        this.headers = headers;
        return this;
    }
    q(query) {
        this.query = query;
        return this;
    }
    b(body) {
        this.body = body;
        return this;
    }
    m(method) {
        this.method = method;
        return this;
    }
}

function determineTimestampFormat(ns, settings) {
    if (settings.timestampFormat.useTrait) {
        if (ns.isTimestampSchema() &&
            (ns.getSchema() === 5 ||
                ns.getSchema() === 6 ||
                ns.getSchema() === 7)) {
            return ns.getSchema();
        }
    }
    const { httpLabel, httpPrefixHeaders, httpHeader, httpQuery } = ns.getMergedTraits();
    const bindingFormat = settings.httpBindings
        ? typeof httpPrefixHeaders === "string" || Boolean(httpHeader)
            ? 6
            : Boolean(httpQuery) || Boolean(httpLabel)
                ? 5
                : undefined
        : undefined;
    return bindingFormat ?? settings.timestampFormat.default;
}

class FromStringShapeDeserializer extends SerdeContext {
    settings;
    constructor(settings) {
        super();
        this.settings = settings;
    }
    read(_schema, data) {
        const ns = schema.NormalizedSchema.of(_schema);
        if (ns.isListSchema()) {
            return serde.splitHeader(data).map((item) => this.read(ns.getValueSchema(), item));
        }
        if (ns.isBlobSchema()) {
            return (this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(data);
        }
        if (ns.isTimestampSchema()) {
            const format = determineTimestampFormat(ns, this.settings);
            switch (format) {
                case 5:
                    return serde._parseRfc3339DateTimeWithOffset(data);
                case 6:
                    return serde._parseRfc7231DateTime(data);
                case 7:
                    return serde._parseEpochTimestamp(data);
                default:
                    console.warn("Missing timestamp format, parsing value with Date constructor:", data);
                    return new Date(data);
            }
        }
        if (ns.isStringSchema()) {
            const mediaType = ns.getMergedTraits().mediaType;
            let intermediateValue = data;
            if (mediaType) {
                if (ns.getMergedTraits().httpHeader) {
                    intermediateValue = this.base64ToUtf8(intermediateValue);
                }
                const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
                if (isJson) {
                    intermediateValue = serde.LazyJsonString.from(intermediateValue);
                }
                return intermediateValue;
            }
        }
        if (ns.isNumericSchema()) {
            return Number(data);
        }
        if (ns.isBigIntegerSchema()) {
            return BigInt(data);
        }
        if (ns.isBigDecimalSchema()) {
            return new serde.NumericValue(data, "bigDecimal");
        }
        if (ns.isBooleanSchema()) {
            return String(data).toLowerCase() === "true";
        }
        return data;
    }
    base64ToUtf8(base64String) {
        return (this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8)((this.serdeContext?.base64Decoder ?? utilBase64.fromBase64)(base64String));
    }
}

class HttpInterceptingShapeDeserializer extends SerdeContext {
    codecDeserializer;
    stringDeserializer;
    constructor(codecDeserializer, codecSettings) {
        super();
        this.codecDeserializer = codecDeserializer;
        this.stringDeserializer = new FromStringShapeDeserializer(codecSettings);
    }
    setSerdeContext(serdeContext) {
        this.stringDeserializer.setSerdeContext(serdeContext);
        this.codecDeserializer.setSerdeContext(serdeContext);
        this.serdeContext = serdeContext;
    }
    read(schema$1, data) {
        const ns = schema.NormalizedSchema.of(schema$1);
        const traits = ns.getMergedTraits();
        const toString = this.serdeContext?.utf8Encoder ?? utilUtf8.toUtf8;
        if (traits.httpHeader || traits.httpResponseCode) {
            return this.stringDeserializer.read(ns, toString(data));
        }
        if (traits.httpPayload) {
            if (ns.isBlobSchema()) {
                const toBytes = this.serdeContext?.utf8Decoder ?? utilUtf8.fromUtf8;
                if (typeof data === "string") {
                    return toBytes(data);
                }
                return data;
            }
            else if (ns.isStringSchema()) {
                if ("byteLength" in data) {
                    return toString(data);
                }
                return data;
            }
        }
        return this.codecDeserializer.read(ns, data);
    }
}

class ToStringShapeSerializer extends SerdeContext {
    settings;
    stringBuffer = "";
    constructor(settings) {
        super();
        this.settings = settings;
    }
    write(schema$1, value) {
        const ns = schema.NormalizedSchema.of(schema$1);
        switch (typeof value) {
            case "object":
                if (value === null) {
                    this.stringBuffer = "null";
                    return;
                }
                if (ns.isTimestampSchema()) {
                    if (!(value instanceof Date)) {
                        throw new Error(`@smithy/core/protocols - received non-Date value ${value} when schema expected Date in ${ns.getName(true)}`);
                    }
                    const format = determineTimestampFormat(ns, this.settings);
                    switch (format) {
                        case 5:
                            this.stringBuffer = value.toISOString().replace(".000Z", "Z");
                            break;
                        case 6:
                            this.stringBuffer = serde.dateToUtcString(value);
                            break;
                        case 7:
                            this.stringBuffer = String(value.getTime() / 1000);
                            break;
                        default:
                            console.warn("Missing timestamp format, using epoch seconds", value);
                            this.stringBuffer = String(value.getTime() / 1000);
                    }
                    return;
                }
                if (ns.isBlobSchema() && "byteLength" in value) {
                    this.stringBuffer = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(value);
                    return;
                }
                if (ns.isListSchema() && Array.isArray(value)) {
                    let buffer = "";
                    for (const item of value) {
                        this.write([ns.getValueSchema(), ns.getMergedTraits()], item);
                        const headerItem = this.flush();
                        const serialized = ns.getValueSchema().isTimestampSchema() ? headerItem : serde.quoteHeader(headerItem);
                        if (buffer !== "") {
                            buffer += ", ";
                        }
                        buffer += serialized;
                    }
                    this.stringBuffer = buffer;
                    return;
                }
                this.stringBuffer = JSON.stringify(value, null, 2);
                break;
            case "string":
                const mediaType = ns.getMergedTraits().mediaType;
                let intermediateValue = value;
                if (mediaType) {
                    const isJson = mediaType === "application/json" || mediaType.endsWith("+json");
                    if (isJson) {
                        intermediateValue = serde.LazyJsonString.from(intermediateValue);
                    }
                    if (ns.getMergedTraits().httpHeader) {
                        this.stringBuffer = (this.serdeContext?.base64Encoder ?? utilBase64.toBase64)(intermediateValue.toString());
                        return;
                    }
                }
                this.stringBuffer = value;
                break;
            default:
                if (ns.isIdempotencyToken()) {
                    this.stringBuffer = serde.generateIdempotencyToken();
                }
                else {
                    this.stringBuffer = String(value);
                }
        }
    }
    flush() {
        const buffer = this.stringBuffer;
        this.stringBuffer = "";
        return buffer;
    }
}

class HttpInterceptingShapeSerializer {
    codecSerializer;
    stringSerializer;
    buffer;
    constructor(codecSerializer, codecSettings, stringSerializer = new ToStringShapeSerializer(codecSettings)) {
        this.codecSerializer = codecSerializer;
        this.stringSerializer = stringSerializer;
    }
    setSerdeContext(serdeContext) {
        this.codecSerializer.setSerdeContext(serdeContext);
        this.stringSerializer.setSerdeContext(serdeContext);
    }
    write(schema$1, value) {
        const ns = schema.NormalizedSchema.of(schema$1);
        const traits = ns.getMergedTraits();
        if (traits.httpHeader || traits.httpLabel || traits.httpQuery) {
            this.stringSerializer.write(ns, value);
            this.buffer = this.stringSerializer.flush();
            return;
        }
        return this.codecSerializer.write(ns, value);
    }
    flush() {
        if (this.buffer !== undefined) {
            const buffer = this.buffer;
            this.buffer = undefined;
            return buffer;
        }
        return this.codecSerializer.flush();
    }
}

exports.FromStringShapeDeserializer = FromStringShapeDeserializer;
exports.HttpBindingProtocol = HttpBindingProtocol;
exports.HttpInterceptingShapeDeserializer = HttpInterceptingShapeDeserializer;
exports.HttpInterceptingShapeSerializer = HttpInterceptingShapeSerializer;
exports.HttpProtocol = HttpProtocol;
exports.RequestBuilder = RequestBuilder;
exports.RpcProtocol = RpcProtocol;
exports.SerdeContext = SerdeContext;
exports.ToStringShapeSerializer = ToStringShapeSerializer;
exports.collectBody = collectBody;
exports.determineTimestampFormat = determineTimestampFormat;
exports.extendedEncodeURIComponent = extendedEncodeURIComponent;
exports.requestBuilder = requestBuilder;
exports.resolvedPath = resolvedPath;


/***/ }),

/***/ 9826:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var protocolHttp = __nccwpck_require__(4418);
var utilMiddleware = __nccwpck_require__(2390);

const deref = (schemaRef) => {
    if (typeof schemaRef === "function") {
        return schemaRef();
    }
    return schemaRef;
};

const operation = (namespace, name, traits, input, output) => ({
    name,
    namespace,
    traits,
    input,
    output,
});

const schemaDeserializationMiddleware = (config) => (next, context) => async (args) => {
    const { response } = await next(args);
    const { operationSchema } = utilMiddleware.getSmithyContext(context);
    const [, ns, n, t, i, o] = operationSchema ?? [];
    try {
        const parsed = await config.protocol.deserializeResponse(operation(ns, n, t, i, o), {
            ...config,
            ...context,
        }, response);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
            enumerable: false,
            writable: false,
            configurable: false,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            try {
                error.message += "\n  " + hint;
            }
            catch (e) {
                if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
                    console.warn(hint);
                }
                else {
                    context.logger?.warn?.(hint);
                }
            }
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
            try {
                if (protocolHttp.HttpResponse.isInstance(response)) {
                    const { headers = {} } = response;
                    const headerEntries = Object.entries(headers);
                    error.$metadata = {
                        httpStatusCode: response.statusCode,
                        requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
                        extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
                        cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries),
                    };
                }
            }
            catch (e) {
            }
        }
        throw error;
    }
};
const findHeader = (pattern, headers) => {
    return (headers.find(([k]) => {
        return k.match(pattern);
    }) || [void 0, void 0])[1];
};

const schemaSerializationMiddleware = (config) => (next, context) => async (args) => {
    const { operationSchema } = utilMiddleware.getSmithyContext(context);
    const [, ns, n, t, i, o] = operationSchema ?? [];
    const endpoint = context.endpointV2?.url && config.urlParser
        ? async () => config.urlParser(context.endpointV2.url)
        : config.endpoint;
    const request = await config.protocol.serializeRequest(operation(ns, n, t, i, o), args.input, {
        ...config,
        ...context,
        endpoint,
    });
    return next({
        ...args,
        request,
    });
};

const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSchemaSerdePlugin(config) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(schemaSerializationMiddleware(config), serializerMiddlewareOption);
            commandStack.add(schemaDeserializationMiddleware(config), deserializerMiddlewareOption);
            config.protocol.setSerdeContext(config);
        },
    };
}

class Schema {
    name;
    namespace;
    traits;
    static assign(instance, values) {
        const schema = Object.assign(instance, values);
        return schema;
    }
    static [Symbol.hasInstance](lhs) {
        const isPrototype = this.prototype.isPrototypeOf(lhs);
        if (!isPrototype && typeof lhs === "object" && lhs !== null) {
            const list = lhs;
            return list.symbol === this.symbol;
        }
        return isPrototype;
    }
    getName() {
        return this.namespace + "#" + this.name;
    }
}

class ListSchema extends Schema {
    static symbol = Symbol.for("@smithy/lis");
    name;
    traits;
    valueSchema;
    symbol = ListSchema.symbol;
}
const list = (namespace, name, traits, valueSchema) => Schema.assign(new ListSchema(), {
    name,
    namespace,
    traits,
    valueSchema,
});

class MapSchema extends Schema {
    static symbol = Symbol.for("@smithy/map");
    name;
    traits;
    keySchema;
    valueSchema;
    symbol = MapSchema.symbol;
}
const map = (namespace, name, traits, keySchema, valueSchema) => Schema.assign(new MapSchema(), {
    name,
    namespace,
    traits,
    keySchema,
    valueSchema,
});

class OperationSchema extends Schema {
    static symbol = Symbol.for("@smithy/ope");
    name;
    traits;
    input;
    output;
    symbol = OperationSchema.symbol;
}
const op = (namespace, name, traits, input, output) => Schema.assign(new OperationSchema(), {
    name,
    namespace,
    traits,
    input,
    output,
});

class StructureSchema extends Schema {
    static symbol = Symbol.for("@smithy/str");
    name;
    traits;
    memberNames;
    memberList;
    symbol = StructureSchema.symbol;
}
const struct = (namespace, name, traits, memberNames, memberList) => Schema.assign(new StructureSchema(), {
    name,
    namespace,
    traits,
    memberNames,
    memberList,
});

class ErrorSchema extends StructureSchema {
    static symbol = Symbol.for("@smithy/err");
    ctor;
    symbol = ErrorSchema.symbol;
}
const error = (namespace, name, traits, memberNames, memberList, ctor) => Schema.assign(new ErrorSchema(), {
    name,
    namespace,
    traits,
    memberNames,
    memberList,
    ctor: null,
});

function translateTraits(indicator) {
    if (typeof indicator === "object") {
        return indicator;
    }
    indicator = indicator | 0;
    const traits = {};
    let i = 0;
    for (const trait of [
        "httpLabel",
        "idempotent",
        "idempotencyToken",
        "sensitive",
        "httpPayload",
        "httpResponseCode",
        "httpQueryParams",
    ]) {
        if (((indicator >> i++) & 1) === 1) {
            traits[trait] = 1;
        }
    }
    return traits;
}

const anno = {
    it: Symbol.for("@smithy/nor-struct-it"),
};
class NormalizedSchema {
    ref;
    memberName;
    static symbol = Symbol.for("@smithy/nor");
    symbol = NormalizedSchema.symbol;
    name;
    schema;
    _isMemberSchema;
    traits;
    memberTraits;
    normalizedTraits;
    constructor(ref, memberName) {
        this.ref = ref;
        this.memberName = memberName;
        const traitStack = [];
        let _ref = ref;
        let schema = ref;
        this._isMemberSchema = false;
        while (isMemberSchema(_ref)) {
            traitStack.push(_ref[1]);
            _ref = _ref[0];
            schema = deref(_ref);
            this._isMemberSchema = true;
        }
        if (traitStack.length > 0) {
            this.memberTraits = {};
            for (let i = traitStack.length - 1; i >= 0; --i) {
                const traitSet = traitStack[i];
                Object.assign(this.memberTraits, translateTraits(traitSet));
            }
        }
        else {
            this.memberTraits = 0;
        }
        if (schema instanceof NormalizedSchema) {
            const computedMemberTraits = this.memberTraits;
            Object.assign(this, schema);
            this.memberTraits = Object.assign({}, computedMemberTraits, schema.getMemberTraits(), this.getMemberTraits());
            this.normalizedTraits = void 0;
            this.memberName = memberName ?? schema.memberName;
            return;
        }
        this.schema = deref(schema);
        if (isStaticSchema(this.schema)) {
            this.name = `${this.schema[1]}#${this.schema[2]}`;
            this.traits = this.schema[3];
        }
        else {
            this.name = this.memberName ?? String(schema);
            this.traits = 0;
        }
        if (this._isMemberSchema && !memberName) {
            throw new Error(`@smithy/core/schema - NormalizedSchema member init ${this.getName(true)} missing member name.`);
        }
    }
    static [Symbol.hasInstance](lhs) {
        const isPrototype = this.prototype.isPrototypeOf(lhs);
        if (!isPrototype && typeof lhs === "object" && lhs !== null) {
            const ns = lhs;
            return ns.symbol === this.symbol;
        }
        return isPrototype;
    }
    static of(ref) {
        const sc = deref(ref);
        if (sc instanceof NormalizedSchema) {
            return sc;
        }
        if (isMemberSchema(sc)) {
            const [ns, traits] = sc;
            if (ns instanceof NormalizedSchema) {
                Object.assign(ns.getMergedTraits(), translateTraits(traits));
                return ns;
            }
            throw new Error(`@smithy/core/schema - may not init unwrapped member schema=${JSON.stringify(ref, null, 2)}.`);
        }
        return new NormalizedSchema(sc);
    }
    getSchema() {
        const sc = this.schema;
        if (sc[0] === 0) {
            return sc[4];
        }
        return sc;
    }
    getName(withNamespace = false) {
        const { name } = this;
        const short = !withNamespace && name && name.includes("#");
        return short ? name.split("#")[1] : name || undefined;
    }
    getMemberName() {
        return this.memberName;
    }
    isMemberSchema() {
        return this._isMemberSchema;
    }
    isListSchema() {
        const sc = this.getSchema();
        return typeof sc === "number"
            ? sc >= 64 && sc < 128
            : sc[0] === 1;
    }
    isMapSchema() {
        const sc = this.getSchema();
        return typeof sc === "number"
            ? sc >= 128 && sc <= 0b1111_1111
            : sc[0] === 2;
    }
    isStructSchema() {
        const sc = this.getSchema();
        const id = sc[0];
        return (id === 3 ||
            id === -3 ||
            id === 4);
    }
    isUnionSchema() {
        const sc = this.getSchema();
        return sc[0] === 4;
    }
    isBlobSchema() {
        const sc = this.getSchema();
        return sc === 21 || sc === 42;
    }
    isTimestampSchema() {
        const sc = this.getSchema();
        return (typeof sc === "number" &&
            sc >= 4 &&
            sc <= 7);
    }
    isUnitSchema() {
        return this.getSchema() === "unit";
    }
    isDocumentSchema() {
        return this.getSchema() === 15;
    }
    isStringSchema() {
        return this.getSchema() === 0;
    }
    isBooleanSchema() {
        return this.getSchema() === 2;
    }
    isNumericSchema() {
        return this.getSchema() === 1;
    }
    isBigIntegerSchema() {
        return this.getSchema() === 17;
    }
    isBigDecimalSchema() {
        return this.getSchema() === 19;
    }
    isStreaming() {
        const { streaming } = this.getMergedTraits();
        return !!streaming || this.getSchema() === 42;
    }
    isIdempotencyToken() {
        return !!this.getMergedTraits().idempotencyToken;
    }
    getMergedTraits() {
        return (this.normalizedTraits ??
            (this.normalizedTraits = {
                ...this.getOwnTraits(),
                ...this.getMemberTraits(),
            }));
    }
    getMemberTraits() {
        return translateTraits(this.memberTraits);
    }
    getOwnTraits() {
        return translateTraits(this.traits);
    }
    getKeySchema() {
        const [isDoc, isMap] = [this.isDocumentSchema(), this.isMapSchema()];
        if (!isDoc && !isMap) {
            throw new Error(`@smithy/core/schema - cannot get key for non-map: ${this.getName(true)}`);
        }
        const schema = this.getSchema();
        const memberSchema = isDoc
            ? 15
            : schema[4] ?? 0;
        return member([memberSchema, 0], "key");
    }
    getValueSchema() {
        const sc = this.getSchema();
        const [isDoc, isMap, isList] = [this.isDocumentSchema(), this.isMapSchema(), this.isListSchema()];
        const memberSchema = typeof sc === "number"
            ? 0b0011_1111 & sc
            : sc && typeof sc === "object" && (isMap || isList)
                ? sc[3 + sc[0]]
                : isDoc
                    ? 15
                    : void 0;
        if (memberSchema != null) {
            return member([memberSchema, 0], isMap ? "value" : "member");
        }
        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no value member.`);
    }
    getMemberSchema(memberName) {
        const struct = this.getSchema();
        if (this.isStructSchema() && struct[4].includes(memberName)) {
            const i = struct[4].indexOf(memberName);
            const memberSchema = struct[5][i];
            return member(isMemberSchema(memberSchema) ? memberSchema : [memberSchema, 0], memberName);
        }
        if (this.isDocumentSchema()) {
            return member([15, 0], memberName);
        }
        throw new Error(`@smithy/core/schema - ${this.getName(true)} has no no member=${memberName}.`);
    }
    getMemberSchemas() {
        const buffer = {};
        try {
            for (const [k, v] of this.structIterator()) {
                buffer[k] = v;
            }
        }
        catch (ignored) { }
        return buffer;
    }
    getEventStreamMember() {
        if (this.isStructSchema()) {
            for (const [memberName, memberSchema] of this.structIterator()) {
                if (memberSchema.isStreaming() && memberSchema.isStructSchema()) {
                    return memberName;
                }
            }
        }
        return "";
    }
    *structIterator() {
        if (this.isUnitSchema()) {
            return;
        }
        if (!this.isStructSchema()) {
            throw new Error("@smithy/core/schema - cannot iterate non-struct schema.");
        }
        const struct = this.getSchema();
        const z = struct[4].length;
        let it = struct[anno.it];
        if (it && z === it.length) {
            yield* it;
            return;
        }
        it = Array(z);
        for (let i = 0; i < z; ++i) {
            const k = struct[4][i];
            const v = member([struct[5][i], 0], k);
            yield (it[i] = [k, v]);
        }
        struct[anno.it] = it;
    }
}
function member(memberSchema, memberName) {
    if (memberSchema instanceof NormalizedSchema) {
        return Object.assign(memberSchema, {
            memberName,
            _isMemberSchema: true,
        });
    }
    const internalCtorAccess = NormalizedSchema;
    return new internalCtorAccess(memberSchema, memberName);
}
const isMemberSchema = (sc) => Array.isArray(sc) && sc.length === 2;
const isStaticSchema = (sc) => Array.isArray(sc) && sc.length >= 5;

class SimpleSchema extends Schema {
    static symbol = Symbol.for("@smithy/sim");
    name;
    schemaRef;
    traits;
    symbol = SimpleSchema.symbol;
}
const sim = (namespace, name, schemaRef, traits) => Schema.assign(new SimpleSchema(), {
    name,
    namespace,
    traits,
    schemaRef,
});
const simAdapter = (namespace, name, traits, schemaRef) => Schema.assign(new SimpleSchema(), {
    name,
    namespace,
    traits,
    schemaRef,
});

const SCHEMA = {
    BLOB: 0b0001_0101,
    STREAMING_BLOB: 0b0010_1010,
    BOOLEAN: 0b0000_0010,
    STRING: 0b0000_0000,
    NUMERIC: 0b0000_0001,
    BIG_INTEGER: 0b0001_0001,
    BIG_DECIMAL: 0b0001_0011,
    DOCUMENT: 0b0000_1111,
    TIMESTAMP_DEFAULT: 0b0000_0100,
    TIMESTAMP_DATE_TIME: 0b0000_0101,
    TIMESTAMP_HTTP_DATE: 0b0000_0110,
    TIMESTAMP_EPOCH_SECONDS: 0b0000_0111,
    LIST_MODIFIER: 0b0100_0000,
    MAP_MODIFIER: 0b1000_0000,
};

class TypeRegistry {
    namespace;
    schemas;
    exceptions;
    static registries = new Map();
    constructor(namespace, schemas = new Map(), exceptions = new Map()) {
        this.namespace = namespace;
        this.schemas = schemas;
        this.exceptions = exceptions;
    }
    static for(namespace) {
        if (!TypeRegistry.registries.has(namespace)) {
            TypeRegistry.registries.set(namespace, new TypeRegistry(namespace));
        }
        return TypeRegistry.registries.get(namespace);
    }
    register(shapeId, schema) {
        const qualifiedName = this.normalizeShapeId(shapeId);
        const registry = TypeRegistry.for(qualifiedName.split("#")[0]);
        registry.schemas.set(qualifiedName, schema);
    }
    getSchema(shapeId) {
        const id = this.normalizeShapeId(shapeId);
        if (!this.schemas.has(id)) {
            throw new Error(`@smithy/core/schema - schema not found for ${id}`);
        }
        return this.schemas.get(id);
    }
    registerError(es, ctor) {
        const $error = es;
        const registry = TypeRegistry.for($error[1]);
        registry.schemas.set($error[1] + "#" + $error[2], $error);
        registry.exceptions.set($error, ctor);
    }
    getErrorCtor(es) {
        const $error = es;
        const registry = TypeRegistry.for($error[1]);
        return registry.exceptions.get($error);
    }
    getBaseException() {
        for (const exceptionKey of this.exceptions.keys()) {
            if (Array.isArray(exceptionKey)) {
                const [, ns, name] = exceptionKey;
                const id = ns + "#" + name;
                if (id.startsWith("smithy.ts.sdk.synthetic.") && id.endsWith("ServiceException")) {
                    return exceptionKey;
                }
            }
        }
        return undefined;
    }
    find(predicate) {
        return [...this.schemas.values()].find(predicate);
    }
    clear() {
        this.schemas.clear();
        this.exceptions.clear();
    }
    normalizeShapeId(shapeId) {
        if (shapeId.includes("#")) {
            return shapeId;
        }
        return this.namespace + "#" + shapeId;
    }
}

exports.ErrorSchema = ErrorSchema;
exports.ListSchema = ListSchema;
exports.MapSchema = MapSchema;
exports.NormalizedSchema = NormalizedSchema;
exports.OperationSchema = OperationSchema;
exports.SCHEMA = SCHEMA;
exports.Schema = Schema;
exports.SimpleSchema = SimpleSchema;
exports.StructureSchema = StructureSchema;
exports.TypeRegistry = TypeRegistry;
exports.deref = deref;
exports.deserializerMiddlewareOption = deserializerMiddlewareOption;
exports.error = error;
exports.getSchemaSerdePlugin = getSchemaSerdePlugin;
exports.isStaticSchema = isStaticSchema;
exports.list = list;
exports.map = map;
exports.op = op;
exports.operation = operation;
exports.serializerMiddlewareOption = serializerMiddlewareOption;
exports.sim = sim;
exports.simAdapter = simAdapter;
exports.struct = struct;
exports.translateTraits = translateTraits;


/***/ }),

/***/ 7669:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var uuid = __nccwpck_require__(3634);

const copyDocumentWithTransform = (source, schemaRef, transform = (_) => _) => source;

const parseBoolean = (value) => {
    switch (value) {
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
const expectBoolean = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
const expectNumber = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value) => {
    const expected = expectNumber(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
const expectLong = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
const expectInt = expectLong;
const expectInt32 = (value) => expectSizedInt(value, 32);
const expectShort = (value) => expectSizedInt(value, 16);
const expectByte = (value) => expectSizedInt(value, 8);
const expectSizedInt = (value, size) => {
    const expected = expectLong(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size) => {
    switch (size) {
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location) => {
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
const expectObject = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
const expectString = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if (["boolean", "number", "bigint"].includes(typeof value)) {
        logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
const expectUnion = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = expectObject(value);
    const setKeys = Object.entries(asObject)
        .filter(([, v]) => v != null)
        .map(([k]) => k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
const strictParseDouble = (value) => {
    if (typeof value == "string") {
        return expectNumber(parseNumber(value));
    }
    return expectNumber(value);
};
const strictParseFloat = strictParseDouble;
const strictParseFloat32 = (value) => {
    if (typeof value == "string") {
        return expectFloat32(parseNumber(value));
    }
    return expectFloat32(value);
};
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value) => {
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectNumber(value);
};
const handleFloat = limitedParseDouble;
const limitedParseFloat = limitedParseDouble;
const limitedParseFloat32 = (value) => {
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return expectFloat32(value);
};
const parseFloatString = (value) => {
    switch (value) {
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value) => {
    if (typeof value === "string") {
        return expectLong(parseNumber(value));
    }
    return expectLong(value);
};
const strictParseInt = strictParseLong;
const strictParseInt32 = (value) => {
    if (typeof value === "string") {
        return expectInt32(parseNumber(value));
    }
    return expectInt32(value);
};
const strictParseShort = (value) => {
    if (typeof value === "string") {
        return expectShort(parseNumber(value));
    }
    return expectShort(value);
};
const strictParseByte = (value) => {
    if (typeof value === "string") {
        return expectByte(parseNumber(value));
    }
    return expectByte(value);
};
const stackTraceWarning = (message) => {
    return String(new TypeError(message).stack || message)
        .split("\n")
        .slice(0, 5)
        .filter((s) => !s.includes("stackTraceWarning"))
        .join("\n");
};
const logger = {
    warn: console.warn,
};

const DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
};
const RFC3339_WITH_OFFSET$1 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET$1.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = strictParseShort(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, { hours, minutes, seconds, fractionalMilliseconds });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
const IMF_FIXDATE$1 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const RFC_850_DATE$1 = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const ASC_TIME$1 = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
const parseRfc7231DateTime = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE$1.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    match = RFC_850_DATE$1.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds,
        }));
    }
    match = ASC_TIME$1.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate(strictParseShort(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), { hours, minutes, seconds, fractionalMilliseconds });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
const parseEpochTimestamp = (value) => {
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    }
    else if (typeof value === "string") {
        valueAsDouble = strictParseDouble(value);
    }
    else if (typeof value === "object" && value.tag === 1) {
        valueAsDouble = value.value;
    }
    else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
const buildDate = (year, month, day, time) => {
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value) => {
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + strictParseShort(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
const adjustRfc850Year = (input) => {
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value) => {
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const validateDayOfMonth = (year, month, day) => {
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year) => {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper) => {
    const dateVal = strictParseByte(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value) => {
    if (value === null || value === undefined) {
        return 0;
    }
    return strictParseFloat32("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value) => {
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    }
    else if (directionStr == "-") {
        direction = -1;
    }
    else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value) => {
    let idx = 0;
    while (idx < value.length - 1 && value.charAt(idx) === "0") {
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};

const LazyJsonString = function LazyJsonString(val) {
    const str = Object.assign(new String(val), {
        deserializeJSON() {
            return JSON.parse(String(val));
        },
        toString() {
            return String(val);
        },
        toJSON() {
            return String(val);
        },
    });
    return str;
};
LazyJsonString.from = (object) => {
    if (object && typeof object === "object" && (object instanceof LazyJsonString || "deserializeJSON" in object)) {
        return object;
    }
    else if (typeof object === "string" || Object.getPrototypeOf(object) === String.prototype) {
        return LazyJsonString(String(object));
    }
    return LazyJsonString(JSON.stringify(object));
};
LazyJsonString.fromObject = LazyJsonString.from;

function quoteHeader(part) {
    if (part.includes(",") || part.includes('"')) {
        part = `"${part.replace(/"/g, '\\"')}"`;
    }
    return part;
}

const ddd = `(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun)(?:[ne|u?r]?s?day)?`;
const mmm = `(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)`;
const time = `(\\d?\\d):(\\d{2}):(\\d{2})(?:\\.(\\d+))?`;
const date = `(\\d?\\d)`;
const year = `(\\d{4})`;
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d\d)-(\d\d)[tT](\d\d):(\d\d):(\d\d)(\.(\d+))?(([-+]\d\d:\d\d)|[zZ])$/);
const IMF_FIXDATE = new RegExp(`^${ddd}, ${date} ${mmm} ${year} ${time} GMT$`);
const RFC_850_DATE = new RegExp(`^${ddd}, ${date}-${mmm}-(\\d\\d) ${time} GMT$`);
const ASC_TIME = new RegExp(`^${ddd} ${mmm} ( [1-9]|\\d\\d) ${time} ${year}$`);
const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const _parseEpochTimestamp = (value) => {
    if (value == null) {
        return void 0;
    }
    let num = NaN;
    if (typeof value === "number") {
        num = value;
    }
    else if (typeof value === "string") {
        if (!/^-?\d*\.?\d+$/.test(value)) {
            throw new TypeError(`parseEpochTimestamp - numeric string invalid.`);
        }
        num = Number.parseFloat(value);
    }
    else if (typeof value === "object" && value.tag === 1) {
        num = value.value;
    }
    if (isNaN(num) || Math.abs(num) === Infinity) {
        throw new TypeError("Epoch timestamps must be valid finite numbers.");
    }
    return new Date(Math.round(num * 1000));
};
const _parseRfc3339DateTimeWithOffset = (value) => {
    if (value == null) {
        return void 0;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC3339 timestamps must be strings");
    }
    const matches = RFC3339_WITH_OFFSET.exec(value);
    if (!matches) {
        throw new TypeError(`Invalid RFC3339 timestamp format ${value}`);
    }
    const [, yearStr, monthStr, dayStr, hours, minutes, seconds, , ms, offsetStr] = matches;
    range(monthStr, 1, 12);
    range(dayStr, 1, 31);
    range(hours, 0, 23);
    range(minutes, 0, 59);
    range(seconds, 0, 60);
    const date = new Date(Date.UTC(Number(yearStr), Number(monthStr) - 1, Number(dayStr), Number(hours), Number(minutes), Number(seconds), Number(ms) ? Math.round(parseFloat(`0.${ms}`) * 1000) : 0));
    date.setUTCFullYear(Number(yearStr));
    if (offsetStr.toUpperCase() != "Z") {
        const [, sign, offsetH, offsetM] = /([+-])(\d\d):(\d\d)/.exec(offsetStr) || [void 0, "+", 0, 0];
        const scalar = sign === "-" ? 1 : -1;
        date.setTime(date.getTime() + scalar * (Number(offsetH) * 60 * 60 * 1000 + Number(offsetM) * 60 * 1000));
    }
    return date;
};
const _parseRfc7231DateTime = (value) => {
    if (value == null) {
        return void 0;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC7231 timestamps must be strings.");
    }
    let day;
    let month;
    let year;
    let hour;
    let minute;
    let second;
    let fraction;
    let matches;
    if ((matches = IMF_FIXDATE.exec(value))) {
        [, day, month, year, hour, minute, second, fraction] = matches;
    }
    else if ((matches = RFC_850_DATE.exec(value))) {
        [, day, month, year, hour, minute, second, fraction] = matches;
        year = (Number(year) + 1900).toString();
    }
    else if ((matches = ASC_TIME.exec(value))) {
        [, month, day, hour, minute, second, fraction, year] = matches;
    }
    if (year && second) {
        const timestamp = Date.UTC(Number(year), months.indexOf(month), Number(day), Number(hour), Number(minute), Number(second), fraction ? Math.round(parseFloat(`0.${fraction}`) * 1000) : 0);
        range(day, 1, 31);
        range(hour, 0, 23);
        range(minute, 0, 59);
        range(second, 0, 60);
        const date = new Date(timestamp);
        date.setUTCFullYear(Number(year));
        return date;
    }
    throw new TypeError(`Invalid RFC7231 date-time value ${value}.`);
};
function range(v, min, max) {
    const _v = Number(v);
    if (_v < min || _v > max) {
        throw new Error(`Value ${_v} out of range [${min}, ${max}]`);
    }
}

function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
        throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
        return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for (let i = 0; i < segments.length; i++) {
        if (currentSegment === "") {
            currentSegment = segments[i];
        }
        else {
            currentSegment += delimiter + segments[i];
        }
        if ((i + 1) % numDelimiters === 0) {
            compoundSegments.push(currentSegment);
            currentSegment = "";
        }
    }
    if (currentSegment !== "") {
        compoundSegments.push(currentSegment);
    }
    return compoundSegments;
}

const splitHeader = (value) => {
    const z = value.length;
    const values = [];
    let withinQuotes = false;
    let prevChar = undefined;
    let anchor = 0;
    for (let i = 0; i < z; ++i) {
        const char = value[i];
        switch (char) {
            case `"`:
                if (prevChar !== "\\") {
                    withinQuotes = !withinQuotes;
                }
                break;
            case ",":
                if (!withinQuotes) {
                    values.push(value.slice(anchor, i));
                    anchor = i + 1;
                }
                break;
        }
        prevChar = char;
    }
    values.push(value.slice(anchor));
    return values.map((v) => {
        v = v.trim();
        const z = v.length;
        if (z < 2) {
            return v;
        }
        if (v[0] === `"` && v[z - 1] === `"`) {
            v = v.slice(1, z - 1);
        }
        return v.replace(/\\"/g, '"');
    });
};

const format = /^-?\d*(\.\d+)?$/;
class NumericValue {
    string;
    type;
    constructor(string, type) {
        this.string = string;
        this.type = type;
        if (!format.test(string)) {
            throw new Error(`@smithy/core/serde - NumericValue must only contain [0-9], at most one decimal point ".", and an optional negation prefix "-".`);
        }
    }
    toString() {
        return this.string;
    }
    static [Symbol.hasInstance](object) {
        if (!object || typeof object !== "object") {
            return false;
        }
        const _nv = object;
        return NumericValue.prototype.isPrototypeOf(object) || (_nv.type === "bigDecimal" && format.test(_nv.string));
    }
}
function nv(input) {
    return new NumericValue(String(input), "bigDecimal");
}

Object.defineProperty(exports, "generateIdempotencyToken", ({
    enumerable: true,
    get: function () { return uuid.v4; }
}));
exports.LazyJsonString = LazyJsonString;
exports.NumericValue = NumericValue;
exports._parseEpochTimestamp = _parseEpochTimestamp;
exports._parseRfc3339DateTimeWithOffset = _parseRfc3339DateTimeWithOffset;
exports._parseRfc7231DateTime = _parseRfc7231DateTime;
exports.copyDocumentWithTransform = copyDocumentWithTransform;
exports.dateToUtcString = dateToUtcString;
exports.expectBoolean = expectBoolean;
exports.expectByte = expectByte;
exports.expectFloat32 = expectFloat32;
exports.expectInt = expectInt;
exports.expectInt32 = expectInt32;
exports.expectLong = expectLong;
exports.expectNonNull = expectNonNull;
exports.expectNumber = expectNumber;
exports.expectObject = expectObject;
exports.expectShort = expectShort;
exports.expectString = expectString;
exports.expectUnion = expectUnion;
exports.handleFloat = handleFloat;
exports.limitedParseDouble = limitedParseDouble;
exports.limitedParseFloat = limitedParseFloat;
exports.limitedParseFloat32 = limitedParseFloat32;
exports.logger = logger;
exports.nv = nv;
exports.parseBoolean = parseBoolean;
exports.parseEpochTimestamp = parseEpochTimestamp;
exports.parseRfc3339DateTime = parseRfc3339DateTime;
exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
exports.parseRfc7231DateTime = parseRfc7231DateTime;
exports.quoteHeader = quoteHeader;
exports.splitEvery = splitEvery;
exports.splitHeader = splitHeader;
exports.strictParseByte = strictParseByte;
exports.strictParseDouble = strictParseDouble;
exports.strictParseFloat = strictParseFloat;
exports.strictParseFloat32 = strictParseFloat32;
exports.strictParseInt = strictParseInt;
exports.strictParseInt32 = strictParseInt32;
exports.strictParseLong = strictParseLong;
exports.strictParseShort = strictParseShort;


/***/ }),

/***/ 2687:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var protocolHttp = __nccwpck_require__(4418);
var querystringBuilder = __nccwpck_require__(8031);
var utilBase64 = __nccwpck_require__(5600);

function createRequest(url, requestOptions) {
    return new Request(url, requestOptions);
}

function requestTimeout(timeoutInMs = 0) {
    return new Promise((resolve, reject) => {
        if (timeoutInMs) {
            setTimeout(() => {
                const timeoutError = new Error(`Request did not complete within ${timeoutInMs} ms`);
                timeoutError.name = "TimeoutError";
                reject(timeoutError);
            }, timeoutInMs);
        }
    });
}

const keepAliveSupport = {
    supported: undefined,
};
class FetchHttpHandler {
    config;
    configProvider;
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new FetchHttpHandler(instanceOrOptions);
    }
    constructor(options) {
        if (typeof options === "function") {
            this.configProvider = options().then((opts) => opts || {});
        }
        else {
            this.config = options ?? {};
            this.configProvider = Promise.resolve(this.config);
        }
        if (keepAliveSupport.supported === undefined) {
            keepAliveSupport.supported = Boolean(typeof Request !== "undefined" && "keepalive" in createRequest("https://[::1]"));
        }
    }
    destroy() {
    }
    async handle(request, { abortSignal, requestTimeout: requestTimeout$1 } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        const requestTimeoutInMs = requestTimeout$1 ?? this.config.requestTimeout;
        const keepAlive = this.config.keepAlive === true;
        const credentials = this.config.credentials;
        if (abortSignal?.aborted) {
            const abortError = new Error("Request aborted");
            abortError.name = "AbortError";
            return Promise.reject(abortError);
        }
        let path = request.path;
        const queryString = querystringBuilder.buildQueryString(request.query || {});
        if (queryString) {
            path += `?${queryString}`;
        }
        if (request.fragment) {
            path += `#${request.fragment}`;
        }
        let auth = "";
        if (request.username != null || request.password != null) {
            const username = request.username ?? "";
            const password = request.password ?? "";
            auth = `${username}:${password}@`;
        }
        const { port, method } = request;
        const url = `${request.protocol}//${auth}${request.hostname}${port ? `:${port}` : ""}${path}`;
        const body = method === "GET" || method === "HEAD" ? undefined : request.body;
        const requestOptions = {
            body,
            headers: new Headers(request.headers),
            method: method,
            credentials,
        };
        if (this.config?.cache) {
            requestOptions.cache = this.config.cache;
        }
        if (body) {
            requestOptions.duplex = "half";
        }
        if (typeof AbortController !== "undefined") {
            requestOptions.signal = abortSignal;
        }
        if (keepAliveSupport.supported) {
            requestOptions.keepalive = keepAlive;
        }
        if (typeof this.config.requestInit === "function") {
            Object.assign(requestOptions, this.config.requestInit(request));
        }
        let removeSignalEventListener = () => { };
        const fetchRequest = createRequest(url, requestOptions);
        const raceOfPromises = [
            fetch(fetchRequest).then((response) => {
                const fetchHeaders = response.headers;
                const transformedHeaders = {};
                for (const pair of fetchHeaders.entries()) {
                    transformedHeaders[pair[0]] = pair[1];
                }
                const hasReadableStream = response.body != undefined;
                if (!hasReadableStream) {
                    return response.blob().then((body) => ({
                        response: new protocolHttp.HttpResponse({
                            headers: transformedHeaders,
                            reason: response.statusText,
                            statusCode: response.status,
                            body,
                        }),
                    }));
                }
                return {
                    response: new protocolHttp.HttpResponse({
                        headers: transformedHeaders,
                        reason: response.statusText,
                        statusCode: response.status,
                        body: response.body,
                    }),
                };
            }),
            requestTimeout(requestTimeoutInMs),
        ];
        if (abortSignal) {
            raceOfPromises.push(new Promise((resolve, reject) => {
                const onAbort = () => {
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
                if (typeof abortSignal.addEventListener === "function") {
                    const signal = abortSignal;
                    signal.addEventListener("abort", onAbort, { once: true });
                    removeSignalEventListener = () => signal.removeEventListener("abort", onAbort);
                }
                else {
                    abortSignal.onabort = onAbort;
                }
            }));
        }
        return Promise.race(raceOfPromises).finally(removeSignalEventListener);
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            config[key] = value;
            return config;
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

const streamCollector = async (stream) => {
    if ((typeof Blob === "function" && stream instanceof Blob) || stream.constructor?.name === "Blob") {
        if (Blob.prototype.arrayBuffer !== undefined) {
            return new Uint8Array(await stream.arrayBuffer());
        }
        return collectBlob(stream);
    }
    return collectStream(stream);
};
async function collectBlob(blob) {
    const base64 = await readToBase64(blob);
    const arrayBuffer = utilBase64.fromBase64(base64);
    return new Uint8Array(arrayBuffer);
}
async function collectStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}
function readToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
            if (reader.readyState !== 2) {
                return reject(new Error("Reader aborted too early"));
            }
            const result = (reader.result ?? "");
            const commaIndex = result.indexOf(",");
            const dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
            resolve(result.substring(dataOffset));
        };
        reader.onabort = () => reject(new Error("Read aborted"));
        reader.onerror = () => reject(reader.error);
        reader.readAsDataURL(blob);
    });
}

exports.FetchHttpHandler = FetchHttpHandler;
exports.keepAliveSupport = keepAliveSupport;
exports.streamCollector = streamCollector;


/***/ }),

/***/ 3081:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilBufferFrom = __nccwpck_require__(1381);
var utilUtf8 = __nccwpck_require__(1895);
var buffer = __nccwpck_require__(4300);
var crypto = __nccwpck_require__(6113);

class Hash {
    algorithmIdentifier;
    secret;
    hash;
    constructor(algorithmIdentifier, secret) {
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
    }
    update(toHash, encoding) {
        this.hash.update(utilUtf8.toUint8Array(castSourceData(toHash, encoding)));
    }
    digest() {
        return Promise.resolve(this.hash.digest());
    }
    reset() {
        this.hash = this.secret
            ? crypto.createHmac(this.algorithmIdentifier, castSourceData(this.secret))
            : crypto.createHash(this.algorithmIdentifier);
    }
}
function castSourceData(toCast, encoding) {
    if (buffer.Buffer.isBuffer(toCast)) {
        return toCast;
    }
    if (typeof toCast === "string") {
        return utilBufferFrom.fromString(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
        return utilBufferFrom.fromArrayBuffer(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return utilBufferFrom.fromArrayBuffer(toCast);
}

exports.Hash = Hash;


/***/ }),

/***/ 780:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const isArrayBuffer = (arg) => (typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer) ||
    Object.prototype.toString.call(arg) === "[object ArrayBuffer]";

exports.isArrayBuffer = isArrayBuffer;


/***/ }),

/***/ 2800:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var protocolHttp = __nccwpck_require__(4418);

const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
    return (next) => async (args) => {
        const request = args.request;
        if (protocolHttp.HttpRequest.isInstance(request)) {
            const { body, headers } = request;
            if (body &&
                Object.keys(headers)
                    .map((str) => str.toLowerCase())
                    .indexOf(CONTENT_LENGTH_HEADER) === -1) {
                try {
                    const length = bodyLengthChecker(body);
                    request.headers = {
                        ...request.headers,
                        [CONTENT_LENGTH_HEADER]: String(length),
                    };
                }
                catch (error) {
                }
            }
        }
        return next({
            ...args,
            request,
        });
    };
}
const contentLengthMiddlewareOptions = {
    step: "build",
    tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
    name: "contentLengthMiddleware",
    override: true,
};
const getContentLengthPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
    },
});

exports.contentLengthMiddleware = contentLengthMiddleware;
exports.contentLengthMiddlewareOptions = contentLengthMiddlewareOptions;
exports.getContentLengthPlugin = getContentLengthPlugin;


/***/ }),

/***/ 1518:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointFromConfig = void 0;
const node_config_provider_1 = __nccwpck_require__(3461);
const getEndpointUrlConfig_1 = __nccwpck_require__(7574);
const getEndpointFromConfig = async (serviceId) => (0, node_config_provider_1.loadConfig)((0, getEndpointUrlConfig_1.getEndpointUrlConfig)(serviceId ?? ""))();
exports.getEndpointFromConfig = getEndpointFromConfig;


/***/ }),

/***/ 7574:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEndpointUrlConfig = void 0;
const shared_ini_file_loader_1 = __nccwpck_require__(3507);
const ENV_ENDPOINT_URL = "AWS_ENDPOINT_URL";
const CONFIG_ENDPOINT_URL = "endpoint_url";
const getEndpointUrlConfig = (serviceId) => ({
    environmentVariableSelector: (env) => {
        const serviceSuffixParts = serviceId.split(" ").map((w) => w.toUpperCase());
        const serviceEndpointUrl = env[[ENV_ENDPOINT_URL, ...serviceSuffixParts].join("_")];
        if (serviceEndpointUrl)
            return serviceEndpointUrl;
        const endpointUrl = env[ENV_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    configFileSelector: (profile, config) => {
        if (config && profile.services) {
            const servicesSection = config[["services", profile.services].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
            if (servicesSection) {
                const servicePrefixParts = serviceId.split(" ").map((w) => w.toLowerCase());
                const endpointUrl = servicesSection[[servicePrefixParts.join("_"), CONFIG_ENDPOINT_URL].join(shared_ini_file_loader_1.CONFIG_PREFIX_SEPARATOR)];
                if (endpointUrl)
                    return endpointUrl;
            }
        }
        const endpointUrl = profile[CONFIG_ENDPOINT_URL];
        if (endpointUrl)
            return endpointUrl;
        return undefined;
    },
    default: undefined,
});
exports.getEndpointUrlConfig = getEndpointUrlConfig;


/***/ }),

/***/ 2918:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var getEndpointFromConfig = __nccwpck_require__(1518);
var urlParser = __nccwpck_require__(4681);
var core = __nccwpck_require__(5829);
var utilMiddleware = __nccwpck_require__(2390);
var middlewareSerde = __nccwpck_require__(1238);

const resolveParamsForS3 = async (endpointParams) => {
    const bucket = endpointParams?.Bucket || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if (isArnBucketName(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    }
    else if (!isDnsCompatibleBucketName(bucket) ||
        (bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:")) ||
        bucket.toLowerCase() !== bucket ||
        bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
const isDnsCompatibleBucketName = (bucketName) => DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
const isArnBucketName = (bucketName) => {
    const [arn, partition, service, , , bucket] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = Boolean(isArn && partition && service && bucket);
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return isValidArn;
};

const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config, isClientContextParam = false) => {
    const configProvider = async () => {
        let configValue;
        if (isClientContextParam) {
            const clientContextParams = config.clientContextParams;
            const nestedValue = clientContextParams?.[configKey];
            configValue = nestedValue ?? config[configKey] ?? config[canonicalEndpointParamKey];
        }
        else {
            configValue = config[configKey] ?? config[canonicalEndpointParamKey];
        }
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "credentialScope" || canonicalEndpointParamKey === "CredentialScope") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.credentialScope ?? credentials?.CredentialScope;
            return configValue;
        };
    }
    if (configKey === "accountId" || canonicalEndpointParamKey === "AccountId") {
        return async () => {
            const credentials = typeof config.credentials === "function" ? await config.credentials() : config.credentials;
            const configValue = credentials?.accountId ?? credentials?.AccountId;
            return configValue;
        };
    }
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async () => {
            if (config.isCustomEndpoint === false) {
                return undefined;
            }
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};

const toEndpointV1 = (endpoint) => {
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return urlParser.parseUrl(endpoint.url);
        }
        return endpoint;
    }
    return urlParser.parseUrl(endpoint);
};

const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context) => {
    if (!clientConfig.isCustomEndpoint) {
        let endpointFromConfig;
        if (clientConfig.serviceConfiguredEndpoint) {
            endpointFromConfig = await clientConfig.serviceConfiguredEndpoint();
        }
        else {
            endpointFromConfig = await getEndpointFromConfig.getEndpointFromConfig(clientConfig.serviceId);
        }
        if (endpointFromConfig) {
            clientConfig.endpoint = () => Promise.resolve(toEndpointV1(endpointFromConfig));
            clientConfig.isCustomEndpoint = true;
        }
    }
    const endpointParams = await resolveParams(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
const resolveParams = async (commandInput, instructionsSupplier, clientConfig) => {
    const endpointParams = {};
    const instructions = instructionsSupplier?.getEndpointParameterInstructions?.() || {};
    for (const [name, instruction] of Object.entries(instructions)) {
        switch (instruction.type) {
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await createConfigValueProvider(instruction.name, name, clientConfig, instruction.type !== "builtInParams")();
                break;
            case "operationContextParams":
                endpointParams[name] = instruction.get(commandInput);
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await resolveParamsForS3(endpointParams);
    }
    return endpointParams;
};

const endpointMiddleware = ({ config, instructions, }) => {
    return (next, context) => async (args) => {
        if (config.isCustomEndpoint) {
            core.setFeature(context, "ENDPOINT_OVERRIDE", "N");
        }
        const endpoint = await getEndpointFromInstructions(args.input, {
            getEndpointParameterInstructions() {
                return instructions;
            },
        }, { ...config }, context);
        context.endpointV2 = endpoint;
        context.authSchemes = endpoint.properties?.authSchemes;
        const authScheme = context.authSchemes?.[0];
        if (authScheme) {
            context["signing_region"] = authScheme.signingRegion;
            context["signing_service"] = authScheme.signingName;
            const smithyContext = utilMiddleware.getSmithyContext(context);
            const httpAuthOption = smithyContext?.selectedHttpAuthScheme?.httpAuthOption;
            if (httpAuthOption) {
                httpAuthOption.signingProperties = Object.assign(httpAuthOption.signingProperties || {}, {
                    signing_region: authScheme.signingRegion,
                    signingRegion: authScheme.signingRegion,
                    signing_service: authScheme.signingName,
                    signingName: authScheme.signingName,
                    signingRegionSet: authScheme.signingRegionSet,
                }, authScheme.properties);
            }
        }
        return next({
            ...args,
        });
    };
};

const endpointMiddlewareOptions = {
    step: "serialize",
    tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middlewareSerde.serializerMiddlewareOption.name,
};
const getEndpointPlugin = (config, instructions) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(endpointMiddleware({
            config,
            instructions,
        }), endpointMiddlewareOptions);
    },
});

const resolveEndpointConfig = (input) => {
    const tls = input.tls ?? true;
    const { endpoint, useDualstackEndpoint, useFipsEndpoint } = input;
    const customEndpointProvider = endpoint != null ? async () => toEndpointV1(await utilMiddleware.normalizeProvider(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    const resolvedConfig = Object.assign(input, {
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: utilMiddleware.normalizeProvider(useDualstackEndpoint ?? false),
        useFipsEndpoint: utilMiddleware.normalizeProvider(useFipsEndpoint ?? false),
    });
    let configuredEndpointPromise = undefined;
    resolvedConfig.serviceConfiguredEndpoint = async () => {
        if (input.serviceId && !configuredEndpointPromise) {
            configuredEndpointPromise = getEndpointFromConfig.getEndpointFromConfig(input.serviceId);
        }
        return configuredEndpointPromise;
    };
    return resolvedConfig;
};

const resolveEndpointRequiredConfig = (input) => {
    const { endpoint } = input;
    if (endpoint === undefined) {
        input.endpoint = async () => {
            throw new Error("@smithy/middleware-endpoint: (default endpointRuleSet) endpoint is not set - you must configure an endpoint.");
        };
    }
    return input;
};

exports.endpointMiddleware = endpointMiddleware;
exports.endpointMiddlewareOptions = endpointMiddlewareOptions;
exports.getEndpointFromInstructions = getEndpointFromInstructions;
exports.getEndpointPlugin = getEndpointPlugin;
exports.resolveEndpointConfig = resolveEndpointConfig;
exports.resolveEndpointRequiredConfig = resolveEndpointRequiredConfig;
exports.resolveParams = resolveParams;
exports.toEndpointV1 = toEndpointV1;


/***/ }),

/***/ 6039:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilRetry = __nccwpck_require__(4902);
var protocolHttp = __nccwpck_require__(4418);
var serviceErrorClassification = __nccwpck_require__(6375);
var uuid = __nccwpck_require__(3634);
var utilMiddleware = __nccwpck_require__(2390);
var smithyClient = __nccwpck_require__(3570);
var isStreamingPayload = __nccwpck_require__(8977);

const getDefaultRetryQuota = (initialRetryTokens, options) => {
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = utilRetry.NO_RETRY_INCREMENT;
    const retryCost = utilRetry.RETRY_COST;
    const timeoutRetryCost = utilRetry.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error) => (error.name === "TimeoutError" ? timeoutRetryCost : retryCost);
    const hasRetryTokens = (error) => getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error) => {
        if (!hasRetryTokens(error)) {
            throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error);
        availableCapacity -= capacityAmount;
        return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount) => {
        availableCapacity += capacityReleaseAmount ?? noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens,
    });
};

const defaultDelayDecider = (delayBase, attempts) => Math.floor(Math.min(utilRetry.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));

const defaultRetryDecider = (error) => {
    if (!error) {
        return false;
    }
    return serviceErrorClassification.isRetryableByTrait(error) || serviceErrorClassification.isClockSkewError(error) || serviceErrorClassification.isThrottlingError(error) || serviceErrorClassification.isTransientError(error);
};

const asSdkError = (error) => {
    if (error instanceof Error)
        return error;
    if (error instanceof Object)
        return Object.assign(new Error(), error);
    if (typeof error === "string")
        return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
};

class StandardRetryStrategy {
    maxAttemptsProvider;
    retryDecider;
    delayDecider;
    retryQuota;
    mode = utilRetry.RETRY_MODES.STANDARD;
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.retryDecider = options?.retryDecider ?? defaultRetryDecider;
        this.delayDecider = options?.delayDecider ?? defaultDelayDecider;
        this.retryQuota = options?.retryQuota ?? getDefaultRetryQuota(utilRetry.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
        let maxAttempts;
        try {
            maxAttempts = await this.maxAttemptsProvider();
        }
        catch (error) {
            maxAttempts = utilRetry.DEFAULT_MAX_ATTEMPTS;
        }
        return maxAttempts;
    }
    async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request } = args;
        if (protocolHttp.HttpRequest.isInstance(request)) {
            request.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
        }
        while (true) {
            try {
                if (protocolHttp.HttpRequest.isInstance(request)) {
                    request.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                if (options?.beforeRequest) {
                    await options.beforeRequest();
                }
                const { response, output } = await next(args);
                if (options?.afterRequest) {
                    options.afterRequest(response);
                }
                this.retryQuota.releaseRetryTokens(retryTokenAmount);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalDelay;
                return { response, output };
            }
            catch (e) {
                const err = asSdkError(e);
                attempts++;
                if (this.shouldRetry(err, attempts, maxAttempts)) {
                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                    const delayFromDecider = this.delayDecider(serviceErrorClassification.isThrottlingError(err) ? utilRetry.THROTTLING_RETRY_DELAY_BASE : utilRetry.DEFAULT_RETRY_DELAY_BASE, attempts);
                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);
                    totalDelay += delay;
                    await new Promise((resolve) => setTimeout(resolve, delay));
                    continue;
                }
                if (!err.$metadata) {
                    err.$metadata = {};
                }
                err.$metadata.attempts = attempts;
                err.$metadata.totalRetryDelay = totalDelay;
                throw err;
            }
        }
    }
}
const getDelayFromRetryAfterHeader = (response) => {
    if (!protocolHttp.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
};

class AdaptiveRetryStrategy extends StandardRetryStrategy {
    rateLimiter;
    constructor(maxAttemptsProvider, options) {
        const { rateLimiter, ...superOptions } = options ?? {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter ?? new utilRetry.DefaultRateLimiter();
        this.mode = utilRetry.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
        return super.retry(next, args, {
            beforeRequest: async () => {
                return this.rateLimiter.getSendToken();
            },
            afterRequest: (response) => {
                this.rateLimiter.updateClientSendingRate(response);
            },
        });
    }
}

const ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
const CONFIG_MAX_ATTEMPTS = "max_attempts";
const NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        const value = env[ENV_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    configFileSelector: (profile) => {
        const value = profile[CONFIG_MAX_ATTEMPTS];
        if (!value)
            return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    default: utilRetry.DEFAULT_MAX_ATTEMPTS,
};
const resolveRetryConfig = (input) => {
    const { retryStrategy, retryMode: _retryMode, maxAttempts: _maxAttempts } = input;
    const maxAttempts = utilMiddleware.normalizeProvider(_maxAttempts ?? utilRetry.DEFAULT_MAX_ATTEMPTS);
    return Object.assign(input, {
        maxAttempts,
        retryStrategy: async () => {
            if (retryStrategy) {
                return retryStrategy;
            }
            const retryMode = await utilMiddleware.normalizeProvider(_retryMode)();
            if (retryMode === utilRetry.RETRY_MODES.ADAPTIVE) {
                return new utilRetry.AdaptiveRetryStrategy(maxAttempts);
            }
            return new utilRetry.StandardRetryStrategy(maxAttempts);
        },
    });
};
const ENV_RETRY_MODE = "AWS_RETRY_MODE";
const CONFIG_RETRY_MODE = "retry_mode";
const NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => env[ENV_RETRY_MODE],
    configFileSelector: (profile) => profile[CONFIG_RETRY_MODE],
    default: utilRetry.DEFAULT_RETRY_MODE,
};

const omitRetryHeadersMiddleware = () => (next) => async (args) => {
    const { request } = args;
    if (protocolHttp.HttpRequest.isInstance(request)) {
        delete request.headers[utilRetry.INVOCATION_ID_HEADER];
        delete request.headers[utilRetry.REQUEST_HEADER];
    }
    return next(args);
};
const omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: ["RETRY", "HEADERS", "OMIT_RETRY_HEADERS"],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true,
};
const getOmitRetryHeadersPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.addRelativeTo(omitRetryHeadersMiddleware(), omitRetryHeadersMiddlewareOptions);
    },
});

const retryMiddleware = (options) => (next, context) => async (args) => {
    let retryStrategy = await options.retryStrategy();
    const maxAttempts = await options.maxAttempts();
    if (isRetryStrategyV2(retryStrategy)) {
        retryStrategy = retryStrategy;
        let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
        let lastError = new Error();
        let attempts = 0;
        let totalRetryDelay = 0;
        const { request } = args;
        const isRequest = protocolHttp.HttpRequest.isInstance(request);
        if (isRequest) {
            request.headers[utilRetry.INVOCATION_ID_HEADER] = uuid.v4();
        }
        while (true) {
            try {
                if (isRequest) {
                    request.headers[utilRetry.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                const { response, output } = await next(args);
                retryStrategy.recordSuccess(retryToken);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalRetryDelay;
                return { response, output };
            }
            catch (e) {
                const retryErrorInfo = getRetryErrorInfo(e);
                lastError = asSdkError(e);
                if (isRequest && isStreamingPayload.isStreamingPayload(request)) {
                    (context.logger instanceof smithyClient.NoOpLogger ? console : context.logger)?.warn("An error was encountered in a non-retryable streaming request.");
                    throw lastError;
                }
                try {
                    retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                }
                catch (refreshError) {
                    if (!lastError.$metadata) {
                        lastError.$metadata = {};
                    }
                    lastError.$metadata.attempts = attempts + 1;
                    lastError.$metadata.totalRetryDelay = totalRetryDelay;
                    throw lastError;
                }
                attempts = retryToken.getRetryCount();
                const delay = retryToken.getRetryDelay();
                totalRetryDelay += delay;
                await new Promise((resolve) => setTimeout(resolve, delay));
            }
        }
    }
    else {
        retryStrategy = retryStrategy;
        if (retryStrategy?.mode)
            context.userAgent = [...(context.userAgent || []), ["cfg/retry-mode", retryStrategy.mode]];
        return retryStrategy.retry(next, args);
    }
};
const isRetryStrategyV2 = (retryStrategy) => typeof retryStrategy.acquireInitialRetryToken !== "undefined" &&
    typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" &&
    typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error) => {
    const errorInfo = {
        error,
        errorType: getRetryErrorType(error),
    };
    const retryAfterHint = getRetryAfterHint(error.$response);
    if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
};
const getRetryErrorType = (error) => {
    if (serviceErrorClassification.isThrottlingError(error))
        return "THROTTLING";
    if (serviceErrorClassification.isTransientError(error))
        return "TRANSIENT";
    if (serviceErrorClassification.isServerError(error))
        return "SERVER_ERROR";
    return "CLIENT_ERROR";
};
const retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: ["RETRY"],
    step: "finalizeRequest",
    priority: "high",
    override: true,
};
const getRetryPlugin = (options) => ({
    applyToStack: (clientStack) => {
        clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
    },
});
const getRetryAfterHint = (response) => {
    if (!protocolHttp.HttpResponse.isInstance(response))
        return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key) => key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName)
        return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds))
        return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
};

exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
exports.CONFIG_MAX_ATTEMPTS = CONFIG_MAX_ATTEMPTS;
exports.CONFIG_RETRY_MODE = CONFIG_RETRY_MODE;
exports.ENV_MAX_ATTEMPTS = ENV_MAX_ATTEMPTS;
exports.ENV_RETRY_MODE = ENV_RETRY_MODE;
exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = NODE_MAX_ATTEMPT_CONFIG_OPTIONS;
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = NODE_RETRY_MODE_CONFIG_OPTIONS;
exports.StandardRetryStrategy = StandardRetryStrategy;
exports.defaultDelayDecider = defaultDelayDecider;
exports.defaultRetryDecider = defaultRetryDecider;
exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;
exports.getRetryAfterHint = getRetryAfterHint;
exports.getRetryPlugin = getRetryPlugin;
exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
exports.omitRetryHeadersMiddlewareOptions = omitRetryHeadersMiddlewareOptions;
exports.resolveRetryConfig = resolveRetryConfig;
exports.retryMiddleware = retryMiddleware;
exports.retryMiddlewareOptions = retryMiddlewareOptions;


/***/ }),

/***/ 8977:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isStreamingPayload = void 0;
const stream_1 = __nccwpck_require__(2781);
const isStreamingPayload = (request) => request?.body instanceof stream_1.Readable ||
    (typeof ReadableStream !== "undefined" && request?.body instanceof ReadableStream);
exports.isStreamingPayload = isStreamingPayload;


/***/ }),

/***/ 1238:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var protocolHttp = __nccwpck_require__(4418);

const deserializerMiddleware = (options, deserializer) => (next, context) => async (args) => {
    const { response } = await next(args);
    try {
        const parsed = await deserializer(response, options);
        return {
            response,
            output: parsed,
        };
    }
    catch (error) {
        Object.defineProperty(error, "$response", {
            value: response,
            enumerable: false,
            writable: false,
            configurable: false,
        });
        if (!("$metadata" in error)) {
            const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
            try {
                error.message += "\n  " + hint;
            }
            catch (e) {
                if (!context.logger || context.logger?.constructor?.name === "NoOpLogger") {
                    console.warn(hint);
                }
                else {
                    context.logger?.warn?.(hint);
                }
            }
            if (typeof error.$responseBodyText !== "undefined") {
                if (error.$response) {
                    error.$response.body = error.$responseBodyText;
                }
            }
            try {
                if (protocolHttp.HttpResponse.isInstance(response)) {
                    const { headers = {} } = response;
                    const headerEntries = Object.entries(headers);
                    error.$metadata = {
                        httpStatusCode: response.statusCode,
                        requestId: findHeader(/^x-[\w-]+-request-?id$/, headerEntries),
                        extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, headerEntries),
                        cfId: findHeader(/^x-[\w-]+-cf-id$/, headerEntries),
                    };
                }
            }
            catch (e) {
            }
        }
        throw error;
    }
};
const findHeader = (pattern, headers) => {
    return (headers.find(([k]) => {
        return k.match(pattern);
    }) || [void 0, void 0])[1];
};

const serializerMiddleware = (options, serializer) => (next, context) => async (args) => {
    const endpointConfig = options;
    const endpoint = context.endpointV2?.url && endpointConfig.urlParser
        ? async () => endpointConfig.urlParser(context.endpointV2.url)
        : endpointConfig.endpoint;
    if (!endpoint) {
        throw new Error("No valid endpoint provider available.");
    }
    const request = await serializer(args.input, { ...options, endpoint });
    return next({
        ...args,
        request,
    });
};

const deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: ["DESERIALIZER"],
    override: true,
};
const serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: ["SERIALIZER"],
    override: true,
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack) => {
            commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
            commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
        },
    };
}

exports.deserializerMiddleware = deserializerMiddleware;
exports.deserializerMiddlewareOption = deserializerMiddlewareOption;
exports.getSerdePlugin = getSerdePlugin;
exports.serializerMiddleware = serializerMiddleware;
exports.serializerMiddlewareOption = serializerMiddlewareOption;


/***/ }),

/***/ 7911:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const getAllAliases = (name, aliases) => {
    const _aliases = [];
    if (name) {
        _aliases.push(name);
    }
    if (aliases) {
        for (const alias of aliases) {
            _aliases.push(alias);
        }
    }
    return _aliases;
};
const getMiddlewareNameWithAliases = (name, aliases) => {
    return `${name || "anonymous"}${aliases && aliases.length > 0 ? ` (a.k.a. ${aliases.join(",")})` : ""}`;
};
const constructStack = () => {
    let absoluteEntries = [];
    let relativeEntries = [];
    let identifyOnResolve = false;
    const entriesNameSet = new Set();
    const sort = (entries) => entries.sort((a, b) => stepWeights[b.step] - stepWeights[a.step] ||
        priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            const aliases = getAllAliases(entry.name, entry.aliases);
            if (aliases.includes(toRemove)) {
                isRemoved = true;
                for (const alias of aliases) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove) => {
        let isRemoved = false;
        const filterCb = (entry) => {
            if (entry.middleware === toRemove) {
                isRemoved = true;
                for (const alias of getAllAliases(entry.name, entry.aliases)) {
                    entriesNameSet.delete(alias);
                }
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack) => {
        absoluteEntries.forEach((entry) => {
            toStack.add(entry.middleware, { ...entry });
        });
        relativeEntries.forEach((entry) => {
            toStack.addRelativeTo(entry.middleware, { ...entry });
        });
        toStack.identifyOnResolve?.(stack.identifyOnResolve());
        return toStack;
    };
    const expandRelativeMiddlewareList = (from) => {
        const expandedMiddlewareList = [];
        from.before.forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry) => {
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            }
            else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false) => {
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry) => {
            const normalizedEntry = {
                ...entry,
                before: [],
                after: [],
            };
            for (const alias of getAllAliases(normalizedEntry.name, normalizedEntry.aliases)) {
                normalizedEntriesNameMap[alias] = normalizedEntry;
            }
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry) => {
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ` +
                        `${getMiddlewareNameWithAliases(entry.name, entry.aliases)} ` +
                        `middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries)
            .map(expandRelativeMiddlewareList)
            .reduce((wholeList, expandedMiddlewareList) => {
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {}) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = absoluteEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = absoluteEntries[toOverrideIndex];
                        if (toOverride.step !== entry.step || entry.priority !== toOverride.priority) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware with ` +
                                `${toOverride.priority} priority in ${toOverride.step} step cannot ` +
                                `be overridden by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware with ` +
                                `${entry.priority} priority in ${entry.step} step.`);
                        }
                        absoluteEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options) => {
            const { name, override, aliases: _aliases } = options;
            const entry = {
                middleware,
                ...options,
            };
            const aliases = getAllAliases(name, _aliases);
            if (aliases.length > 0) {
                if (aliases.some((alias) => entriesNameSet.has(alias))) {
                    if (!override)
                        throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(name, _aliases)}'`);
                    for (const alias of aliases) {
                        const toOverrideIndex = relativeEntries.findIndex((entry) => entry.name === alias || entry.aliases?.some((a) => a === alias));
                        if (toOverrideIndex === -1) {
                            continue;
                        }
                        const toOverride = relativeEntries[toOverrideIndex];
                        if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                            throw new Error(`"${getMiddlewareNameWithAliases(toOverride.name, toOverride.aliases)}" middleware ` +
                                `${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` +
                                `by "${getMiddlewareNameWithAliases(name, _aliases)}" middleware ${entry.relation} ` +
                                `"${entry.toMiddleware}" middleware.`);
                        }
                        relativeEntries.splice(toOverrideIndex, 1);
                    }
                }
                for (const alias of aliases) {
                    entriesNameSet.add(alias);
                }
            }
            relativeEntries.push(entry);
        },
        clone: () => cloneTo(constructStack()),
        use: (plugin) => {
            plugin.applyToStack(stack);
        },
        remove: (toRemove) => {
            if (typeof toRemove === "string")
                return removeByName(toRemove);
            else
                return removeByReference(toRemove);
        },
        removeByTag: (toRemove) => {
            let isRemoved = false;
            const filterCb = (entry) => {
                const { tags, name, aliases: _aliases } = entry;
                if (tags && tags.includes(toRemove)) {
                    const aliases = getAllAliases(name, _aliases);
                    for (const alias of aliases) {
                        entriesNameSet.delete(alias);
                    }
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from) => {
            const cloned = cloneTo(constructStack());
            cloned.use(from);
            cloned.identifyOnResolve(identifyOnResolve || cloned.identifyOnResolve() || (from.identifyOnResolve?.() ?? false));
            return cloned;
        },
        applyToStack: cloneTo,
        identify: () => {
            return getMiddlewareList(true).map((mw) => {
                const step = mw.step ??
                    mw.relation +
                        " " +
                        mw.toMiddleware;
                return getMiddlewareNameWithAliases(mw.name, mw.aliases) + " - " + step;
            });
        },
        identifyOnResolve(toggle) {
            if (typeof toggle === "boolean")
                identifyOnResolve = toggle;
            return identifyOnResolve;
        },
        resolve: (handler, context) => {
            for (const middleware of getMiddlewareList()
                .map((entry) => entry.middleware)
                .reverse()) {
                handler = middleware(handler, context);
            }
            if (identifyOnResolve) {
                console.log(stack.identify());
            }
            return handler;
        },
    };
    return stack;
};
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1,
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1,
};

exports.constructStack = constructStack;


/***/ }),

/***/ 3461:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var propertyProvider = __nccwpck_require__(9721);
var sharedIniFileLoader = __nccwpck_require__(3507);

function getSelectorName(functionString) {
    try {
        const constants = new Set(Array.from(functionString.match(/([A-Z_]){3,}/g) ?? []));
        constants.delete("CONFIG");
        constants.delete("CONFIG_PREFIX_SEPARATOR");
        constants.delete("ENV");
        return [...constants].join(", ");
    }
    catch (e) {
        return functionString;
    }
}

const fromEnv = (envVarSelector, options) => async () => {
    try {
        const config = envVarSelector(process.env, options);
        if (config === undefined) {
            throw new Error();
        }
        return config;
    }
    catch (e) {
        throw new propertyProvider.CredentialsProviderError(e.message || `Not found in ENV: ${getSelectorName(envVarSelector.toString())}`, { logger: options?.logger });
    }
};

const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {}) => async () => {
    const profile = sharedIniFileLoader.getProfileName(init);
    const { configFile, credentialsFile } = await sharedIniFileLoader.loadSharedConfigFiles(init);
    const profileFromCredentials = credentialsFile[profile] || {};
    const profileFromConfig = configFile[profile] || {};
    const mergedProfile = preferredFile === "config"
        ? { ...profileFromCredentials, ...profileFromConfig }
        : { ...profileFromConfig, ...profileFromCredentials };
    try {
        const cfgFile = preferredFile === "config" ? configFile : credentialsFile;
        const configValue = configSelector(mergedProfile, cfgFile);
        if (configValue === undefined) {
            throw new Error();
        }
        return configValue;
    }
    catch (e) {
        throw new propertyProvider.CredentialsProviderError(e.message || `Not found in config files w/ profile [${profile}]: ${getSelectorName(configSelector.toString())}`, { logger: init.logger });
    }
};

const isFunction = (func) => typeof func === "function";
const fromStatic = (defaultValue) => isFunction(defaultValue) ? async () => await defaultValue() : propertyProvider.fromStatic(defaultValue);

const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {}) => {
    const { signingName, logger } = configuration;
    const envOptions = { signingName, logger };
    return propertyProvider.memoize(propertyProvider.chain(fromEnv(environmentVariableSelector, envOptions), fromSharedConfigFiles(configFileSelector, configuration), fromStatic(defaultValue)));
};

exports.loadConfig = loadConfig;


/***/ }),

/***/ 258:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var protocolHttp = __nccwpck_require__(4418);
var querystringBuilder = __nccwpck_require__(8031);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var stream = __nccwpck_require__(2781);
var http2 = __nccwpck_require__(5158);

const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "EPIPE", "ETIMEDOUT"];

const getTransformedHeaders = (headers) => {
    const transformedHeaders = {};
    for (const name of Object.keys(headers)) {
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};

const timing = {
    setTimeout: (cb, ms) => setTimeout(cb, ms),
    clearTimeout: (timeoutId) => clearTimeout(timeoutId),
};

const DEFER_EVENT_LISTENER_TIME$2 = 1000;
const setConnectionTimeout = (request, reject, timeoutInMs = 0) => {
    if (!timeoutInMs) {
        return -1;
    }
    const registerTimeout = (offset) => {
        const timeoutId = timing.setTimeout(() => {
            request.destroy();
            reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket did not establish a connection with the server within the configured timeout of ${timeoutInMs} ms.`), {
                name: "TimeoutError",
            }));
        }, timeoutInMs - offset);
        const doWithSocket = (socket) => {
            if (socket?.connecting) {
                socket.on("connect", () => {
                    timing.clearTimeout(timeoutId);
                });
            }
            else {
                timing.clearTimeout(timeoutId);
            }
        };
        if (request.socket) {
            doWithSocket(request.socket);
        }
        else {
            request.on("socket", doWithSocket);
        }
    };
    if (timeoutInMs < 2000) {
        registerTimeout(0);
        return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, DEFER_EVENT_LISTENER_TIME$2), DEFER_EVENT_LISTENER_TIME$2);
};

const setRequestTimeout = (req, reject, timeoutInMs = 0, throwOnRequestTimeout, logger) => {
    if (timeoutInMs) {
        return timing.setTimeout(() => {
            let msg = `@smithy/node-http-handler - [${throwOnRequestTimeout ? "ERROR" : "WARN"}] a request has exceeded the configured ${timeoutInMs} ms requestTimeout.`;
            if (throwOnRequestTimeout) {
                const error = Object.assign(new Error(msg), {
                    name: "TimeoutError",
                    code: "ETIMEDOUT",
                });
                req.destroy(error);
                reject(error);
            }
            else {
                msg += ` Init client requestHandler with throwOnRequestTimeout=true to turn this into an error.`;
                logger?.warn?.(msg);
            }
        }, timeoutInMs);
    }
    return -1;
};

const DEFER_EVENT_LISTENER_TIME$1 = 3000;
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs }, deferTimeMs = DEFER_EVENT_LISTENER_TIME$1) => {
    if (keepAlive !== true) {
        return -1;
    }
    const registerListener = () => {
        if (request.socket) {
            request.socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
        }
        else {
            request.on("socket", (socket) => {
                socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
            });
        }
    };
    if (deferTimeMs === 0) {
        registerListener();
        return 0;
    }
    return timing.setTimeout(registerListener, deferTimeMs);
};

const DEFER_EVENT_LISTENER_TIME = 3000;
const setSocketTimeout = (request, reject, timeoutInMs = 0) => {
    const registerTimeout = (offset) => {
        const timeout = timeoutInMs - offset;
        const onTimeout = () => {
            request.destroy();
            reject(Object.assign(new Error(`@smithy/node-http-handler - the request socket timed out after ${timeoutInMs} ms of inactivity (configured by client requestHandler).`), { name: "TimeoutError" }));
        };
        if (request.socket) {
            request.socket.setTimeout(timeout, onTimeout);
            request.on("close", () => request.socket?.removeListener("timeout", onTimeout));
        }
        else {
            request.setTimeout(timeout, onTimeout);
        }
    };
    if (0 < timeoutInMs && timeoutInMs < 6000) {
        registerTimeout(0);
        return 0;
    }
    return timing.setTimeout(registerTimeout.bind(null, timeoutInMs === 0 ? 0 : DEFER_EVENT_LISTENER_TIME), DEFER_EVENT_LISTENER_TIME);
};

const MIN_WAIT_TIME = 6_000;
async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME, externalAgent = false) {
    const headers = request.headers ?? {};
    const expect = headers.Expect || headers.expect;
    let timeoutId = -1;
    let sendBody = true;
    if (!externalAgent && expect === "100-continue") {
        sendBody = await Promise.race([
            new Promise((resolve) => {
                timeoutId = Number(timing.setTimeout(() => resolve(true), Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve) => {
                httpRequest.on("continue", () => {
                    timing.clearTimeout(timeoutId);
                    resolve(true);
                });
                httpRequest.on("response", () => {
                    timing.clearTimeout(timeoutId);
                    resolve(false);
                });
                httpRequest.on("error", () => {
                    timing.clearTimeout(timeoutId);
                    resolve(false);
                });
            }),
        ]);
    }
    if (sendBody) {
        writeBody(httpRequest, request.body);
    }
}
function writeBody(httpRequest, body) {
    if (body instanceof stream.Readable) {
        body.pipe(httpRequest);
        return;
    }
    if (body) {
        if (Buffer.isBuffer(body) || typeof body === "string") {
            httpRequest.end(body);
            return;
        }
        const uint8 = body;
        if (typeof uint8 === "object" &&
            uint8.buffer &&
            typeof uint8.byteOffset === "number" &&
            typeof uint8.byteLength === "number") {
            httpRequest.end(Buffer.from(uint8.buffer, uint8.byteOffset, uint8.byteLength));
            return;
        }
        httpRequest.end(Buffer.from(body));
        return;
    }
    httpRequest.end();
}

const DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    config;
    configProvider;
    socketWarningTimestamp = 0;
    externalAgent = false;
    metadata = { handlerProtocol: "http/1.1" };
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttpHandler(instanceOrOptions);
    }
    static checkSocketUsage(agent, socketWarningTimestamp, logger = console) {
        const { sockets, requests, maxSockets } = agent;
        if (typeof maxSockets !== "number" || maxSockets === Infinity) {
            return socketWarningTimestamp;
        }
        const interval = 15_000;
        if (Date.now() - interval < socketWarningTimestamp) {
            return socketWarningTimestamp;
        }
        if (sockets && requests) {
            for (const origin in sockets) {
                const socketsInUse = sockets[origin]?.length ?? 0;
                const requestsEnqueued = requests[origin]?.length ?? 0;
                if (socketsInUse >= maxSockets && requestsEnqueued >= 2 * maxSockets) {
                    logger?.warn?.(`@smithy/node-http-handler:WARN - socket usage at capacity=${socketsInUse} and ${requestsEnqueued} additional requests are enqueued.
See https://docs.aws.amazon.com/sdk-for-javascript/v3/developer-guide/node-configuring-maxsockets.html
or increase socketAcquisitionWarningTimeout=(millis) in the NodeHttpHandler config.`);
                    return Date.now();
                }
            }
        }
        return socketWarningTimestamp;
    }
    constructor(options) {
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((_options) => {
                    resolve(this.resolveDefaultConfig(_options));
                })
                    .catch(reject);
            }
            else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, socketAcquisitionWarningTimeout, httpAgent, httpsAgent, throwOnRequestTimeout, } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout,
            socketTimeout,
            socketAcquisitionWarningTimeout,
            throwOnRequestTimeout,
            httpAgent: (() => {
                if (httpAgent instanceof http.Agent || typeof httpAgent?.destroy === "function") {
                    this.externalAgent = true;
                    return httpAgent;
                }
                return new http.Agent({ keepAlive, maxSockets, ...httpAgent });
            })(),
            httpsAgent: (() => {
                if (httpsAgent instanceof https.Agent || typeof httpsAgent?.destroy === "function") {
                    this.externalAgent = true;
                    return httpsAgent;
                }
                return new https.Agent({ keepAlive, maxSockets, ...httpsAgent });
            })(),
            logger: console,
        };
    }
    destroy() {
        this.config?.httpAgent?.destroy();
        this.config?.httpsAgent?.destroy();
    }
    async handle(request, { abortSignal, requestTimeout } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        return new Promise((_resolve, _reject) => {
            const config = this.config;
            let writeRequestBodyPromise = undefined;
            const timeouts = [];
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                timeouts.forEach(timing.clearTimeout);
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                timeouts.forEach(timing.clearTimeout);
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const headers = request.headers ?? {};
            const expectContinue = (headers.Expect ?? headers.expect) === "100-continue";
            let agent = isSSL ? config.httpsAgent : config.httpAgent;
            if (expectContinue && !this.externalAgent) {
                agent = new (isSSL ? https.Agent : http.Agent)({
                    keepAlive: false,
                    maxSockets: Infinity,
                });
            }
            timeouts.push(timing.setTimeout(() => {
                this.socketWarningTimestamp = NodeHttpHandler.checkSocketUsage(agent, this.socketWarningTimestamp, config.logger);
            }, config.socketAcquisitionWarningTimeout ?? (config.requestTimeout ?? 2000) + (config.connectionTimeout ?? 1000)));
            const queryString = querystringBuilder.buildQueryString(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            let hostname = request.hostname ?? "";
            if (hostname[0] === "[" && hostname.endsWith("]")) {
                hostname = request.hostname.slice(1, -1);
            }
            else {
                hostname = request.hostname;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: hostname,
                method: request.method,
                path,
                port: request.port,
                agent,
                auth,
            };
            const requestFunc = isSSL ? https.request : http.request;
            const req = requestFunc(nodeHttpsOptions, (res) => {
                const httpResponse = new protocolHttp.HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: getTransformedHeaders(res.headers),
                    body: res,
                });
                resolve({ response: httpResponse });
            });
            req.on("error", (err) => {
                if (NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, { name: "TimeoutError" }));
                }
                else {
                    reject(err);
                }
            });
            if (abortSignal) {
                const onAbort = () => {
                    req.destroy();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
                if (typeof abortSignal.addEventListener === "function") {
                    const signal = abortSignal;
                    signal.addEventListener("abort", onAbort, { once: true });
                    req.once("close", () => signal.removeEventListener("abort", onAbort));
                }
                else {
                    abortSignal.onabort = onAbort;
                }
            }
            const effectiveRequestTimeout = requestTimeout ?? config.requestTimeout;
            timeouts.push(setConnectionTimeout(req, reject, config.connectionTimeout));
            timeouts.push(setRequestTimeout(req, reject, effectiveRequestTimeout, config.throwOnRequestTimeout, config.logger ?? console));
            timeouts.push(setSocketTimeout(req, reject, config.socketTimeout));
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                timeouts.push(setSocketKeepAlive(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs,
                }));
            }
            writeRequestBodyPromise = writeRequestBody(req, request, effectiveRequestTimeout, this.externalAgent).catch((e) => {
                timeouts.forEach(timing.clearTimeout);
                return _reject(e);
            });
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
}

class NodeHttp2ConnectionPool {
    sessions = [];
    constructor(sessions) {
        this.sessions = sessions ?? [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s) => s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions) {
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}

class NodeHttp2ConnectionManager {
    constructor(config) {
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    config;
    sessionCache = new Map();
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({ maxConcurrentStreams: this.config.maxConcurrency }, (err) => {
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " +
                        this.config.maxConcurrency +
                        "when creating new session for " +
                        requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = () => {
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", () => this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        const cacheKey = this.getUrlString(requestContext);
        this.sessionCache.get(cacheKey)?.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache) {
            for (const session of connectionPool) {
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (maxConcurrentStreams && maxConcurrentStreams <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}

class NodeHttp2Handler {
    config;
    configProvider;
    metadata = { handlerProtocol: "h2" };
    connectionManager = new NodeHttp2ConnectionManager({});
    static create(instanceOrOptions) {
        if (typeof instanceOrOptions?.handle === "function") {
            return instanceOrOptions;
        }
        return new NodeHttp2Handler(instanceOrOptions);
    }
    constructor(options) {
        this.configProvider = new Promise((resolve, reject) => {
            if (typeof options === "function") {
                options()
                    .then((opts) => {
                    resolve(opts || {});
                })
                    .catch(reject);
            }
            else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal, requestTimeout } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout: configRequestTimeout, disableConcurrentStreams } = this.config;
        const effectiveRequestTimeout = requestTimeout ?? configRequestTimeout;
        return new Promise((_resolve, _reject) => {
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg) => {
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg) => {
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal?.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = request.username ?? "";
                const password = request.password ?? "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = { destination: new URL(authority) };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: this.config?.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false,
            });
            const rejectWithDestroy = (err) => {
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = querystringBuilder.buildQueryString(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [http2.constants.HTTP2_HEADER_PATH]: path,
                [http2.constants.HTTP2_HEADER_METHOD]: method,
            });
            session.ref();
            req.on("response", (headers) => {
                const httpResponse = new protocolHttp.HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: getTransformedHeaders(headers),
                    body: req,
                });
                fulfilled = true;
                resolve({ response: httpResponse });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (effectiveRequestTimeout) {
                req.setTimeout(effectiveRequestTimeout, () => {
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${effectiveRequestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                const onAbort = () => {
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
                if (typeof abortSignal.addEventListener === "function") {
                    const signal = abortSignal;
                    signal.addEventListener("abort", onAbort, { once: true });
                    req.once("close", () => signal.removeEventListener("abort", onAbort));
                }
                else {
                    abortSignal.onabort = onAbort;
                }
            }
            req.on("frameError", (type, code, id) => {
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", () => {
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", () => {
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = writeRequestBody(req, request, effectiveRequestTimeout);
        });
    }
    updateHttpClientConfig(key, value) {
        this.config = undefined;
        this.configProvider = this.configProvider.then((config) => {
            return {
                ...config,
                [key]: value,
            };
        });
    }
    httpHandlerConfigs() {
        return this.config ?? {};
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}

class Collector extends stream.Writable {
    bufferedBytes = [];
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}

const streamCollector = (stream) => {
    if (isReadableStreamInstance(stream)) {
        return collectReadableStream(stream);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
};
const isReadableStreamInstance = (stream) => typeof ReadableStream === "function" && stream instanceof ReadableStream;
async function collectReadableStream(stream) {
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    let length = 0;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            length += value.length;
        }
        isDone = done;
    }
    const collected = new Uint8Array(length);
    let offset = 0;
    for (const chunk of chunks) {
        collected.set(chunk, offset);
        offset += chunk.length;
    }
    return collected;
}

exports.DEFAULT_REQUEST_TIMEOUT = DEFAULT_REQUEST_TIMEOUT;
exports.NodeHttp2Handler = NodeHttp2Handler;
exports.NodeHttpHandler = NodeHttpHandler;
exports.streamCollector = streamCollector;


/***/ }),

/***/ 9721:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class ProviderError extends Error {
    name = "ProviderError";
    tryNextLink;
    constructor(message, options = true) {
        let logger;
        let tryNextLink = true;
        if (typeof options === "boolean") {
            logger = undefined;
            tryNextLink = options;
        }
        else if (options != null && typeof options === "object") {
            logger = options.logger;
            tryNextLink = options.tryNextLink ?? true;
        }
        super(message);
        this.tryNextLink = tryNextLink;
        Object.setPrototypeOf(this, ProviderError.prototype);
        logger?.debug?.(`@smithy/property-provider ${tryNextLink ? "->" : "(!)"} ${message}`);
    }
    static from(error, options = true) {
        return Object.assign(new this(error.message, options), error);
    }
}

class CredentialsProviderError extends ProviderError {
    name = "CredentialsProviderError";
    constructor(message, options = true) {
        super(message, options);
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}

class TokenProviderError extends ProviderError {
    name = "TokenProviderError";
    constructor(message, options = true) {
        super(message, options);
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}

const chain = (...providers) => async () => {
    if (providers.length === 0) {
        throw new ProviderError("No providers in chain");
    }
    let lastProviderError;
    for (const provider of providers) {
        try {
            const credentials = await provider();
            return credentials;
        }
        catch (err) {
            lastProviderError = err;
            if (err?.tryNextLink) {
                continue;
            }
            throw err;
        }
    }
    throw lastProviderError;
};

const fromStatic = (staticValue) => () => Promise.resolve(staticValue);

const memoize = (provider, isExpired, requiresRefresh) => {
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async () => {
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        }
        finally {
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options) => {
            if (!hasResult || options?.forceRefresh) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options) => {
        if (!hasResult || options?.forceRefresh) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};

exports.CredentialsProviderError = CredentialsProviderError;
exports.ProviderError = ProviderError;
exports.TokenProviderError = TokenProviderError;
exports.chain = chain;
exports.fromStatic = fromStatic;
exports.memoize = memoize;


/***/ }),

/***/ 4418:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var types = __nccwpck_require__(5756);

const getHttpHandlerExtensionConfiguration = (runtimeConfig) => {
    return {
        setHttpHandler(handler) {
            runtimeConfig.httpHandler = handler;
        },
        httpHandler() {
            return runtimeConfig.httpHandler;
        },
        updateHttpClientConfig(key, value) {
            runtimeConfig.httpHandler?.updateHttpClientConfig(key, value);
        },
        httpHandlerConfigs() {
            return runtimeConfig.httpHandler.httpHandlerConfigs();
        },
    };
};
const resolveHttpHandlerRuntimeConfig = (httpHandlerExtensionConfiguration) => {
    return {
        httpHandler: httpHandlerExtensionConfiguration.httpHandler(),
    };
};

class Field {
    name;
    kind;
    values;
    constructor({ name, kind = types.FieldPosition.HEADER, values = [] }) {
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v) => v !== value);
    }
    toString() {
        return this.values.map((v) => (v.includes(",") || v.includes(" ") ? `"${v}"` : v)).join(", ");
    }
    get() {
        return this.values;
    }
}

class Fields {
    entries = {};
    encoding;
    constructor({ fields = [], encoding = "utf-8" }) {
        fields.forEach(this.setField.bind(this));
        this.encoding = encoding;
    }
    setField(field) {
        this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
        return this.entries[name.toLowerCase()];
    }
    removeField(name) {
        delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
        return Object.values(this.entries).filter((field) => field.kind === kind);
    }
}

class HttpRequest {
    method;
    protocol;
    hostname;
    port;
    path;
    query;
    headers;
    username;
    password;
    fragment;
    body;
    constructor(options) {
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol
            ? options.protocol.slice(-1) !== ":"
                ? `${options.protocol}:`
                : options.protocol
            : "https:";
        this.path = options.path ? (options.path.charAt(0) !== "/" ? `/${options.path}` : options.path) : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static clone(request) {
        const cloned = new HttpRequest({
            ...request,
            headers: { ...request.headers },
        });
        if (cloned.query) {
            cloned.query = cloneQuery(cloned.query);
        }
        return cloned;
    }
    static isInstance(request) {
        if (!request) {
            return false;
        }
        const req = request;
        return ("method" in req &&
            "protocol" in req &&
            "hostname" in req &&
            "path" in req &&
            typeof req["query"] === "object" &&
            typeof req["headers"] === "object");
    }
    clone() {
        return HttpRequest.clone(this);
    }
}
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName) => {
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [...param] : param,
        };
    }, {});
}

class HttpResponse {
    statusCode;
    reason;
    headers;
    body;
    constructor(options) {
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response)
            return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}

function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
}

exports.Field = Field;
exports.Fields = Fields;
exports.HttpRequest = HttpRequest;
exports.HttpResponse = HttpResponse;
exports.getHttpHandlerExtensionConfiguration = getHttpHandlerExtensionConfiguration;
exports.isValidHostname = isValidHostname;
exports.resolveHttpHandlerRuntimeConfig = resolveHttpHandlerRuntimeConfig;


/***/ }),

/***/ 8031:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilUriEscape = __nccwpck_require__(4197);

function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()) {
        const value = query[key];
        key = utilUriEscape.escapeUri(key);
        if (Array.isArray(value)) {
            for (let i = 0, iLen = value.length; i < iLen; i++) {
                parts.push(`${key}=${utilUriEscape.escapeUri(value[i])}`);
            }
        }
        else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${utilUriEscape.escapeUri(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}

exports.buildQueryString = buildQueryString;


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")) {
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            }
            else if (Array.isArray(query[key])) {
                query[key].push(value);
            }
            else {
                query[key] = [query[key], value];
            }
        }
    }
    return query;
}

exports.parseQueryString = parseQueryString;


/***/ }),

/***/ 6375:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch",
];
const THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException",
];
const TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"];
const TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
const NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"];
const NODEJS_NETWORK_ERROR_CODES = ["EHOSTUNREACH", "ENETUNREACH", "ENOTFOUND"];

const isRetryableByTrait = (error) => error?.$retryable !== undefined;
const isClockSkewError = (error) => CLOCK_SKEW_ERROR_CODES.includes(error.name);
const isClockSkewCorrectedError = (error) => error.$metadata?.clockSkewCorrected;
const isBrowserNetworkError = (error) => {
    const errorMessages = new Set([
        "Failed to fetch",
        "NetworkError when attempting to fetch resource",
        "The Internet connection appears to be offline",
        "Load failed",
        "Network request failed",
    ]);
    const isValid = error && error instanceof TypeError;
    if (!isValid) {
        return false;
    }
    return errorMessages.has(error.message);
};
const isThrottlingError = (error) => error.$metadata?.httpStatusCode === 429 ||
    THROTTLING_ERROR_CODES.includes(error.name) ||
    error.$retryable?.throttling == true;
const isTransientError = (error, depth = 0) => isRetryableByTrait(error) ||
    isClockSkewCorrectedError(error) ||
    TRANSIENT_ERROR_CODES.includes(error.name) ||
    NODEJS_TIMEOUT_ERROR_CODES.includes(error?.code || "") ||
    NODEJS_NETWORK_ERROR_CODES.includes(error?.code || "") ||
    TRANSIENT_ERROR_STATUS_CODES.includes(error.$metadata?.httpStatusCode || 0) ||
    isBrowserNetworkError(error) ||
    (error.cause !== undefined && depth <= 10 && isTransientError(error.cause, depth + 1));
const isServerError = (error) => {
    if (error.$metadata?.httpStatusCode !== undefined) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !isTransientError(error)) {
            return true;
        }
        return false;
    }
    return false;
};

exports.isBrowserNetworkError = isBrowserNetworkError;
exports.isClockSkewCorrectedError = isClockSkewCorrectedError;
exports.isClockSkewError = isClockSkewError;
exports.isRetryableByTrait = isRetryableByTrait;
exports.isServerError = isServerError;
exports.isThrottlingError = isThrottlingError;
exports.isTransientError = isTransientError;


/***/ }),

/***/ 8340:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getHomeDir = void 0;
const os_1 = __nccwpck_require__(2037);
const path_1 = __nccwpck_require__(1017);
const homeDirCache = {};
const getHomeDirCacheKey = () => {
    if (process && process.geteuid) {
        return `${process.geteuid()}`;
    }
    return "DEFAULT";
};
const getHomeDir = () => {
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME)
        return HOME;
    if (USERPROFILE)
        return USERPROFILE;
    if (HOMEPATH)
        return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey])
        homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
    return homeDirCache[homeDirCacheKey];
};
exports.getHomeDir = getHomeDir;


/***/ }),

/***/ 4740:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFilepath = void 0;
const crypto_1 = __nccwpck_require__(6113);
const path_1 = __nccwpck_require__(1017);
const getHomeDir_1 = __nccwpck_require__(8340);
const getSSOTokenFilepath = (id) => {
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
};
exports.getSSOTokenFilepath = getSSOTokenFilepath;


/***/ }),

/***/ 9678:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSSOTokenFromFile = exports.tokenIntercept = void 0;
const promises_1 = __nccwpck_require__(3292);
const getSSOTokenFilepath_1 = __nccwpck_require__(4740);
exports.tokenIntercept = {};
const getSSOTokenFromFile = async (id) => {
    if (exports.tokenIntercept[id]) {
        return exports.tokenIntercept[id];
    }
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await (0, promises_1.readFile)(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};
exports.getSSOTokenFromFile = getSSOTokenFromFile;


/***/ }),

/***/ 3507:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var getHomeDir = __nccwpck_require__(8340);
var getSSOTokenFilepath = __nccwpck_require__(4740);
var getSSOTokenFromFile = __nccwpck_require__(9678);
var path = __nccwpck_require__(1017);
var types = __nccwpck_require__(5756);
var readFile = __nccwpck_require__(1664);

const ENV_PROFILE = "AWS_PROFILE";
const DEFAULT_PROFILE = "default";
const getProfileName = (init) => init.profile || process.env[ENV_PROFILE] || DEFAULT_PROFILE;

const CONFIG_PREFIX_SEPARATOR = ".";

const getConfigData = (data) => Object.entries(data)
    .filter(([key]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    if (indexOfSeparator === -1) {
        return false;
    }
    return Object.values(types.IniSectionType).includes(key.substring(0, indexOfSeparator));
})
    .reduce((acc, [key, value]) => {
    const indexOfSeparator = key.indexOf(CONFIG_PREFIX_SEPARATOR);
    const updatedKey = key.substring(0, indexOfSeparator) === types.IniSectionType.PROFILE ? key.substring(indexOfSeparator + 1) : key;
    acc[updatedKey] = value;
    return acc;
}, {
    ...(data.default && { default: data.default }),
});

const ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath = () => process.env[ENV_CONFIG_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "config");

const ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = () => process.env[ENV_CREDENTIALS_PATH] || path.join(getHomeDir.getHomeDir(), ".aws", "credentials");

const prefixKeyRegex = /^([\w-]+)\s(["'])?([\w-@\+\.%:/]+)\2$/;
const profileNameBlockList = ["__proto__", "profile __proto__"];
const parseIni = (iniData) => {
    const map = {};
    let currentSection;
    let currentSubSection;
    for (const iniLine of iniData.split(/\r?\n/)) {
        const trimmedLine = iniLine.split(/(^|\s)[;#]/)[0].trim();
        const isSection = trimmedLine[0] === "[" && trimmedLine[trimmedLine.length - 1] === "]";
        if (isSection) {
            currentSection = undefined;
            currentSubSection = undefined;
            const sectionName = trimmedLine.substring(1, trimmedLine.length - 1);
            const matches = prefixKeyRegex.exec(sectionName);
            if (matches) {
                const [, prefix, , name] = matches;
                if (Object.values(types.IniSectionType).includes(prefix)) {
                    currentSection = [prefix, name].join(CONFIG_PREFIX_SEPARATOR);
                }
            }
            else {
                currentSection = sectionName;
            }
            if (profileNameBlockList.includes(sectionName)) {
                throw new Error(`Found invalid profile name "${sectionName}"`);
            }
        }
        else if (currentSection) {
            const indexOfEqualsSign = trimmedLine.indexOf("=");
            if (![0, -1].includes(indexOfEqualsSign)) {
                const [name, value] = [
                    trimmedLine.substring(0, indexOfEqualsSign).trim(),
                    trimmedLine.substring(indexOfEqualsSign + 1).trim(),
                ];
                if (value === "") {
                    currentSubSection = name;
                }
                else {
                    if (currentSubSection && iniLine.trimStart() === iniLine) {
                        currentSubSection = undefined;
                    }
                    map[currentSection] = map[currentSection] || {};
                    const key = currentSubSection ? [currentSubSection, name].join(CONFIG_PREFIX_SEPARATOR) : name;
                    map[currentSection][key] = value;
                }
            }
        }
    }
    return map;
};

const swallowError$1 = () => ({});
const loadSharedConfigFiles = async (init = {}) => {
    const { filepath = getCredentialsFilepath(), configFilepath = getConfigFilepath() } = init;
    const homeDir = getHomeDir.getHomeDir();
    const relativeHomeDirPrefix = "~/";
    let resolvedFilepath = filepath;
    if (filepath.startsWith(relativeHomeDirPrefix)) {
        resolvedFilepath = path.join(homeDir, filepath.slice(2));
    }
    let resolvedConfigFilepath = configFilepath;
    if (configFilepath.startsWith(relativeHomeDirPrefix)) {
        resolvedConfigFilepath = path.join(homeDir, configFilepath.slice(2));
    }
    const parsedFiles = await Promise.all([
        readFile.readFile(resolvedConfigFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .then(getConfigData)
            .catch(swallowError$1),
        readFile.readFile(resolvedFilepath, {
            ignoreCache: init.ignoreCache,
        })
            .then(parseIni)
            .catch(swallowError$1),
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1],
    };
};

const getSsoSessionData = (data) => Object.entries(data)
    .filter(([key]) => key.startsWith(types.IniSectionType.SSO_SESSION + CONFIG_PREFIX_SEPARATOR))
    .reduce((acc, [key, value]) => ({ ...acc, [key.substring(key.indexOf(CONFIG_PREFIX_SEPARATOR) + 1)]: value }), {});

const swallowError = () => ({});
const loadSsoSessionData = async (init = {}) => readFile.readFile(init.configFilepath ?? getConfigFilepath())
    .then(parseIni)
    .then(getSsoSessionData)
    .catch(swallowError);

const mergeConfigFiles = (...files) => {
    const merged = {};
    for (const file of files) {
        for (const [key, values] of Object.entries(file)) {
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            }
            else {
                merged[key] = values;
            }
        }
    }
    return merged;
};

const parseKnownFiles = async (init) => {
    const parsedFiles = await loadSharedConfigFiles(init);
    return mergeConfigFiles(parsedFiles.configFile, parsedFiles.credentialsFile);
};

const externalDataInterceptor = {
    getFileRecord() {
        return readFile.fileIntercept;
    },
    interceptFile(path, contents) {
        readFile.fileIntercept[path] = Promise.resolve(contents);
    },
    getTokenRecord() {
        return getSSOTokenFromFile.tokenIntercept;
    },
    interceptToken(id, contents) {
        getSSOTokenFromFile.tokenIntercept[id] = contents;
    },
};

Object.defineProperty(exports, "getSSOTokenFromFile", ({
    enumerable: true,
    get: function () { return getSSOTokenFromFile.getSSOTokenFromFile; }
}));
Object.defineProperty(exports, "readFile", ({
    enumerable: true,
    get: function () { return readFile.readFile; }
}));
exports.CONFIG_PREFIX_SEPARATOR = CONFIG_PREFIX_SEPARATOR;
exports.DEFAULT_PROFILE = DEFAULT_PROFILE;
exports.ENV_PROFILE = ENV_PROFILE;
exports.externalDataInterceptor = externalDataInterceptor;
exports.getProfileName = getProfileName;
exports.loadSharedConfigFiles = loadSharedConfigFiles;
exports.loadSsoSessionData = loadSsoSessionData;
exports.parseKnownFiles = parseKnownFiles;
Object.keys(getHomeDir).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return getHomeDir[k]; }
    });
});
Object.keys(getSSOTokenFilepath).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return getSSOTokenFilepath[k]; }
    });
});


/***/ }),

/***/ 1664:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readFile = exports.fileIntercept = exports.filePromises = void 0;
const promises_1 = __nccwpck_require__(3977);
exports.filePromises = {};
exports.fileIntercept = {};
const readFile = (path, options) => {
    if (exports.fileIntercept[path] !== undefined) {
        return exports.fileIntercept[path];
    }
    if (!exports.filePromises[path] || options?.ignoreCache) {
        exports.filePromises[path] = (0, promises_1.readFile)(path, "utf8");
    }
    return exports.filePromises[path];
};
exports.readFile = readFile;


/***/ }),

/***/ 1528:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilHexEncoding = __nccwpck_require__(5364);
var utilUtf8 = __nccwpck_require__(1895);
var isArrayBuffer = __nccwpck_require__(780);
var protocolHttp = __nccwpck_require__(4418);
var utilMiddleware = __nccwpck_require__(2390);
var utilUriEscape = __nccwpck_require__(4197);

const ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
const CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
const AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
const SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
const EXPIRES_QUERY_PARAM = "X-Amz-Expires";
const SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
const TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
const REGION_SET_PARAM = "X-Amz-Region-Set";
const AUTH_HEADER = "authorization";
const AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
const DATE_HEADER = "date";
const GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
const SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
const SHA256_HEADER = "x-amz-content-sha256";
const TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
const HOST_HEADER = "host";
const ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true,
};
const PROXY_HEADER_PATTERN = /^proxy-/;
const SEC_HEADER_PATTERN = /^sec-/;
const UNSIGNABLE_PATTERNS = [/^proxy-/i, /^sec-/i];
const ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
const ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
const EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
const UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
const MAX_CACHE_SIZE = 50;
const KEY_TYPE_IDENTIFIER = "aws4_request";
const MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;

const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service) => `${shortDate}/${region}/${service}/${KEY_TYPE_IDENTIFIER}`;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service) => {
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${utilHexEncoding.toHex(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while (cacheQueue.length > MAX_CACHE_SIZE) {
        delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [shortDate, region, service, KEY_TYPE_IDENTIFIER]) {
        key = await hmac(sha256Constructor, key, signable);
    }
    return (signingKeyCache[cacheKey] = key);
};
const clearCredentialCache = () => {
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey) => {
        delete signingKeyCache[cacheKey];
    });
};
const hmac = (ctor, secret, data) => {
    const hash = new ctor(secret);
    hash.update(utilUtf8.toUint8Array(data));
    return hash.digest();
};

const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders) => {
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()) {
        if (headers[headerName] == undefined) {
            continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS ||
            unsignableHeaders?.has(canonicalHeaderName) ||
            PROXY_HEADER_PATTERN.test(canonicalHeaderName) ||
            SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || (signableHeaders && !signableHeaders.has(canonicalHeaderName))) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
};

const getPayloadHash = async ({ headers, body }, hashConstructor) => {
    for (const headerName of Object.keys(headers)) {
        if (headerName.toLowerCase() === SHA256_HEADER) {
            return headers[headerName];
        }
    }
    if (body == undefined) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    }
    else if (typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer.isArrayBuffer(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update(utilUtf8.toUint8Array(body));
        return utilHexEncoding.toHex(await hashCtor.digest());
    }
    return UNSIGNED_PAYLOAD;
};

class HeaderFormatter {
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = utilUtf8.fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = utilUtf8.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set(utilHexEncoding.fromHex(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
}
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
class Int64 {
    bytes;
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9_223_372_036_854_775_807 || number < -9223372036854776e3) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 0b10000000;
        if (negative) {
            negate(bytes);
        }
        return parseInt(utilHexEncoding.toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
}
function negate(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 0xff;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
            break;
    }
}

const hasHeader = (soughtHeader, headers) => {
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)) {
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};

const moveHeadersToQuery = (request, options = {}) => {
    const { headers, query = {} } = protocolHttp.HttpRequest.clone(request);
    for (const name of Object.keys(headers)) {
        const lname = name.toLowerCase();
        if ((lname.slice(0, 6) === "x-amz-" && !options.unhoistableHeaders?.has(lname)) ||
            options.hoistableHeaders?.has(lname)) {
            query[name] = headers[name];
            delete headers[name];
        }
    }
    return {
        ...request,
        headers,
        query,
    };
};

const prepareRequest = (request) => {
    request = protocolHttp.HttpRequest.clone(request);
    for (const headerName of Object.keys(request.headers)) {
        if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
        }
    }
    return request;
};

const getCanonicalQuery = ({ query = {} }) => {
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query)) {
        if (key.toLowerCase() === SIGNATURE_HEADER) {
            continue;
        }
        const encodedKey = utilUriEscape.escapeUri(key);
        keys.push(encodedKey);
        const value = query[key];
        if (typeof value === "string") {
            serialized[encodedKey] = `${encodedKey}=${utilUriEscape.escapeUri(value)}`;
        }
        else if (Array.isArray(value)) {
            serialized[encodedKey] = value
                .slice(0)
                .reduce((encoded, value) => encoded.concat([`${encodedKey}=${utilUriEscape.escapeUri(value)}`]), [])
                .sort()
                .join("&");
        }
    }
    return keys
        .sort()
        .map((key) => serialized[key])
        .filter((serialized) => serialized)
        .join("&");
};

const iso8601 = (time) => toDate(time)
    .toISOString()
    .replace(/\.\d{3}Z$/, "Z");
const toDate = (time) => {
    if (typeof time === "number") {
        return new Date(time * 1000);
    }
    if (typeof time === "string") {
        if (Number(time)) {
            return new Date(Number(time) * 1000);
        }
        return new Date(time);
    }
    return time;
};

class SignatureV4Base {
    service;
    regionProvider;
    credentialProvider;
    sha256;
    uriEscapePath;
    applyChecksum;
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = utilMiddleware.normalizeProvider(region);
        this.credentialProvider = utilMiddleware.normalizeProvider(credentials);
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${getCanonicalQuery(request)}
${sortedHeaders.map((name) => `${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest, algorithmIdentifier) {
        const hash = new this.sha256();
        hash.update(utilUtf8.toUint8Array(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${algorithmIdentifier}
${longDate}
${credentialScope}
${utilHexEncoding.toHex(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")) {
                if (pathSegment?.length === 0)
                    continue;
                if (pathSegment === ".")
                    continue;
                if (pathSegment === "..") {
                    normalizedPathSegments.pop();
                }
                else {
                    normalizedPathSegments.push(pathSegment);
                }
            }
            const normalizedPath = `${path?.startsWith("/") ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && path?.endsWith("/") ? "/" : ""}`;
            const doubleEncoded = utilUriEscape.escapeUri(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    }
    validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" ||
            typeof credentials.accessKeyId !== "string" ||
            typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
        }
    }
    formatDate(now) {
        const longDate = iso8601(now).replace(/[\-:]/g, "");
        return {
            longDate,
            shortDate: longDate.slice(0, 8),
        };
    }
    getCanonicalHeaderList(headers) {
        return Object.keys(headers).sort().join(";");
    }
}

class SignatureV4 extends SignatureV4Base {
    headerFormatter = new HeaderFormatter();
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true, }) {
        super({
            applyChecksum,
            credentials,
            region,
            service,
            sha256,
            uriEscapePath,
        });
    }
    async presign(originalRequest, options = {}) {
        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, hoistableHeaders, signingRegion, signingService, } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const { longDate, shortDate } = this.formatDate(signingDate);
        if (expiresIn > MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders, hoistableHeaders });
        if (credentials.sessionToken) {
            request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
        request.query[CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        request.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(canonicalHeaders);
        request.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await getPayloadHash(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, options) {
        if (typeof toSign === "string") {
            return this.signString(toSign, options);
        }
        else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
        }
        else if (toSign.message) {
            return this.signMessage(toSign, options);
        }
        else {
            return this.signRequest(toSign, options);
        }
    }
    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion ?? (await this.regionProvider());
        const { shortDate, longDate } = this.formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        const hashedPayload = await getPayloadHash({ headers: {}, body: payload }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = utilHexEncoding.toHex(await hash.digest());
        const stringToSign = [
            EVENT_ALGORITHM_IDENTIFIER,
            longDate,
            scope,
            priorSignature,
            hashedHeaders,
            hashedPayload,
        ].join("\n");
        return this.signString(stringToSign, { signingDate, signingRegion: region, signingService });
    }
    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
            headers: this.headerFormatter.format(signableMessage.message.headers),
            payload: signableMessage.message.body,
        }, {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature,
        });
        return promise.then((signature) => {
            return { message: signableMessage.message, signature };
        });
    }
    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const { shortDate } = this.formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update(utilUtf8.toUint8Array(stringToSign));
        return utilHexEncoding.toHex(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService, } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion ?? (await this.regionProvider());
        const request = prepareRequest(requestToSign);
        const { longDate, shortDate } = this.formatDate(signingDate);
        const scope = createScope(shortDate, region, signingService ?? this.service);
        request.headers[AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await getPayloadHash(request, this.sha256);
        if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[AUTH_HEADER] =
            `${ALGORITHM_IDENTIFIER} ` +
                `Credential=${credentials.accessKeyId}/${scope}, ` +
                `SignedHeaders=${this.getCanonicalHeaderList(canonicalHeaders)}, ` +
                `Signature=${signature}`;
        return request;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest, ALGORITHM_IDENTIFIER);
        const hash = new this.sha256(await keyPromise);
        hash.update(utilUtf8.toUint8Array(stringToSign));
        return utilHexEncoding.toHex(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
        return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
    }
}

const signatureV4aContainer = {
    SignatureV4a: null,
};

exports.ALGORITHM_IDENTIFIER = ALGORITHM_IDENTIFIER;
exports.ALGORITHM_IDENTIFIER_V4A = ALGORITHM_IDENTIFIER_V4A;
exports.ALGORITHM_QUERY_PARAM = ALGORITHM_QUERY_PARAM;
exports.ALWAYS_UNSIGNABLE_HEADERS = ALWAYS_UNSIGNABLE_HEADERS;
exports.AMZ_DATE_HEADER = AMZ_DATE_HEADER;
exports.AMZ_DATE_QUERY_PARAM = AMZ_DATE_QUERY_PARAM;
exports.AUTH_HEADER = AUTH_HEADER;
exports.CREDENTIAL_QUERY_PARAM = CREDENTIAL_QUERY_PARAM;
exports.DATE_HEADER = DATE_HEADER;
exports.EVENT_ALGORITHM_IDENTIFIER = EVENT_ALGORITHM_IDENTIFIER;
exports.EXPIRES_QUERY_PARAM = EXPIRES_QUERY_PARAM;
exports.GENERATED_HEADERS = GENERATED_HEADERS;
exports.HOST_HEADER = HOST_HEADER;
exports.KEY_TYPE_IDENTIFIER = KEY_TYPE_IDENTIFIER;
exports.MAX_CACHE_SIZE = MAX_CACHE_SIZE;
exports.MAX_PRESIGNED_TTL = MAX_PRESIGNED_TTL;
exports.PROXY_HEADER_PATTERN = PROXY_HEADER_PATTERN;
exports.REGION_SET_PARAM = REGION_SET_PARAM;
exports.SEC_HEADER_PATTERN = SEC_HEADER_PATTERN;
exports.SHA256_HEADER = SHA256_HEADER;
exports.SIGNATURE_HEADER = SIGNATURE_HEADER;
exports.SIGNATURE_QUERY_PARAM = SIGNATURE_QUERY_PARAM;
exports.SIGNED_HEADERS_QUERY_PARAM = SIGNED_HEADERS_QUERY_PARAM;
exports.SignatureV4 = SignatureV4;
exports.SignatureV4Base = SignatureV4Base;
exports.TOKEN_HEADER = TOKEN_HEADER;
exports.TOKEN_QUERY_PARAM = TOKEN_QUERY_PARAM;
exports.UNSIGNABLE_PATTERNS = UNSIGNABLE_PATTERNS;
exports.UNSIGNED_PAYLOAD = UNSIGNED_PAYLOAD;
exports.clearCredentialCache = clearCredentialCache;
exports.createScope = createScope;
exports.getCanonicalHeaders = getCanonicalHeaders;
exports.getCanonicalQuery = getCanonicalQuery;
exports.getPayloadHash = getPayloadHash;
exports.getSigningKey = getSigningKey;
exports.hasHeader = hasHeader;
exports.moveHeadersToQuery = moveHeadersToQuery;
exports.prepareRequest = prepareRequest;
exports.signatureV4aContainer = signatureV4aContainer;


/***/ }),

/***/ 3570:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var middlewareStack = __nccwpck_require__(7911);
var protocols = __nccwpck_require__(2241);
var types = __nccwpck_require__(5756);
var schema = __nccwpck_require__(9826);
var serde = __nccwpck_require__(7669);

class Client {
    config;
    middlewareStack = middlewareStack.constructStack();
    initConfig;
    handlers;
    constructor(config) {
        this.config = config;
        const { protocol, protocolSettings } = config;
        if (protocolSettings) {
            if (typeof protocol === "function") {
                config.protocol = new protocol(protocolSettings);
            }
        }
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const useHandlerCache = options === undefined && this.config.cacheMiddleware === true;
        let handler;
        if (useHandlerCache) {
            if (!this.handlers) {
                this.handlers = new WeakMap();
            }
            const handlers = this.handlers;
            if (handlers.has(command.constructor)) {
                handler = handlers.get(command.constructor);
            }
            else {
                handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
                handlers.set(command.constructor, handler);
            }
        }
        else {
            delete this.handlers;
            handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        }
        if (callback) {
            handler(command)
                .then((result) => callback(null, result.output), (err) => callback(err))
                .catch(() => { });
        }
        else {
            return handler(command).then((result) => result.output);
        }
    }
    destroy() {
        this.config?.requestHandler?.destroy?.();
        delete this.handlers;
    }
}

const SENSITIVE_STRING$1 = "***SensitiveInformation***";
function schemaLogFilter(schema$1, data) {
    if (data == null) {
        return data;
    }
    const ns = schema.NormalizedSchema.of(schema$1);
    if (ns.getMergedTraits().sensitive) {
        return SENSITIVE_STRING$1;
    }
    if (ns.isListSchema()) {
        const isSensitive = !!ns.getValueSchema().getMergedTraits().sensitive;
        if (isSensitive) {
            return SENSITIVE_STRING$1;
        }
    }
    else if (ns.isMapSchema()) {
        const isSensitive = !!ns.getKeySchema().getMergedTraits().sensitive || !!ns.getValueSchema().getMergedTraits().sensitive;
        if (isSensitive) {
            return SENSITIVE_STRING$1;
        }
    }
    else if (ns.isStructSchema() && typeof data === "object") {
        const object = data;
        const newObject = {};
        for (const [member, memberNs] of ns.structIterator()) {
            if (object[member] != null) {
                newObject[member] = schemaLogFilter(memberNs, object[member]);
            }
        }
        return newObject;
    }
    return data;
}

class Command {
    middlewareStack = middlewareStack.constructStack();
    schema;
    static classBuilder() {
        return new ClassBuilder();
    }
    resolveMiddlewareWithContext(clientStack, configuration, options, { middlewareFn, clientName, commandName, inputFilterSensitiveLog, outputFilterSensitiveLog, smithyContext, additionalContext, CommandCtor, }) {
        for (const mw of middlewareFn.bind(this)(CommandCtor, clientStack, configuration, options)) {
            this.middlewareStack.use(mw);
        }
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog,
            outputFilterSensitiveLog,
            [types.SMITHY_CONTEXT_KEY]: {
                commandInstance: this,
                ...smithyContext,
            },
            ...additionalContext,
        };
        const { requestHandler } = configuration;
        return stack.resolve((request) => requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
}
class ClassBuilder {
    _init = () => { };
    _ep = {};
    _middlewareFn = () => [];
    _commandName = "";
    _clientName = "";
    _additionalContext = {};
    _smithyContext = {};
    _inputFilterSensitiveLog = undefined;
    _outputFilterSensitiveLog = undefined;
    _serializer = null;
    _deserializer = null;
    _operationSchema;
    init(cb) {
        this._init = cb;
    }
    ep(endpointParameterInstructions) {
        this._ep = endpointParameterInstructions;
        return this;
    }
    m(middlewareSupplier) {
        this._middlewareFn = middlewareSupplier;
        return this;
    }
    s(service, operation, smithyContext = {}) {
        this._smithyContext = {
            service,
            operation,
            ...smithyContext,
        };
        return this;
    }
    c(additionalContext = {}) {
        this._additionalContext = additionalContext;
        return this;
    }
    n(clientName, commandName) {
        this._clientName = clientName;
        this._commandName = commandName;
        return this;
    }
    f(inputFilter = (_) => _, outputFilter = (_) => _) {
        this._inputFilterSensitiveLog = inputFilter;
        this._outputFilterSensitiveLog = outputFilter;
        return this;
    }
    ser(serializer) {
        this._serializer = serializer;
        return this;
    }
    de(deserializer) {
        this._deserializer = deserializer;
        return this;
    }
    sc(operation) {
        this._operationSchema = operation;
        this._smithyContext.operationSchema = operation;
        return this;
    }
    build() {
        const closure = this;
        let CommandRef;
        return (CommandRef = class extends Command {
            input;
            static getEndpointParameterInstructions() {
                return closure._ep;
            }
            constructor(...[input]) {
                super();
                this.input = input ?? {};
                closure._init(this);
                this.schema = closure._operationSchema;
            }
            resolveMiddleware(stack, configuration, options) {
                const op = closure._operationSchema;
                const input = op?.[4] ?? op?.input;
                const output = op?.[5] ?? op?.output;
                return this.resolveMiddlewareWithContext(stack, configuration, options, {
                    CommandCtor: CommandRef,
                    middlewareFn: closure._middlewareFn,
                    clientName: closure._clientName,
                    commandName: closure._commandName,
                    inputFilterSensitiveLog: closure._inputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, input) : (_) => _),
                    outputFilterSensitiveLog: closure._outputFilterSensitiveLog ?? (op ? schemaLogFilter.bind(null, output) : (_) => _),
                    smithyContext: closure._smithyContext,
                    additionalContext: closure._additionalContext,
                });
            }
            serialize = closure._serializer;
            deserialize = closure._deserializer;
        });
    }
}

const SENSITIVE_STRING = "***SensitiveInformation***";

const createAggregatedClient = (commands, Client) => {
    for (const command of Object.keys(commands)) {
        const CommandCtor = commands[command];
        const methodImpl = async function (args, optionsOrCb, cb) {
            const command = new CommandCtor(args);
            if (typeof optionsOrCb === "function") {
                this.send(command, optionsOrCb);
            }
            else if (typeof cb === "function") {
                if (typeof optionsOrCb !== "object")
                    throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                this.send(command, optionsOrCb || {}, cb);
            }
            else {
                return this.send(command, optionsOrCb);
            }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client.prototype[methodName] = methodImpl;
    }
};

class ServiceException extends Error {
    $fault;
    $response;
    $retryable;
    $metadata;
    constructor(options) {
        super(options.message);
        Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
    static isInstance(value) {
        if (!value)
            return false;
        const candidate = value;
        return (ServiceException.prototype.isPrototypeOf(candidate) ||
            (Boolean(candidate.$fault) &&
                Boolean(candidate.$metadata) &&
                (candidate.$fault === "client" || candidate.$fault === "server")));
    }
    static [Symbol.hasInstance](instance) {
        if (!instance)
            return false;
        const candidate = instance;
        if (this === ServiceException) {
            return ServiceException.isInstance(instance);
        }
        if (ServiceException.isInstance(instance)) {
            if (candidate.name && this.name) {
                return this.prototype.isPrototypeOf(instance) || candidate.name === this.name;
            }
            return this.prototype.isPrototypeOf(instance);
        }
        return false;
    }
}
const decorateServiceException = (exception, additions = {}) => {
    Object.entries(additions)
        .filter(([, v]) => v !== undefined)
        .forEach(([k, v]) => {
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};

const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode }) => {
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: parsedBody?.code || parsedBody?.Code || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata,
    });
    throw decorateServiceException(response, parsedBody);
};
const withBaseException = (ExceptionCtor) => {
    return ({ output, parsedBody, errorCode }) => {
        throwDefaultError({ output, parsedBody, exceptionCtor: ExceptionCtor, errorCode });
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});

const loadConfigsForDefaultMode = (mode) => {
    switch (mode) {
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100,
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100,
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000,
            };
        default:
            return {};
    }
};

let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version) => {
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 16) {
        warningEmitted = true;
    }
};

const getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    for (const id in types.AlgorithmId) {
        const algorithmId = types.AlgorithmId[id];
        if (runtimeConfig[algorithmId] === undefined) {
            continue;
        }
        checksumAlgorithms.push({
            algorithmId: () => algorithmId,
            checksumConstructor: () => runtimeConfig[algorithmId],
        });
    }
    return {
        addChecksumAlgorithm(algo) {
            checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return checksumAlgorithms;
        },
    };
};
const resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

const getRetryConfiguration = (runtimeConfig) => {
    return {
        setRetryStrategy(retryStrategy) {
            runtimeConfig.retryStrategy = retryStrategy;
        },
        retryStrategy() {
            return runtimeConfig.retryStrategy;
        },
    };
};
const resolveRetryRuntimeConfig = (retryStrategyConfiguration) => {
    const runtimeConfig = {};
    runtimeConfig.retryStrategy = retryStrategyConfiguration.retryStrategy();
    return runtimeConfig;
};

const getDefaultExtensionConfiguration = (runtimeConfig) => {
    return Object.assign(getChecksumConfiguration(runtimeConfig), getRetryConfiguration(runtimeConfig));
};
const getDefaultClientConfiguration = getDefaultExtensionConfiguration;
const resolveDefaultRuntimeConfig = (config) => {
    return Object.assign(resolveChecksumRuntimeConfig(config), resolveRetryRuntimeConfig(config));
};

const getArrayIfSingleItem = (mayBeArray) => Array.isArray(mayBeArray) ? mayBeArray : [mayBeArray];

const getValueFromTextNode = (obj) => {
    const textNodeName = "#text";
    for (const key in obj) {
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
            obj[key] = obj[key][textNodeName];
        }
        else if (typeof obj[key] === "object" && obj[key] !== null) {
            obj[key] = getValueFromTextNode(obj[key]);
        }
    }
    return obj;
};

const isSerializableHeaderValue = (value) => {
    return value != null;
};

class NoOpLogger {
    trace() { }
    debug() { }
    info() { }
    warn() { }
    error() { }
}

function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    }
    else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        }
        else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)) {
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
const convertMap = (target) => {
    const output = {};
    for (const [k, v] of Object.entries(target || {})) {
        output[k] = [, v];
    }
    return output;
};
const take = (source, instructions) => {
    const out = {};
    for (const key in instructions) {
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
const mapWithFilter = (target, filter, instructions) => {
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value]) => {
        if (Array.isArray(value)) {
            _instructions[key] = value;
        }
        else {
            if (typeof value === "function") {
                _instructions[key] = [filter, value()];
            }
            else {
                _instructions[key] = [filter, value];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey) => {
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [, instruction];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if ((typeof filter === "function" && filter(source[sourceKey])) || (typeof filter !== "function" && !!filter)) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(void 0)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        }
        else if (customFilterPassed) {
            target[targetKey] = value();
        }
    }
    else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = (typeof filter === "function" && !!filter(value)) || (typeof filter !== "function" && !!filter);
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_) => _ != null;
const pass = (_) => _;

const serializeFloat = (value) => {
    if (value !== value) {
        return "NaN";
    }
    switch (value) {
        case Infinity:
            return "Infinity";
        case -Infinity:
            return "-Infinity";
        default:
            return value;
    }
};
const serializeDateTime = (date) => date.toISOString().replace(".000Z", "Z");

const _json = (obj) => {
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_) => _ != null).map(_json);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)) {
            if (obj[key] == null) {
                continue;
            }
            target[key] = _json(obj[key]);
        }
        return target;
    }
    return obj;
};

Object.defineProperty(exports, "collectBody", ({
    enumerable: true,
    get: function () { return protocols.collectBody; }
}));
Object.defineProperty(exports, "extendedEncodeURIComponent", ({
    enumerable: true,
    get: function () { return protocols.extendedEncodeURIComponent; }
}));
Object.defineProperty(exports, "resolvedPath", ({
    enumerable: true,
    get: function () { return protocols.resolvedPath; }
}));
exports.Client = Client;
exports.Command = Command;
exports.NoOpLogger = NoOpLogger;
exports.SENSITIVE_STRING = SENSITIVE_STRING;
exports.ServiceException = ServiceException;
exports._json = _json;
exports.convertMap = convertMap;
exports.createAggregatedClient = createAggregatedClient;
exports.decorateServiceException = decorateServiceException;
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;
exports.getArrayIfSingleItem = getArrayIfSingleItem;
exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration;
exports.getValueFromTextNode = getValueFromTextNode;
exports.isSerializableHeaderValue = isSerializableHeaderValue;
exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;
exports.map = map;
exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;
exports.serializeDateTime = serializeDateTime;
exports.serializeFloat = serializeFloat;
exports.take = take;
exports.throwDefaultError = throwDefaultError;
exports.withBaseException = withBaseException;
Object.keys(serde).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return serde[k]; }
    });
});


/***/ }),

/***/ 5756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.HttpAuthLocation = void 0;
(function (HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));

exports.HttpApiKeyAuthLocation = void 0;
(function (HttpApiKeyAuthLocation) {
    HttpApiKeyAuthLocation["HEADER"] = "header";
    HttpApiKeyAuthLocation["QUERY"] = "query";
})(exports.HttpApiKeyAuthLocation || (exports.HttpApiKeyAuthLocation = {}));

exports.EndpointURLScheme = void 0;
(function (EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));

exports.AlgorithmId = void 0;
(function (AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(exports.AlgorithmId || (exports.AlgorithmId = {}));
const getChecksumConfiguration = (runtimeConfig) => {
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: () => exports.AlgorithmId.SHA256,
            checksumConstructor: () => runtimeConfig.sha256,
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: () => exports.AlgorithmId.MD5,
            checksumConstructor: () => runtimeConfig.md5,
        });
    }
    return {
        addChecksumAlgorithm(algo) {
            checksumAlgorithms.push(algo);
        },
        checksumAlgorithms() {
            return checksumAlgorithms;
        },
    };
};
const resolveChecksumRuntimeConfig = (clientConfig) => {
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm) => {
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};

const getDefaultClientConfiguration = (runtimeConfig) => {
    return getChecksumConfiguration(runtimeConfig);
};
const resolveDefaultRuntimeConfig = (config) => {
    return resolveChecksumRuntimeConfig(config);
};

exports.FieldPosition = void 0;
(function (FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(exports.FieldPosition || (exports.FieldPosition = {}));

const SMITHY_CONTEXT_KEY = "__smithy_context";

exports.IniSectionType = void 0;
(function (IniSectionType) {
    IniSectionType["PROFILE"] = "profile";
    IniSectionType["SSO_SESSION"] = "sso-session";
    IniSectionType["SERVICES"] = "services";
})(exports.IniSectionType || (exports.IniSectionType = {}));

exports.RequestHandlerProtocol = void 0;
(function (RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));

exports.SMITHY_CONTEXT_KEY = SMITHY_CONTEXT_KEY;
exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;


/***/ }),

/***/ 4681:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var querystringParser = __nccwpck_require__(4769);

const parseUrl = (url) => {
    if (typeof url === "string") {
        return parseUrl(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = querystringParser.parseQueryString(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query,
    };
};

exports.parseUrl = parseUrl;


/***/ }),

/***/ 305:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(1381);
const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64 = (input) => {
    if ((input.length * 3) % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
exports.fromBase64 = fromBase64;


/***/ }),

/***/ 5600:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var fromBase64 = __nccwpck_require__(305);
var toBase64 = __nccwpck_require__(4730);



Object.keys(fromBase64).forEach(function (k) {
	if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return fromBase64[k]; }
	});
});
Object.keys(toBase64).forEach(function (k) {
	if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return toBase64[k]; }
	});
});


/***/ }),

/***/ 4730:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toBase64 = void 0;
const util_buffer_from_1 = __nccwpck_require__(1381);
const util_utf8_1 = __nccwpck_require__(1895);
const toBase64 = (_input) => {
    let input;
    if (typeof _input === "string") {
        input = (0, util_utf8_1.fromUtf8)(_input);
    }
    else {
        input = _input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
};
exports.toBase64 = toBase64;


/***/ }),

/***/ 713:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null;
const calculateBodyLength = (body) => {
    if (typeof body === "string") {
        if (TEXT_ENCODER) {
            return TEXT_ENCODER.encode(body).byteLength;
        }
        let len = body.length;
        for (let i = len - 1; i >= 0; i--) {
            const code = body.charCodeAt(i);
            if (code > 0x7f && code <= 0x7ff)
                len++;
            else if (code > 0x7ff && code <= 0xffff)
                len += 2;
            if (code >= 0xdc00 && code <= 0xdfff)
                i--;
        }
        return len;
    }
    else if (typeof body.byteLength === "number") {
        return body.byteLength;
    }
    else if (typeof body.size === "number") {
        return body.size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
};

exports.calculateBodyLength = calculateBodyLength;


/***/ }),

/***/ 8075:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var node_fs = __nccwpck_require__(7561);

const calculateBodyLength = (body) => {
    if (!body) {
        return 0;
    }
    if (typeof body === "string") {
        return Buffer.byteLength(body);
    }
    else if (typeof body.byteLength === "number") {
        return body.byteLength;
    }
    else if (typeof body.size === "number") {
        return body.size;
    }
    else if (typeof body.start === "number" && typeof body.end === "number") {
        return body.end + 1 - body.start;
    }
    else if (body instanceof node_fs.ReadStream) {
        if (body.path != null) {
            return node_fs.lstatSync(body.path).size;
        }
        else if (typeof body.fd === "number") {
            return node_fs.fstatSync(body.fd).size;
        }
    }
    throw new Error(`Body Length computation failed for ${body}`);
};

exports.calculateBodyLength = calculateBodyLength;


/***/ }),

/***/ 1381:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var isArrayBuffer = __nccwpck_require__(780);
var buffer = __nccwpck_require__(4300);

const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset) => {
    if (!isArrayBuffer.isArrayBuffer(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer.Buffer.from(input, offset, length);
};
const fromString = (input, encoding) => {
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer.Buffer.from(input, encoding) : buffer.Buffer.from(input);
};

exports.fromArrayBuffer = fromArrayBuffer;
exports.fromString = fromString;


/***/ }),

/***/ 3375:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const booleanSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    if (obj[key] === "true")
        return true;
    if (obj[key] === "false")
        return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};

const numberSelector = (obj, key, type) => {
    if (!(key in obj))
        return undefined;
    const numberValue = parseInt(obj[key], 10);
    if (Number.isNaN(numberValue)) {
        throw new TypeError(`Cannot load ${type} '${key}'. Expected number, got '${obj[key]}'.`);
    }
    return numberValue;
};

exports.SelectorType = void 0;
(function (SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(exports.SelectorType || (exports.SelectorType = {}));

exports.booleanSelector = booleanSelector;
exports.numberSelector = numberSelector;


/***/ }),

/***/ 2429:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var configResolver = __nccwpck_require__(3098);
var nodeConfigProvider = __nccwpck_require__(3461);
var propertyProvider = __nccwpck_require__(9721);

const AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
const AWS_REGION_ENV = "AWS_REGION";
const AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
const ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"];
const IMDS_REGION_PATH = "/latest/meta-data/placement/region";

const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
const NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env) => {
        return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile) => {
        return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy",
};

const resolveDefaultsModeConfig = ({ region = nodeConfigProvider.loadConfig(configResolver.NODE_REGION_CONFIG_OPTIONS), defaultsMode = nodeConfigProvider.loadConfig(NODE_DEFAULTS_MODE_CONFIG_OPTIONS), } = {}) => propertyProvider.memoize(async () => {
    const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
    switch (mode?.toLowerCase()) {
        case "auto":
            return resolveNodeDefaultsModeAuto(region);
        case "in-region":
        case "cross-region":
        case "mobile":
        case "standard":
        case "legacy":
            return Promise.resolve(mode?.toLocaleLowerCase());
        case undefined:
            return Promise.resolve("legacy");
        default:
            throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
    }
});
const resolveNodeDefaultsModeAuto = async (clientRegion) => {
    if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
            return "standard";
        }
        if (resolvedRegion === inferredRegion) {
            return "in-region";
        }
        else {
            return "cross-region";
        }
    }
    return "standard";
};
const inferPhysicalRegion = async () => {
    if (process.env[AWS_EXECUTION_ENV] && (process.env[AWS_REGION_ENV] || process.env[AWS_DEFAULT_REGION_ENV])) {
        return process.env[AWS_REGION_ENV] ?? process.env[AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[ENV_IMDS_DISABLED]) {
        try {
            const { getInstanceMetadataEndpoint, httpRequest } = await __nccwpck_require__.e(/* import() */ 477).then(__nccwpck_require__.t.bind(__nccwpck_require__, 7477, 19));
            const endpoint = await getInstanceMetadataEndpoint();
            return (await httpRequest({ ...endpoint, path: IMDS_REGION_PATH })).toString();
        }
        catch (e) {
        }
    }
};

exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;


/***/ }),

/***/ 5473:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var types = __nccwpck_require__(5756);

class EndpointCache {
    capacity;
    data = new Map();
    parameters = [];
    constructor({ size, params }) {
        this.capacity = size ?? 50;
        if (params) {
            this.parameters = params;
        }
    }
    get(endpointParams, resolver) {
        const key = this.hash(endpointParams);
        if (key === false) {
            return resolver();
        }
        if (!this.data.has(key)) {
            if (this.data.size > this.capacity + 10) {
                const keys = this.data.keys();
                let i = 0;
                while (true) {
                    const { value, done } = keys.next();
                    this.data.delete(value);
                    if (done || ++i > 10) {
                        break;
                    }
                }
            }
            this.data.set(key, resolver());
        }
        return this.data.get(key);
    }
    size() {
        return this.data.size;
    }
    hash(endpointParams) {
        let buffer = "";
        const { parameters } = this;
        if (parameters.length === 0) {
            return false;
        }
        for (const param of parameters) {
            const val = String(endpointParams[param] ?? "");
            if (val.includes("|;")) {
                return false;
            }
            buffer += val + "|;";
        }
        return buffer;
    }
}

const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value) => IP_V4_REGEX.test(value) || (value.startsWith("[") && value.endsWith("]"));

const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false) => {
    if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels) {
        if (!isValidHostLabel(label)) {
            return false;
        }
    }
    return true;
};

const customEndpointFunctions = {};

const debugId = "endpoints";

function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
        return input;
    }
    if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
}

class EndpointError extends Error {
    constructor(message) {
        super(message);
        this.name = "EndpointError";
    }
}

const booleanEquals = (value1, value2) => value1 === value2;

const getAttrPathList = (path) => {
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts) {
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
                throw new EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
                throw new EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
                pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
        }
        else {
            pathList.push(part);
        }
    }
    return pathList;
};

const getAttr = (value, path) => getAttrPathList(path).reduce((acc, index) => {
    if (typeof acc !== "object") {
        throw new EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
    }
    else if (Array.isArray(acc)) {
        return acc[parseInt(index)];
    }
    return acc[index];
}, value);

const isSet = (value) => value != null;

const not = (value) => !value;

const DEFAULT_PORTS = {
    [types.EndpointURLScheme.HTTP]: 80,
    [types.EndpointURLScheme.HTTPS]: 443,
};
const parseURL = (value) => {
    const whatwgURL = (() => {
        try {
            if (value instanceof URL) {
                return value;
            }
            if (typeof value === "object" && "hostname" in value) {
                const { hostname, port, protocol = "", path = "", query = {} } = value;
                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                url.search = Object.entries(query)
                    .map(([k, v]) => `${k}=${v}`)
                    .join("&");
                return url;
            }
            return new URL(value);
        }
        catch (error) {
            return null;
        }
    })();
    if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
        return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(types.EndpointURLScheme).includes(scheme)) {
        return null;
    }
    const isIp = isIpAddress(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) ||
        (typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`));
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp,
    };
};

const stringEquals = (value1, value2) => value1 === value2;

const substring = (input, start, stop, reverse) => {
    if (start >= stop || input.length < stop) {
        return null;
    }
    if (!reverse) {
        return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
};

const uriEncode = (value) => encodeURIComponent(value).replace(/[!*'()]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);

const endpointFunctions = {
    booleanEquals,
    getAttr,
    isSet,
    isValidHostLabel,
    not,
    parseURL,
    stringEquals,
    substring,
    uriEncode,
};

const evaluateTemplate = (template, options) => {
    const evaluatedTemplateArr = [];
    const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    let currentIndex = 0;
    while (currentIndex < template.length) {
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push(getAttr(templateContext[refName], attrName));
        }
        else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
};

const getReferenceValue = ({ ref }, options) => {
    const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord,
    };
    return referenceRecord[ref];
};

const evaluateExpression = (obj, keyName, options) => {
    if (typeof obj === "string") {
        return evaluateTemplate(obj, options);
    }
    else if (obj["fn"]) {
        return group$2.callFunction(obj, options);
    }
    else if (obj["ref"]) {
        return getReferenceValue(obj, options);
    }
    throw new EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
const callFunction = ({ fn, argv }, options) => {
    const evaluatedArgs = argv.map((arg) => ["boolean", "number"].includes(typeof arg) ? arg : group$2.evaluateExpression(arg, "arg", options));
    const fnSegments = fn.split(".");
    if (fnSegments[0] in customEndpointFunctions && fnSegments[1] != null) {
        return customEndpointFunctions[fnSegments[0]][fnSegments[1]](...evaluatedArgs);
    }
    return endpointFunctions[fn](...evaluatedArgs);
};
const group$2 = {
    evaluateExpression,
    callFunction,
};

const evaluateCondition = ({ assign, ...fnArgs }, options) => {
    if (assign && assign in options.referenceRecord) {
        throw new EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = callFunction(fnArgs, options);
    options.logger?.debug?.(`${debugId} evaluateCondition: ${toDebugString(fnArgs)} = ${toDebugString(value)}`);
    return {
        result: value === "" ? true : !!value,
        ...(assign != null && { toAssign: { name: assign, value } }),
    };
};

const evaluateConditions = (conditions = [], options) => {
    const conditionsReferenceRecord = {};
    for (const condition of conditions) {
        const { result, toAssign } = evaluateCondition(condition, {
            ...options,
            referenceRecord: {
                ...options.referenceRecord,
                ...conditionsReferenceRecord,
            },
        });
        if (!result) {
            return { result };
        }
        if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            options.logger?.debug?.(`${debugId} assign: ${toAssign.name} := ${toDebugString(toAssign.value)}`);
        }
    }
    return { result: true, referenceRecord: conditionsReferenceRecord };
};

const getEndpointHeaders = (headers, options) => Object.entries(headers).reduce((acc, [headerKey, headerVal]) => ({
    ...acc,
    [headerKey]: headerVal.map((headerValEntry) => {
        const processedExpr = evaluateExpression(headerValEntry, "Header value entry", options);
        if (typeof processedExpr !== "string") {
            throw new EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
        }
        return processedExpr;
    }),
}), {});

const getEndpointProperties = (properties, options) => Object.entries(properties).reduce((acc, [propertyKey, propertyVal]) => ({
    ...acc,
    [propertyKey]: group$1.getEndpointProperty(propertyVal, options),
}), {});
const getEndpointProperty = (property, options) => {
    if (Array.isArray(property)) {
        return property.map((propertyEntry) => getEndpointProperty(propertyEntry, options));
    }
    switch (typeof property) {
        case "string":
            return evaluateTemplate(property, options);
        case "object":
            if (property === null) {
                throw new EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return group$1.getEndpointProperties(property, options);
        case "boolean":
            return property;
        default:
            throw new EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
};
const group$1 = {
    getEndpointProperty,
    getEndpointProperties,
};

const getEndpointUrl = (endpointUrl, options) => {
    const expression = evaluateExpression(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
        try {
            return new URL(expression);
        }
        catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
        }
    }
    throw new EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};

const evaluateEndpointRule = (endpointRule, options) => {
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    const endpointRuleOptions = {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    };
    const { url, properties, headers } = endpoint;
    options.logger?.debug?.(`${debugId} Resolving endpoint from template: ${toDebugString(endpoint)}`);
    return {
        ...(headers != undefined && {
            headers: getEndpointHeaders(headers, endpointRuleOptions),
        }),
        ...(properties != undefined && {
            properties: getEndpointProperties(properties, endpointRuleOptions),
        }),
        url: getEndpointUrl(url, endpointRuleOptions),
    };
};

const evaluateErrorRule = (errorRule, options) => {
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    throw new EndpointError(evaluateExpression(error, "Error", {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    }));
};

const evaluateRules = (rules, options) => {
    for (const rule of rules) {
        if (rule.type === "endpoint") {
            const endpointOrUndefined = evaluateEndpointRule(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else if (rule.type === "error") {
            evaluateErrorRule(rule, options);
        }
        else if (rule.type === "tree") {
            const endpointOrUndefined = group.evaluateTreeRule(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        }
        else {
            throw new EndpointError(`Unknown endpoint rule: ${rule}`);
        }
    }
    throw new EndpointError(`Rules evaluation failed`);
};
const evaluateTreeRule = (treeRule, options) => {
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = evaluateConditions(conditions, options);
    if (!result) {
        return;
    }
    return group.evaluateRules(rules, {
        ...options,
        referenceRecord: { ...options.referenceRecord, ...referenceRecord },
    });
};
const group = {
    evaluateRules,
    evaluateTreeRule,
};

const resolveEndpoint = (ruleSetObject, options) => {
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    options.logger?.debug?.(`${debugId} Initial EndpointParams: ${toDebugString(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters)
        .filter(([, v]) => v.default != null)
        .map(([k, v]) => [k, v.default]);
    if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault) {
            endpointParams[paramKey] = endpointParams[paramKey] ?? paramDefaultValue;
        }
    }
    const requiredParams = Object.entries(parameters)
        .filter(([, v]) => v.required)
        .map(([k]) => k);
    for (const requiredParam of requiredParams) {
        if (endpointParams[requiredParam] == null) {
            throw new EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
    }
    const endpoint = evaluateRules(rules, { endpointParams, logger, referenceRecord: {} });
    options.logger?.debug?.(`${debugId} Resolved endpoint: ${toDebugString(endpoint)}`);
    return endpoint;
};

exports.EndpointCache = EndpointCache;
exports.EndpointError = EndpointError;
exports.customEndpointFunctions = customEndpointFunctions;
exports.isIpAddress = isIpAddress;
exports.isValidHostLabel = isValidHostLabel;
exports.resolveEndpoint = resolveEndpoint;


/***/ }),

/***/ 5364:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

exports.fromHex = fromHex;
exports.toHex = toHex;


/***/ }),

/***/ 2390:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var types = __nccwpck_require__(5756);

const getSmithyContext = (context) => context[types.SMITHY_CONTEXT_KEY] || (context[types.SMITHY_CONTEXT_KEY] = {});

const normalizeProvider = (input) => {
    if (typeof input === "function")
        return input;
    const promisified = Promise.resolve(input);
    return () => promisified;
};

exports.getSmithyContext = getSmithyContext;
exports.normalizeProvider = normalizeProvider;


/***/ }),

/***/ 4902:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var serviceErrorClassification = __nccwpck_require__(6375);

exports.RETRY_MODES = void 0;
(function (RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
})(exports.RETRY_MODES || (exports.RETRY_MODES = {}));
const DEFAULT_MAX_ATTEMPTS = 3;
const DEFAULT_RETRY_MODE = exports.RETRY_MODES.STANDARD;

class DefaultRateLimiter {
    static setTimeoutFn = setTimeout;
    beta;
    minCapacity;
    minFillRate;
    scaleConstant;
    smooth;
    currentCapacity = 0;
    enabled = false;
    lastMaxRate = 0;
    measuredTxRate = 0;
    requestCount = 0;
    fillRate;
    lastThrottleTime;
    lastTimestamp = 0;
    lastTxRateBucket;
    maxCapacity;
    timeWindow = 0;
    constructor(options) {
        this.beta = options?.beta ?? 0.7;
        this.minCapacity = options?.minCapacity ?? 1;
        this.minFillRate = options?.minFillRate ?? 0.5;
        this.scaleConstant = options?.scaleConstant ?? 0.4;
        this.smooth = options?.smooth ?? 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1000;
    }
    async getSendToken() {
        return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
        if (!this.enabled) {
            return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
            const delay = ((amount - this.currentCapacity) / this.fillRate) * 1000;
            await new Promise((resolve) => DefaultRateLimiter.setTimeoutFn(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if (serviceErrorClassification.isThrottlingError(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
        }
        else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow((this.lastMaxRate * (1 - this.beta)) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
        this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
        const t = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
        }
    }
    getPrecise(num) {
        return parseFloat(num.toFixed(8));
    }
}

const DEFAULT_RETRY_DELAY_BASE = 100;
const MAXIMUM_RETRY_DELAY = 20 * 1000;
const THROTTLING_RETRY_DELAY_BASE = 500;
const INITIAL_RETRY_TOKENS = 500;
const RETRY_COST = 5;
const TIMEOUT_RETRY_COST = 10;
const NO_RETRY_INCREMENT = 1;
const INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
const REQUEST_HEADER = "amz-sdk-request";

const getDefaultRetryBackoffStrategy = () => {
    let delayBase = DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts) => {
        return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay) => {
        delayBase = delay;
    };
    return {
        computeNextBackoffDelay,
        setDelayBase,
    };
};

const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost, }) => {
    const getRetryCount = () => retryCount;
    const getRetryDelay = () => Math.min(MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = () => retryCost;
    return {
        getRetryCount,
        getRetryDelay,
        getRetryCost,
    };
};

class StandardRetryStrategy {
    maxAttempts;
    mode = exports.RETRY_MODES.STANDARD;
    capacity = INITIAL_RETRY_TOKENS;
    retryBackoffStrategy = getDefaultRetryBackoffStrategy();
    maxAttemptsProvider;
    constructor(maxAttempts) {
        this.maxAttempts = maxAttempts;
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
        return createDefaultRetryToken({
            retryDelay: DEFAULT_RETRY_DELAY_BASE,
            retryCount: 0,
        });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
            const errorType = errorInfo.errorType;
            this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
            const retryDelay = errorInfo.retryAfterHint
                ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType)
                : delayFromErrorType;
            const capacityCost = this.getCapacityCost(errorType);
            this.capacity -= capacityCost;
            return createDefaultRetryToken({
                retryDelay,
                retryCount: token.getRetryCount() + 1,
                retryCost: capacityCost,
            });
        }
        throw new Error("No retry token available");
    }
    recordSuccess(token) {
        this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (token.getRetryCost() ?? NO_RETRY_INCREMENT));
    }
    getCapacity() {
        return this.capacity;
    }
    async getMaxAttempts() {
        try {
            return await this.maxAttemptsProvider();
        }
        catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`);
            return DEFAULT_MAX_ATTEMPTS;
        }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return (attempts < maxAttempts &&
            this.capacity >= this.getCapacityCost(errorInfo.errorType) &&
            this.isRetryableError(errorInfo.errorType));
    }
    getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
    }
    isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
}

class AdaptiveRetryStrategy {
    maxAttemptsProvider;
    rateLimiter;
    standardRetryStrategy;
    mode = exports.RETRY_MODES.ADAPTIVE;
    constructor(maxAttemptsProvider, options) {
        this.maxAttemptsProvider = maxAttemptsProvider;
        const { rateLimiter } = options ?? {};
        this.rateLimiter = rateLimiter ?? new DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
    }
}

class ConfiguredRetryStrategy extends StandardRetryStrategy {
    computeNextBackoffDelay;
    constructor(maxAttempts, computeNextBackoffDelay = DEFAULT_RETRY_DELAY_BASE) {
        super(typeof maxAttempts === "function" ? maxAttempts : async () => maxAttempts);
        if (typeof computeNextBackoffDelay === "number") {
            this.computeNextBackoffDelay = () => computeNextBackoffDelay;
        }
        else {
            this.computeNextBackoffDelay = computeNextBackoffDelay;
        }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        token.getRetryDelay = () => this.computeNextBackoffDelay(token.getRetryCount());
        return token;
    }
}

exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;
exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;
exports.DEFAULT_MAX_ATTEMPTS = DEFAULT_MAX_ATTEMPTS;
exports.DEFAULT_RETRY_DELAY_BASE = DEFAULT_RETRY_DELAY_BASE;
exports.DEFAULT_RETRY_MODE = DEFAULT_RETRY_MODE;
exports.DefaultRateLimiter = DefaultRateLimiter;
exports.INITIAL_RETRY_TOKENS = INITIAL_RETRY_TOKENS;
exports.INVOCATION_ID_HEADER = INVOCATION_ID_HEADER;
exports.MAXIMUM_RETRY_DELAY = MAXIMUM_RETRY_DELAY;
exports.NO_RETRY_INCREMENT = NO_RETRY_INCREMENT;
exports.REQUEST_HEADER = REQUEST_HEADER;
exports.RETRY_COST = RETRY_COST;
exports.StandardRetryStrategy = StandardRetryStrategy;
exports.THROTTLING_RETRY_DELAY_BASE = THROTTLING_RETRY_DELAY_BASE;
exports.TIMEOUT_RETRY_COST = TIMEOUT_RETRY_COST;


/***/ }),

/***/ 9361:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ByteArrayCollector = void 0;
class ByteArrayCollector {
    allocByteArray;
    byteLength = 0;
    byteArrays = [];
    constructor(allocByteArray) {
        this.allocByteArray = allocByteArray;
    }
    push(byteArray) {
        this.byteArrays.push(byteArray);
        this.byteLength += byteArray.byteLength;
    }
    flush() {
        if (this.byteArrays.length === 1) {
            const bytes = this.byteArrays[0];
            this.reset();
            return bytes;
        }
        const aggregation = this.allocByteArray(this.byteLength);
        let cursor = 0;
        for (let i = 0; i < this.byteArrays.length; ++i) {
            const bytes = this.byteArrays[i];
            aggregation.set(bytes, cursor);
            cursor += bytes.byteLength;
        }
        this.reset();
        return aggregation;
    }
    reset() {
        this.byteArrays = [];
        this.byteLength = 0;
    }
}
exports.ByteArrayCollector = ByteArrayCollector;


/***/ }),

/***/ 8551:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChecksumStream = void 0;
const ReadableStreamRef = typeof ReadableStream === "function" ? ReadableStream : function () { };
class ChecksumStream extends ReadableStreamRef {
}
exports.ChecksumStream = ChecksumStream;


/***/ }),

/***/ 6982:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChecksumStream = void 0;
const util_base64_1 = __nccwpck_require__(5600);
const stream_1 = __nccwpck_require__(2781);
class ChecksumStream extends stream_1.Duplex {
    expectedChecksum;
    checksumSourceLocation;
    checksum;
    source;
    base64Encoder;
    constructor({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }) {
        super();
        if (typeof source.pipe === "function") {
            this.source = source;
        }
        else {
            throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
        }
        this.base64Encoder = base64Encoder ?? util_base64_1.toBase64;
        this.expectedChecksum = expectedChecksum;
        this.checksum = checksum;
        this.checksumSourceLocation = checksumSourceLocation;
        this.source.pipe(this);
    }
    _read(size) { }
    _write(chunk, encoding, callback) {
        try {
            this.checksum.update(chunk);
            this.push(chunk);
        }
        catch (e) {
            return callback(e);
        }
        return callback();
    }
    async _final(callback) {
        try {
            const digest = await this.checksum.digest();
            const received = this.base64Encoder(digest);
            if (this.expectedChecksum !== received) {
                return callback(new Error(`Checksum mismatch: expected "${this.expectedChecksum}" but received "${received}"` +
                    ` in response header "${this.checksumSourceLocation}".`));
            }
        }
        catch (e) {
            return callback(e);
        }
        this.push(null);
        return callback();
    }
}
exports.ChecksumStream = ChecksumStream;


/***/ }),

/***/ 2313:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createChecksumStream = void 0;
const util_base64_1 = __nccwpck_require__(5600);
const stream_type_check_1 = __nccwpck_require__(7578);
const ChecksumStream_browser_1 = __nccwpck_require__(8551);
const createChecksumStream = ({ expectedChecksum, checksum, source, checksumSourceLocation, base64Encoder, }) => {
    if (!(0, stream_type_check_1.isReadableStream)(source)) {
        throw new Error(`@smithy/util-stream: unsupported source type ${source?.constructor?.name ?? source} in ChecksumStream.`);
    }
    const encoder = base64Encoder ?? util_base64_1.toBase64;
    if (typeof TransformStream !== "function") {
        throw new Error("@smithy/util-stream: unable to instantiate ChecksumStream because API unavailable: ReadableStream/TransformStream.");
    }
    const transform = new TransformStream({
        start() { },
        async transform(chunk, controller) {
            checksum.update(chunk);
            controller.enqueue(chunk);
        },
        async flush(controller) {
            const digest = await checksum.digest();
            const received = encoder(digest);
            if (expectedChecksum !== received) {
                const error = new Error(`Checksum mismatch: expected "${expectedChecksum}" but received "${received}"` +
                    ` in response header "${checksumSourceLocation}".`);
                controller.error(error);
            }
            else {
                controller.terminate();
            }
        },
    });
    source.pipeThrough(transform);
    const readable = transform.readable;
    Object.setPrototypeOf(readable, ChecksumStream_browser_1.ChecksumStream.prototype);
    return readable;
};
exports.createChecksumStream = createChecksumStream;


/***/ }),

/***/ 1927:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createChecksumStream = createChecksumStream;
const stream_type_check_1 = __nccwpck_require__(7578);
const ChecksumStream_1 = __nccwpck_require__(6982);
const createChecksumStream_browser_1 = __nccwpck_require__(2313);
function createChecksumStream(init) {
    if (typeof ReadableStream === "function" && (0, stream_type_check_1.isReadableStream)(init.source)) {
        return (0, createChecksumStream_browser_1.createChecksumStream)(init);
    }
    return new ChecksumStream_1.ChecksumStream(init);
}


/***/ }),

/***/ 3259:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createBufferedReadable = createBufferedReadable;
const node_stream_1 = __nccwpck_require__(4492);
const ByteArrayCollector_1 = __nccwpck_require__(9361);
const createBufferedReadableStream_1 = __nccwpck_require__(2558);
const stream_type_check_1 = __nccwpck_require__(7578);
function createBufferedReadable(upstream, size, logger) {
    if ((0, stream_type_check_1.isReadableStream)(upstream)) {
        return (0, createBufferedReadableStream_1.createBufferedReadableStream)(upstream, size, logger);
    }
    const downstream = new node_stream_1.Readable({ read() { } });
    let streamBufferingLoggedWarning = false;
    let bytesSeen = 0;
    const buffers = [
        "",
        new ByteArrayCollector_1.ByteArrayCollector((size) => new Uint8Array(size)),
        new ByteArrayCollector_1.ByteArrayCollector((size) => Buffer.from(new Uint8Array(size))),
    ];
    let mode = -1;
    upstream.on("data", (chunk) => {
        const chunkMode = (0, createBufferedReadableStream_1.modeOf)(chunk, true);
        if (mode !== chunkMode) {
            if (mode >= 0) {
                downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
            }
            mode = chunkMode;
        }
        if (mode === -1) {
            downstream.push(chunk);
            return;
        }
        const chunkSize = (0, createBufferedReadableStream_1.sizeOf)(chunk);
        bytesSeen += chunkSize;
        const bufferSize = (0, createBufferedReadableStream_1.sizeOf)(buffers[mode]);
        if (chunkSize >= size && bufferSize === 0) {
            downstream.push(chunk);
        }
        else {
            const newSize = (0, createBufferedReadableStream_1.merge)(buffers, mode, chunk);
            if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
                streamBufferingLoggedWarning = true;
                logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
            }
            if (newSize >= size) {
                downstream.push((0, createBufferedReadableStream_1.flush)(buffers, mode));
            }
        }
    });
    upstream.on("end", () => {
        if (mode !== -1) {
            const remainder = (0, createBufferedReadableStream_1.flush)(buffers, mode);
            if ((0, createBufferedReadableStream_1.sizeOf)(remainder) > 0) {
                downstream.push(remainder);
            }
        }
        downstream.push(null);
    });
    return downstream;
}


/***/ }),

/***/ 2558:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createBufferedReadable = void 0;
exports.createBufferedReadableStream = createBufferedReadableStream;
exports.merge = merge;
exports.flush = flush;
exports.sizeOf = sizeOf;
exports.modeOf = modeOf;
const ByteArrayCollector_1 = __nccwpck_require__(9361);
function createBufferedReadableStream(upstream, size, logger) {
    const reader = upstream.getReader();
    let streamBufferingLoggedWarning = false;
    let bytesSeen = 0;
    const buffers = ["", new ByteArrayCollector_1.ByteArrayCollector((size) => new Uint8Array(size))];
    let mode = -1;
    const pull = async (controller) => {
        const { value, done } = await reader.read();
        const chunk = value;
        if (done) {
            if (mode !== -1) {
                const remainder = flush(buffers, mode);
                if (sizeOf(remainder) > 0) {
                    controller.enqueue(remainder);
                }
            }
            controller.close();
        }
        else {
            const chunkMode = modeOf(chunk, false);
            if (mode !== chunkMode) {
                if (mode >= 0) {
                    controller.enqueue(flush(buffers, mode));
                }
                mode = chunkMode;
            }
            if (mode === -1) {
                controller.enqueue(chunk);
                return;
            }
            const chunkSize = sizeOf(chunk);
            bytesSeen += chunkSize;
            const bufferSize = sizeOf(buffers[mode]);
            if (chunkSize >= size && bufferSize === 0) {
                controller.enqueue(chunk);
            }
            else {
                const newSize = merge(buffers, mode, chunk);
                if (!streamBufferingLoggedWarning && bytesSeen > size * 2) {
                    streamBufferingLoggedWarning = true;
                    logger?.warn(`@smithy/util-stream - stream chunk size ${chunkSize} is below threshold of ${size}, automatically buffering.`);
                }
                if (newSize >= size) {
                    controller.enqueue(flush(buffers, mode));
                }
                else {
                    await pull(controller);
                }
            }
        }
    };
    return new ReadableStream({
        pull,
    });
}
exports.createBufferedReadable = createBufferedReadableStream;
function merge(buffers, mode, chunk) {
    switch (mode) {
        case 0:
            buffers[0] += chunk;
            return sizeOf(buffers[0]);
        case 1:
        case 2:
            buffers[mode].push(chunk);
            return sizeOf(buffers[mode]);
    }
}
function flush(buffers, mode) {
    switch (mode) {
        case 0:
            const s = buffers[0];
            buffers[0] = "";
            return s;
        case 1:
        case 2:
            return buffers[mode].flush();
    }
    throw new Error(`@smithy/util-stream - invalid index ${mode} given to flush()`);
}
function sizeOf(chunk) {
    return chunk?.byteLength ?? chunk?.length ?? 0;
}
function modeOf(chunk, allowBuffer = true) {
    if (allowBuffer && typeof Buffer !== "undefined" && chunk instanceof Buffer) {
        return 2;
    }
    if (chunk instanceof Uint8Array) {
        return 1;
    }
    if (typeof chunk === "string") {
        return 0;
    }
    return -1;
}


/***/ }),

/***/ 1273:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAwsChunkedEncodingStream = void 0;
const getAwsChunkedEncodingStream = (readableStream, options) => {
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        bodyLengthChecker !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const reader = readableStream.getReader();
    return new ReadableStream({
        async pull(controller) {
            const { value, done } = await reader.read();
            if (done) {
                controller.enqueue(`0\r\n`);
                if (checksumRequired) {
                    const checksum = base64Encoder(await digest);
                    controller.enqueue(`${checksumLocationName}:${checksum}\r\n`);
                    controller.enqueue(`\r\n`);
                }
                controller.close();
            }
            else {
                controller.enqueue(`${(bodyLengthChecker(value) || 0).toString(16)}\r\n${value}\r\n`);
            }
        },
    });
};
exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;


/***/ }),

/***/ 3636:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;
const node_stream_1 = __nccwpck_require__(4492);
const getAwsChunkedEncodingStream_browser_1 = __nccwpck_require__(1273);
const stream_type_check_1 = __nccwpck_require__(7578);
function getAwsChunkedEncodingStream(stream, options) {
    const readable = stream;
    const readableStream = stream;
    if ((0, stream_type_check_1.isReadableStream)(readableStream)) {
        return (0, getAwsChunkedEncodingStream_browser_1.getAwsChunkedEncodingStream)(readableStream, options);
    }
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined &&
        checksumAlgorithmFn !== undefined &&
        checksumLocationName !== undefined &&
        streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readable) : undefined;
    const awsChunkedEncodingStream = new node_stream_1.Readable({
        read: () => { },
    });
    readable.on("data", (data) => {
        const length = bodyLengthChecker(data) || 0;
        if (length === 0) {
            return;
        }
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readable.on("end", async () => {
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
}


/***/ }),

/***/ 6711:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.headStream = headStream;
async function headStream(stream, bytes) {
    let byteLengthCounter = 0;
    const chunks = [];
    const reader = stream.getReader();
    let isDone = false;
    while (!isDone) {
        const { done, value } = await reader.read();
        if (value) {
            chunks.push(value);
            byteLengthCounter += value?.byteLength ?? 0;
        }
        if (byteLengthCounter >= bytes) {
            break;
        }
        isDone = done;
    }
    reader.releaseLock();
    const collected = new Uint8Array(Math.min(bytes, byteLengthCounter));
    let offset = 0;
    for (const chunk of chunks) {
        if (chunk.byteLength > collected.byteLength - offset) {
            collected.set(chunk.subarray(0, collected.byteLength - offset), offset);
            break;
        }
        else {
            collected.set(chunk, offset);
        }
        offset += chunk.length;
    }
    return collected;
}


/***/ }),

/***/ 6708:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.headStream = void 0;
const stream_1 = __nccwpck_require__(2781);
const headStream_browser_1 = __nccwpck_require__(6711);
const stream_type_check_1 = __nccwpck_require__(7578);
const headStream = (stream, bytes) => {
    if ((0, stream_type_check_1.isReadableStream)(stream)) {
        return (0, headStream_browser_1.headStream)(stream, bytes);
    }
    return new Promise((resolve, reject) => {
        const collector = new Collector();
        collector.limit = bytes;
        stream.pipe(collector);
        stream.on("error", (err) => {
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function () {
            const bytes = new Uint8Array(Buffer.concat(this.buffers));
            resolve(bytes);
        });
    });
};
exports.headStream = headStream;
class Collector extends stream_1.Writable {
    buffers = [];
    limit = Infinity;
    bytesBuffered = 0;
    _write(chunk, encoding, callback) {
        this.buffers.push(chunk);
        this.bytesBuffered += chunk.byteLength ?? 0;
        if (this.bytesBuffered >= this.limit) {
            const excess = this.bytesBuffered - this.limit;
            const tailBuffer = this.buffers[this.buffers.length - 1];
            this.buffers[this.buffers.length - 1] = tailBuffer.subarray(0, tailBuffer.byteLength - excess);
            this.emit("finish");
        }
        callback();
    }
}


/***/ }),

/***/ 6607:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilBase64 = __nccwpck_require__(5600);
var utilUtf8 = __nccwpck_require__(1895);
var ChecksumStream = __nccwpck_require__(6982);
var createChecksumStream = __nccwpck_require__(1927);
var createBufferedReadable = __nccwpck_require__(3259);
var getAwsChunkedEncodingStream = __nccwpck_require__(3636);
var headStream = __nccwpck_require__(6708);
var sdkStreamMixin = __nccwpck_require__(4515);
var splitStream = __nccwpck_require__(8321);
var streamTypeCheck = __nccwpck_require__(7578);

class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
        if (typeof source === "string") {
            if (encoding === "base64") {
                return Uint8ArrayBlobAdapter.mutate(utilBase64.fromBase64(source));
            }
            return Uint8ArrayBlobAdapter.mutate(utilUtf8.fromUtf8(source));
        }
        throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        if (encoding === "base64") {
            return utilBase64.toBase64(this);
        }
        return utilUtf8.toUtf8(this);
    }
}

Object.defineProperty(exports, "isBlob", ({
    enumerable: true,
    get: function () { return streamTypeCheck.isBlob; }
}));
Object.defineProperty(exports, "isReadableStream", ({
    enumerable: true,
    get: function () { return streamTypeCheck.isReadableStream; }
}));
exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter;
Object.keys(ChecksumStream).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return ChecksumStream[k]; }
    });
});
Object.keys(createChecksumStream).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return createChecksumStream[k]; }
    });
});
Object.keys(createBufferedReadable).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return createBufferedReadable[k]; }
    });
});
Object.keys(getAwsChunkedEncodingStream).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return getAwsChunkedEncodingStream[k]; }
    });
});
Object.keys(headStream).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return headStream[k]; }
    });
});
Object.keys(sdkStreamMixin).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return sdkStreamMixin[k]; }
    });
});
Object.keys(splitStream).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () { return splitStream[k]; }
    });
});


/***/ }),

/***/ 2942:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sdkStreamMixin = void 0;
const fetch_http_handler_1 = __nccwpck_require__(2687);
const util_base64_1 = __nccwpck_require__(5600);
const util_hex_encoding_1 = __nccwpck_require__(5364);
const util_utf8_1 = __nccwpck_require__(1895);
const stream_type_check_1 = __nccwpck_require__(7578);
const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!isBlobInstance(stream) && !(0, stream_type_check_1.isReadableStream)(stream)) {
        const name = stream?.__proto__?.constructor?.name || stream;
        throw new Error(`Unexpected stream implementation, expect Blob or ReadableStream, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, fetch_http_handler_1.streamCollector)(stream);
    };
    const blobToWebStream = (blob) => {
        if (typeof blob.stream !== "function") {
            throw new Error("Cannot transform payload Blob to web stream. Please make sure the Blob.stream() is polyfilled.\n" +
                "If you are using React Native, this API is not yet supported, see: https://react-native.canny.io/feature-requests/p/fetch-streaming-body");
        }
        return blob.stream();
    };
    return Object.assign(stream, {
        transformToByteArray: transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === "base64") {
                return (0, util_base64_1.toBase64)(buf);
            }
            else if (encoding === "hex") {
                return (0, util_hex_encoding_1.toHex)(buf);
            }
            else if (encoding === undefined || encoding === "utf8" || encoding === "utf-8") {
                return (0, util_utf8_1.toUtf8)(buf);
            }
            else if (typeof TextDecoder === "function") {
                return new TextDecoder(encoding).decode(buf);
            }
            else {
                throw new Error("TextDecoder is not available, please make sure polyfill is provided.");
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            transformed = true;
            if (isBlobInstance(stream)) {
                return blobToWebStream(stream);
            }
            else if ((0, stream_type_check_1.isReadableStream)(stream)) {
                return stream;
            }
            else {
                throw new Error(`Cannot transform payload to web stream, got ${stream}`);
            }
        },
    });
};
exports.sdkStreamMixin = sdkStreamMixin;
const isBlobInstance = (stream) => typeof Blob === "function" && stream instanceof Blob;


/***/ }),

/***/ 4515:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sdkStreamMixin = void 0;
const node_http_handler_1 = __nccwpck_require__(258);
const util_buffer_from_1 = __nccwpck_require__(1381);
const stream_1 = __nccwpck_require__(2781);
const sdk_stream_mixin_browser_1 = __nccwpck_require__(2942);
const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream) => {
    if (!(stream instanceof stream_1.Readable)) {
        try {
            return (0, sdk_stream_mixin_browser_1.sdkStreamMixin)(stream);
        }
        catch (e) {
            const name = stream?.__proto__?.constructor?.name || stream;
            throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
        }
    }
    let transformed = false;
    const transformToByteArray = async () => {
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, node_http_handler_1.streamCollector)(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding) => {
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            }
            else {
                const decoder = new TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: () => {
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof stream_1.Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please ensure a polyfill is available.");
            }
            transformed = true;
            return stream_1.Readable.toWeb(stream);
        },
    });
};
exports.sdkStreamMixin = sdkStreamMixin;


/***/ }),

/***/ 4693:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitStream = splitStream;
async function splitStream(stream) {
    if (typeof stream.stream === "function") {
        stream = stream.stream();
    }
    const readableStream = stream;
    return readableStream.tee();
}


/***/ }),

/***/ 8321:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.splitStream = splitStream;
const stream_1 = __nccwpck_require__(2781);
const splitStream_browser_1 = __nccwpck_require__(4693);
const stream_type_check_1 = __nccwpck_require__(7578);
async function splitStream(stream) {
    if ((0, stream_type_check_1.isReadableStream)(stream) || (0, stream_type_check_1.isBlob)(stream)) {
        return (0, splitStream_browser_1.splitStream)(stream);
    }
    const stream1 = new stream_1.PassThrough();
    const stream2 = new stream_1.PassThrough();
    stream.pipe(stream1);
    stream.pipe(stream2);
    return [stream1, stream2];
}


/***/ }),

/***/ 7578:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isBlob = exports.isReadableStream = void 0;
const isReadableStream = (stream) => typeof ReadableStream === "function" &&
    (stream?.constructor?.name === ReadableStream.name || stream instanceof ReadableStream);
exports.isReadableStream = isReadableStream;
const isBlob = (blob) => {
    return typeof Blob === "function" && (blob?.constructor?.name === Blob.name || blob instanceof Blob);
};
exports.isBlob = isBlob;


/***/ }),

/***/ 4197:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const escapeUri = (uri) => encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
const hexEncode = (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`;

const escapeUriPath = (uri) => uri.split("/").map(escapeUri).join("/");

exports.escapeUri = escapeUri;
exports.escapeUriPath = escapeUriPath;


/***/ }),

/***/ 1895:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var utilBufferFrom = __nccwpck_require__(1381);

const fromUtf8 = (input) => {
    const buf = utilBufferFrom.fromString(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};

const toUint8Array = (data) => {
    if (typeof data === "string") {
        return fromUtf8(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};

const toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return utilBufferFrom.fromArrayBuffer(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
};

exports.fromUtf8 = fromUtf8;
exports.toUint8Array = toUint8Array;
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 8011:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const getCircularReplacer = () => {
    const seen = new WeakSet();
    return (key, value) => {
        if (typeof value === "object" && value !== null) {
            if (seen.has(value)) {
                return "[Circular]";
            }
            seen.add(value);
        }
        return value;
    };
};

const sleep = (seconds) => {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
};

const waiterServiceDefaults = {
    minDelay: 2,
    maxDelay: 120,
};
exports.WaiterState = void 0;
(function (WaiterState) {
    WaiterState["ABORTED"] = "ABORTED";
    WaiterState["FAILURE"] = "FAILURE";
    WaiterState["SUCCESS"] = "SUCCESS";
    WaiterState["RETRY"] = "RETRY";
    WaiterState["TIMEOUT"] = "TIMEOUT";
})(exports.WaiterState || (exports.WaiterState = {}));
const checkExceptions = (result) => {
    if (result.state === exports.WaiterState.ABORTED) {
        const abortError = new Error(`${JSON.stringify({
            ...result,
            reason: "Request was aborted",
        }, getCircularReplacer())}`);
        abortError.name = "AbortError";
        throw abortError;
    }
    else if (result.state === exports.WaiterState.TIMEOUT) {
        const timeoutError = new Error(`${JSON.stringify({
            ...result,
            reason: "Waiter has timed out",
        }, getCircularReplacer())}`);
        timeoutError.name = "TimeoutError";
        throw timeoutError;
    }
    else if (result.state !== exports.WaiterState.SUCCESS) {
        throw new Error(`${JSON.stringify(result, getCircularReplacer())}`);
    }
    return result;
};

const exponentialBackoffWithJitter = (minDelay, maxDelay, attemptCeiling, attempt) => {
    if (attempt > attemptCeiling)
        return maxDelay;
    const delay = minDelay * 2 ** (attempt - 1);
    return randomInRange(minDelay, delay);
};
const randomInRange = (min, max) => min + Math.random() * (max - min);
const runPolling = async ({ minDelay, maxDelay, maxWaitTime, abortController, client, abortSignal }, input, acceptorChecks) => {
    const observedResponses = {};
    const { state, reason } = await acceptorChecks(client, input);
    if (reason) {
        const message = createMessageFromResponse(reason);
        observedResponses[message] |= 0;
        observedResponses[message] += 1;
    }
    if (state !== exports.WaiterState.RETRY) {
        return { state, reason, observedResponses };
    }
    let currentAttempt = 1;
    const waitUntil = Date.now() + maxWaitTime * 1000;
    const attemptCeiling = Math.log(maxDelay / minDelay) / Math.log(2) + 1;
    while (true) {
        if (abortController?.signal?.aborted || abortSignal?.aborted) {
            const message = "AbortController signal aborted.";
            observedResponses[message] |= 0;
            observedResponses[message] += 1;
            return { state: exports.WaiterState.ABORTED, observedResponses };
        }
        const delay = exponentialBackoffWithJitter(minDelay, maxDelay, attemptCeiling, currentAttempt);
        if (Date.now() + delay * 1000 > waitUntil) {
            return { state: exports.WaiterState.TIMEOUT, observedResponses };
        }
        await sleep(delay);
        const { state, reason } = await acceptorChecks(client, input);
        if (reason) {
            const message = createMessageFromResponse(reason);
            observedResponses[message] |= 0;
            observedResponses[message] += 1;
        }
        if (state !== exports.WaiterState.RETRY) {
            return { state, reason, observedResponses };
        }
        currentAttempt += 1;
    }
};
const createMessageFromResponse = (reason) => {
    if (reason?.$responseBodyText) {
        return `Deserialization error for body: ${reason.$responseBodyText}`;
    }
    if (reason?.$metadata?.httpStatusCode) {
        if (reason.$response || reason.message) {
            return `${reason.$response.statusCode ?? reason.$metadata.httpStatusCode ?? "Unknown"}: ${reason.message}`;
        }
        return `${reason.$metadata.httpStatusCode}: OK`;
    }
    return String(reason?.message ?? JSON.stringify(reason, getCircularReplacer()) ?? "Unknown");
};

const validateWaiterOptions = (options) => {
    if (options.maxWaitTime <= 0) {
        throw new Error(`WaiterConfiguration.maxWaitTime must be greater than 0`);
    }
    else if (options.minDelay <= 0) {
        throw new Error(`WaiterConfiguration.minDelay must be greater than 0`);
    }
    else if (options.maxDelay <= 0) {
        throw new Error(`WaiterConfiguration.maxDelay must be greater than 0`);
    }
    else if (options.maxWaitTime <= options.minDelay) {
        throw new Error(`WaiterConfiguration.maxWaitTime [${options.maxWaitTime}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
    else if (options.maxDelay < options.minDelay) {
        throw new Error(`WaiterConfiguration.maxDelay [${options.maxDelay}] must be greater than WaiterConfiguration.minDelay [${options.minDelay}] for this waiter`);
    }
};

const abortTimeout = (abortSignal) => {
    let onAbort;
    const promise = new Promise((resolve) => {
        onAbort = () => resolve({ state: exports.WaiterState.ABORTED });
        if (typeof abortSignal.addEventListener === "function") {
            abortSignal.addEventListener("abort", onAbort);
        }
        else {
            abortSignal.onabort = onAbort;
        }
    });
    return {
        clearListener() {
            if (typeof abortSignal.removeEventListener === "function") {
                abortSignal.removeEventListener("abort", onAbort);
            }
        },
        aborted: promise,
    };
};
const createWaiter = async (options, input, acceptorChecks) => {
    const params = {
        ...waiterServiceDefaults,
        ...options,
    };
    validateWaiterOptions(params);
    const exitConditions = [runPolling(params, input, acceptorChecks)];
    const finalize = [];
    if (options.abortSignal) {
        const { aborted, clearListener } = abortTimeout(options.abortSignal);
        finalize.push(clearListener);
        exitConditions.push(aborted);
    }
    if (options.abortController?.signal) {
        const { aborted, clearListener } = abortTimeout(options.abortController.signal);
        finalize.push(clearListener);
        exitConditions.push(aborted);
    }
    return Promise.race(exitConditions).then((result) => {
        for (const fn of finalize) {
            fn();
        }
        return result;
    });
};

exports.checkExceptions = checkExceptions;
exports.createWaiter = createWaiter;
exports.waiterServiceDefaults = waiterServiceDefaults;


/***/ }),

/***/ 3634:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var randomUUID = __nccwpck_require__(7448);

const decimalToHex = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
const v4 = () => {
    if (randomUUID.randomUUID) {
        return randomUUID.randomUUID();
    }
    const rnds = new Uint8Array(16);
    crypto.getRandomValues(rnds);
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;
    return (decimalToHex[rnds[0]] +
        decimalToHex[rnds[1]] +
        decimalToHex[rnds[2]] +
        decimalToHex[rnds[3]] +
        "-" +
        decimalToHex[rnds[4]] +
        decimalToHex[rnds[5]] +
        "-" +
        decimalToHex[rnds[6]] +
        decimalToHex[rnds[7]] +
        "-" +
        decimalToHex[rnds[8]] +
        decimalToHex[rnds[9]] +
        "-" +
        decimalToHex[rnds[10]] +
        decimalToHex[rnds[11]] +
        decimalToHex[rnds[12]] +
        decimalToHex[rnds[13]] +
        decimalToHex[rnds[14]] +
        decimalToHex[rnds[15]]);
};

exports.v4 = v4;


/***/ }),

/***/ 7448:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.randomUUID = void 0;
const tslib_1 = __nccwpck_require__(4351);
const crypto_1 = tslib_1.__importDefault(__nccwpck_require__(6113));
exports.randomUUID = crypto_1.default.randomUUID.bind(crypto_1.default);


/***/ }),

/***/ 4351:
/***/ ((module) => {

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, Symbol, Reflect, Promise, SuppressedError */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __esDecorate;
var __runInitializers;
var __propKey;
var __setFunctionName;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
var __addDisposableResource;
var __disposeResources;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if ( true && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };

    __extends = function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __esDecorate = function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
            var context = {};
            for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
            for (var p in contextIn.access) context.access[p] = contextIn.access[p];
            context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
            var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
            if (kind === "accessor") {
                if (result === void 0) continue;
                if (result === null || typeof result !== "object") throw new TypeError("Object expected");
                if (_ = accept(result.get)) descriptor.get = _;
                if (_ = accept(result.set)) descriptor.set = _;
                if (_ = accept(result.init)) initializers.unshift(_);
            }
            else if (_ = accept(result)) {
                if (kind === "field") initializers.unshift(_);
                else descriptor[key] = _;
            }
        }
        if (target) Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
    };

    __runInitializers = function (thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
            value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
    };

    __propKey = function (x) {
        return typeof x === "symbol" ? x : "".concat(x);
    };

    __setFunctionName = function (f, name, prefix) {
        if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (g && (g = 0, op[0] && (_ = 0)), _) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function(m, o) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    };

    __createBinding = Object.create ? (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() { return m[k]; } };
        }
        Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    });

    __values = function (o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    /** @deprecated */
    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    /** @deprecated */
    __spreadArrays = function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    __spreadArray = function (to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || Array.prototype.slice.call(from));
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
        function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
        function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    var __setModuleDefault = Object.create ? (function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
        o["default"] = v;
    };

    __importStar = function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    };

    __importDefault = function (mod) {
        return (mod && mod.__esModule) ? mod : { "default": mod };
    };

    __classPrivateFieldGet = function (receiver, state, kind, f) {
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };

    __classPrivateFieldSet = function (receiver, state, value, kind, f) {
        if (kind === "m") throw new TypeError("Private method is not writable");
        if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    };

    __classPrivateFieldIn = function (state, receiver) {
        if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
    };

    __addDisposableResource = function (env, value, async) {
        if (value !== null && value !== void 0) {
            if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
            var dispose, inner;
            if (async) {
                if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
                dispose = value[Symbol.asyncDispose];
            }
            if (dispose === void 0) {
                if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
                dispose = value[Symbol.dispose];
                if (async) inner = dispose;
            }
            if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
            if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
            env.stack.push({ value: value, dispose: dispose, async: async });
        }
        else if (async) {
            env.stack.push({ async: true });
        }
        return value;
    };

    var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    __disposeResources = function (env) {
        function fail(e) {
            env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
            env.hasError = true;
        }
        function next() {
            while (env.stack.length) {
                var rec = env.stack.pop();
                try {
                    var result = rec.dispose && rec.dispose.call(rec.value);
                    if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
                }
                catch (e) {
                    fail(e);
                }
            }
            if (env.hasError) throw env.error;
        }
        return next();
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__esDecorate", __esDecorate);
    exporter("__runInitializers", __runInitializers);
    exporter("__propKey", __propKey);
    exporter("__setFunctionName", __setFunctionName);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__spreadArray", __spreadArray);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
    exporter("__classPrivateFieldIn", __classPrivateFieldIn);
    exporter("__addDisposableResource", __addDisposableResource);
    exporter("__disposeResources", __disposeResources);
});


/***/ }),

/***/ 4294:
/***/ ((module, __unused_webpack_exports, __nccwpck_require__) => {

module.exports = __nccwpck_require__(4219);


/***/ }),

/***/ 4219:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


var net = __nccwpck_require__(1808);
var tls = __nccwpck_require__(4404);
var http = __nccwpck_require__(3685);
var https = __nccwpck_require__(5687);
var events = __nccwpck_require__(2361);
var assert = __nccwpck_require__(9491);
var util = __nccwpck_require__(3837);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 5840:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "v1", ({
  enumerable: true,
  get: function () {
    return _v.default;
  }
}));
Object.defineProperty(exports, "v3", ({
  enumerable: true,
  get: function () {
    return _v2.default;
  }
}));
Object.defineProperty(exports, "v4", ({
  enumerable: true,
  get: function () {
    return _v3.default;
  }
}));
Object.defineProperty(exports, "v5", ({
  enumerable: true,
  get: function () {
    return _v4.default;
  }
}));
Object.defineProperty(exports, "NIL", ({
  enumerable: true,
  get: function () {
    return _nil.default;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _version.default;
  }
}));
Object.defineProperty(exports, "validate", ({
  enumerable: true,
  get: function () {
    return _validate.default;
  }
}));
Object.defineProperty(exports, "stringify", ({
  enumerable: true,
  get: function () {
    return _stringify.default;
  }
}));
Object.defineProperty(exports, "parse", ({
  enumerable: true,
  get: function () {
    return _parse.default;
  }
}));

var _v = _interopRequireDefault(__nccwpck_require__(8628));

var _v2 = _interopRequireDefault(__nccwpck_require__(6409));

var _v3 = _interopRequireDefault(__nccwpck_require__(5122));

var _v4 = _interopRequireDefault(__nccwpck_require__(9120));

var _nil = _interopRequireDefault(__nccwpck_require__(5332));

var _version = _interopRequireDefault(__nccwpck_require__(1595));

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

var _parse = _interopRequireDefault(__nccwpck_require__(2746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ 4569:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('md5').update(bytes).digest();
}

var _default = md5;
exports["default"] = _default;

/***/ }),

/***/ 5332:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = '00000000-0000-0000-0000-000000000000';
exports["default"] = _default;

/***/ }),

/***/ 2746:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function parse(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  let v;
  const arr = new Uint8Array(16); // Parse ########-....-....-....-............

  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 0xff;
  arr[2] = v >>> 8 & 0xff;
  arr[3] = v & 0xff; // Parse ........-####-....-....-............

  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 0xff; // Parse ........-....-####-....-............

  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 0xff; // Parse ........-....-....-####-............

  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 0xff; // Parse ........-....-....-....-############
  // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
  arr[11] = v / 0x100000000 & 0xff;
  arr[12] = v >>> 24 & 0xff;
  arr[13] = v >>> 16 & 0xff;
  arr[14] = v >>> 8 & 0xff;
  arr[15] = v & 0xff;
  return arr;
}

var _default = parse;
exports["default"] = _default;

/***/ }),

/***/ 814:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;
var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
exports["default"] = _default;

/***/ }),

/***/ 807:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = rng;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate

let poolPtr = rnds8Pool.length;

function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    _crypto.default.randomFillSync(rnds8Pool);

    poolPtr = 0;
  }

  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

/***/ }),

/***/ 5274:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _crypto = _interopRequireDefault(__nccwpck_require__(6113));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === 'string') {
    bytes = Buffer.from(bytes, 'utf8');
  }

  return _crypto.default.createHash('sha1').update(bytes).digest();
}

var _default = sha1;
exports["default"] = _default;

/***/ }),

/***/ 8950:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).substr(1));
}

function stringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
  // of the following:
  // - One or more input array values don't map to a hex octet (leading to
  // "undefined" in the uuid)
  // - Invalid input values for the RFC `version` or `variant` fields

  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Stringified UUID is invalid');
  }

  return uuid;
}

var _default = stringify;
exports["default"] = _default;

/***/ }),

/***/ 8628:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(807));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;

let _clockseq; // Previous uuid creation time


let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node || _nodeId;
  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189

  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || _rng.default)();

    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }

    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock

  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval


  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  } // Per 4.2.1.2 Throw error if too many uuids are requested


  if (nsecs >= 10000) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

  msecs += 12219292800000; // `time_low`

  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff; // `time_mid`

  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff; // `time_high_and_version`

  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

  b[i++] = clockseq & 0xff; // `node`

  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf || (0, _stringify.default)(b);
}

var _default = v1;
exports["default"] = _default;

/***/ }),

/***/ 6409:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5998));

var _md = _interopRequireDefault(__nccwpck_require__(4569));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v3 = (0, _v.default)('v3', 0x30, _md.default);
var _default = v3;
exports["default"] = _default;

/***/ }),

/***/ 5998:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = _default;
exports.URL = exports.DNS = void 0;

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

var _parse = _interopRequireDefault(__nccwpck_require__(2746));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stringToBytes(str) {
  str = unescape(encodeURIComponent(str)); // UTF8 escape

  const bytes = [];

  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }

  return bytes;
}

const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
exports.DNS = DNS;
const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
exports.URL = URL;

function _default(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    if (typeof value === 'string') {
      value = stringToBytes(value);
    }

    if (typeof namespace === 'string') {
      namespace = (0, _parse.default)(namespace);
    }

    if (namespace.length !== 16) {
      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
    } // Compute hash of namespace and value, Per 4.3
    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
    // hashfunc([...namespace, ... value])`


    let bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 0x0f | version;
    bytes[8] = bytes[8] & 0x3f | 0x80;

    if (buf) {
      offset = offset || 0;

      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }

      return buf;
    }

    return (0, _stringify.default)(bytes);
  } // Function#name is not settable on some platforms (#270)


  try {
    generateUUID.name = name; // eslint-disable-next-line no-empty
  } catch (err) {} // For CommonJS default export support


  generateUUID.DNS = DNS;
  generateUUID.URL = URL;
  return generateUUID;
}

/***/ }),

/***/ 5122:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _rng = _interopRequireDefault(__nccwpck_require__(807));

var _stringify = _interopRequireDefault(__nccwpck_require__(8950));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function v4(options, buf, offset) {
  options = options || {};

  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`


  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return (0, _stringify.default)(rnds);
}

var _default = v4;
exports["default"] = _default;

/***/ }),

/***/ 9120:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _v = _interopRequireDefault(__nccwpck_require__(5998));

var _sha = _interopRequireDefault(__nccwpck_require__(5274));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const v5 = (0, _v.default)('v5', 0x50, _sha.default);
var _default = v5;
exports["default"] = _default;

/***/ }),

/***/ 6900:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _regex = _interopRequireDefault(__nccwpck_require__(814));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports["default"] = _default;

/***/ }),

/***/ 1595:
/***/ ((__unused_webpack_module, exports, __nccwpck_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports["default"] = void 0;

var _validate = _interopRequireDefault(__nccwpck_require__(6900));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports["default"] = _default;

/***/ }),

/***/ 9491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 4300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3292:
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5158:
/***/ ((module) => {

"use strict";
module.exports = require("http2");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2761:
/***/ ((module) => {

"use strict";
module.exports = require("node:async_hooks");

/***/ }),

/***/ 6005:
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ 7561:
/***/ ((module) => {

"use strict";
module.exports = require("node:fs");

/***/ }),

/***/ 3977:
/***/ ((module) => {

"use strict";
module.exports = require("node:fs/promises");

/***/ }),

/***/ 612:
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),

/***/ 9411:
/***/ ((module) => {

"use strict";
module.exports = require("node:path");

/***/ }),

/***/ 4492:
/***/ ((module) => {

"use strict";
module.exports = require("node:stream");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 7282:
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 4404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 4577:
/***/ ((module) => {

(()=>{"use strict";var t={d:(e,n)=>{for(var i in n)t.o(n,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:n[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{XMLBuilder:()=>ft,XMLParser:()=>st,XMLValidator:()=>mt});const n=":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",i=new RegExp("^["+n+"]["+n+"\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$");function s(t,e){const n=[];let i=e.exec(t);for(;i;){const s=[];s.startIndex=e.lastIndex-i[0].length;const r=i.length;for(let t=0;t<r;t++)s.push(i[t]);n.push(s),i=e.exec(t)}return n}const r=function(t){return!(null==i.exec(t))},o={allowBooleanAttributes:!1,unpairedTags:[]};function a(t,e){e=Object.assign({},o,e);const n=[];let i=!1,s=!1;"\ufeff"===t[0]&&(t=t.substr(1));for(let o=0;o<t.length;o++)if("<"===t[o]&&"?"===t[o+1]){if(o+=2,o=u(t,o),o.err)return o}else{if("<"!==t[o]){if(l(t[o]))continue;return x("InvalidChar","char '"+t[o]+"' is not expected.",N(t,o))}{let a=o;if(o++,"!"===t[o]){o=h(t,o);continue}{let d=!1;"/"===t[o]&&(d=!0,o++);let f="";for(;o<t.length&&">"!==t[o]&&" "!==t[o]&&"\t"!==t[o]&&"\n"!==t[o]&&"\r"!==t[o];o++)f+=t[o];if(f=f.trim(),"/"===f[f.length-1]&&(f=f.substring(0,f.length-1),o--),!r(f)){let e;return e=0===f.trim().length?"Invalid space after '<'.":"Tag '"+f+"' is an invalid name.",x("InvalidTag",e,N(t,o))}const p=c(t,o);if(!1===p)return x("InvalidAttr","Attributes for '"+f+"' have open quote.",N(t,o));let b=p.value;if(o=p.index,"/"===b[b.length-1]){const n=o-b.length;b=b.substring(0,b.length-1);const s=g(b,e);if(!0!==s)return x(s.err.code,s.err.msg,N(t,n+s.err.line));i=!0}else if(d){if(!p.tagClosed)return x("InvalidTag","Closing tag '"+f+"' doesn't have proper closing.",N(t,o));if(b.trim().length>0)return x("InvalidTag","Closing tag '"+f+"' can't have attributes or invalid starting.",N(t,a));if(0===n.length)return x("InvalidTag","Closing tag '"+f+"' has not been opened.",N(t,a));{const e=n.pop();if(f!==e.tagName){let n=N(t,e.tagStartPos);return x("InvalidTag","Expected closing tag '"+e.tagName+"' (opened in line "+n.line+", col "+n.col+") instead of closing tag '"+f+"'.",N(t,a))}0==n.length&&(s=!0)}}else{const r=g(b,e);if(!0!==r)return x(r.err.code,r.err.msg,N(t,o-b.length+r.err.line));if(!0===s)return x("InvalidXml","Multiple possible root nodes found.",N(t,o));-1!==e.unpairedTags.indexOf(f)||n.push({tagName:f,tagStartPos:a}),i=!0}for(o++;o<t.length;o++)if("<"===t[o]){if("!"===t[o+1]){o++,o=h(t,o);continue}if("?"!==t[o+1])break;if(o=u(t,++o),o.err)return o}else if("&"===t[o]){const e=m(t,o);if(-1==e)return x("InvalidChar","char '&' is not expected.",N(t,o));o=e}else if(!0===s&&!l(t[o]))return x("InvalidXml","Extra text at the end",N(t,o));"<"===t[o]&&o--}}}return i?1==n.length?x("InvalidTag","Unclosed tag '"+n[0].tagName+"'.",N(t,n[0].tagStartPos)):!(n.length>0)||x("InvalidXml","Invalid '"+JSON.stringify(n.map((t=>t.tagName)),null,4).replace(/\r?\n/g,"")+"' found.",{line:1,col:1}):x("InvalidXml","Start tag expected.",1)}function l(t){return" "===t||"\t"===t||"\n"===t||"\r"===t}function u(t,e){const n=e;for(;e<t.length;e++)if("?"!=t[e]&&" "!=t[e]);else{const i=t.substr(n,e-n);if(e>5&&"xml"===i)return x("InvalidXml","XML declaration allowed only at the start of the document.",N(t,e));if("?"==t[e]&&">"==t[e+1]){e++;break}}return e}function h(t,e){if(t.length>e+5&&"-"===t[e+1]&&"-"===t[e+2]){for(e+=3;e<t.length;e++)if("-"===t[e]&&"-"===t[e+1]&&">"===t[e+2]){e+=2;break}}else if(t.length>e+8&&"D"===t[e+1]&&"O"===t[e+2]&&"C"===t[e+3]&&"T"===t[e+4]&&"Y"===t[e+5]&&"P"===t[e+6]&&"E"===t[e+7]){let n=1;for(e+=8;e<t.length;e++)if("<"===t[e])n++;else if(">"===t[e]&&(n--,0===n))break}else if(t.length>e+9&&"["===t[e+1]&&"C"===t[e+2]&&"D"===t[e+3]&&"A"===t[e+4]&&"T"===t[e+5]&&"A"===t[e+6]&&"["===t[e+7])for(e+=8;e<t.length;e++)if("]"===t[e]&&"]"===t[e+1]&&">"===t[e+2]){e+=2;break}return e}const d='"',f="'";function c(t,e){let n="",i="",s=!1;for(;e<t.length;e++){if(t[e]===d||t[e]===f)""===i?i=t[e]:i!==t[e]||(i="");else if(">"===t[e]&&""===i){s=!0;break}n+=t[e]}return""===i&&{value:n,index:e,tagClosed:s}}const p=new RegExp("(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['\"])(([\\s\\S])*?)\\5)?","g");function g(t,e){const n=s(t,p),i={};for(let t=0;t<n.length;t++){if(0===n[t][1].length)return x("InvalidAttr","Attribute '"+n[t][2]+"' has no space in starting.",E(n[t]));if(void 0!==n[t][3]&&void 0===n[t][4])return x("InvalidAttr","Attribute '"+n[t][2]+"' is without value.",E(n[t]));if(void 0===n[t][3]&&!e.allowBooleanAttributes)return x("InvalidAttr","boolean attribute '"+n[t][2]+"' is not allowed.",E(n[t]));const s=n[t][2];if(!b(s))return x("InvalidAttr","Attribute '"+s+"' is an invalid name.",E(n[t]));if(i.hasOwnProperty(s))return x("InvalidAttr","Attribute '"+s+"' is repeated.",E(n[t]));i[s]=1}return!0}function m(t,e){if(";"===t[++e])return-1;if("#"===t[e])return function(t,e){let n=/\d/;for("x"===t[e]&&(e++,n=/[\da-fA-F]/);e<t.length;e++){if(";"===t[e])return e;if(!t[e].match(n))break}return-1}(t,++e);let n=0;for(;e<t.length;e++,n++)if(!(t[e].match(/\w/)&&n<20)){if(";"===t[e])break;return-1}return e}function x(t,e,n){return{err:{code:t,msg:e,line:n.line||n,col:n.col}}}function b(t){return r(t)}function N(t,e){const n=t.substring(0,e).split(/\r?\n/);return{line:n.length,col:n[n.length-1].length+1}}function E(t){return t.startIndex+t[1].length}const v={preserveOrder:!1,attributeNamePrefix:"@_",attributesGroupName:!1,textNodeName:"#text",ignoreAttributes:!0,removeNSPrefix:!1,allowBooleanAttributes:!1,parseTagValue:!0,parseAttributeValue:!1,trimValues:!0,cdataPropName:!1,numberParseOptions:{hex:!0,leadingZeros:!0,eNotation:!0},tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},stopNodes:[],alwaysCreateTextNode:!1,isArray:()=>!1,commentPropName:!1,unpairedTags:[],processEntities:!0,htmlEntities:!1,ignoreDeclaration:!1,ignorePiTags:!1,transformTagName:!1,transformAttributeName:!1,updateTag:function(t,e,n){return t},captureMetaData:!1};let y;y="function"!=typeof Symbol?"@@xmlMetadata":Symbol("XML Node Metadata");class T{constructor(t){this.tagname=t,this.child=[],this[":@"]={}}add(t,e){"__proto__"===t&&(t="#__proto__"),this.child.push({[t]:e})}addChild(t,e){"__proto__"===t.tagname&&(t.tagname="#__proto__"),t[":@"]&&Object.keys(t[":@"]).length>0?this.child.push({[t.tagname]:t.child,":@":t[":@"]}):this.child.push({[t.tagname]:t.child}),void 0!==e&&(this.child[this.child.length-1][y]={startIndex:e})}static getMetaDataSymbol(){return y}}function w(t,e){const n={};if("O"!==t[e+3]||"C"!==t[e+4]||"T"!==t[e+5]||"Y"!==t[e+6]||"P"!==t[e+7]||"E"!==t[e+8])throw new Error("Invalid Tag instead of DOCTYPE");{e+=9;let i=1,s=!1,r=!1,o="";for(;e<t.length;e++)if("<"!==t[e]||r)if(">"===t[e]){if(r?"-"===t[e-1]&&"-"===t[e-2]&&(r=!1,i--):i--,0===i)break}else"["===t[e]?s=!0:o+=t[e];else{if(s&&C(t,"!ENTITY",e)){let i,s;e+=7,[i,s,e]=O(t,e+1),-1===s.indexOf("&")&&(n[i]={regx:RegExp(`&${i};`,"g"),val:s})}else if(s&&C(t,"!ELEMENT",e)){e+=8;const{index:n}=S(t,e+1);e=n}else if(s&&C(t,"!ATTLIST",e))e+=8;else if(s&&C(t,"!NOTATION",e)){e+=9;const{index:n}=A(t,e+1);e=n}else{if(!C(t,"!--",e))throw new Error("Invalid DOCTYPE");r=!0}i++,o=""}if(0!==i)throw new Error("Unclosed DOCTYPE")}return{entities:n,i:e}}const P=(t,e)=>{for(;e<t.length&&/\s/.test(t[e]);)e++;return e};function O(t,e){e=P(t,e);let n="";for(;e<t.length&&!/\s/.test(t[e])&&'"'!==t[e]&&"'"!==t[e];)n+=t[e],e++;if($(n),e=P(t,e),"SYSTEM"===t.substring(e,e+6).toUpperCase())throw new Error("External entities are not supported");if("%"===t[e])throw new Error("Parameter entities are not supported");let i="";return[e,i]=I(t,e,"entity"),[n,i,--e]}function A(t,e){e=P(t,e);let n="";for(;e<t.length&&!/\s/.test(t[e]);)n+=t[e],e++;$(n),e=P(t,e);const i=t.substring(e,e+6).toUpperCase();if("SYSTEM"!==i&&"PUBLIC"!==i)throw new Error(`Expected SYSTEM or PUBLIC, found "${i}"`);e+=i.length,e=P(t,e);let s=null,r=null;if("PUBLIC"===i)[e,s]=I(t,e,"publicIdentifier"),'"'!==t[e=P(t,e)]&&"'"!==t[e]||([e,r]=I(t,e,"systemIdentifier"));else if("SYSTEM"===i&&([e,r]=I(t,e,"systemIdentifier"),!r))throw new Error("Missing mandatory system identifier for SYSTEM notation");return{notationName:n,publicIdentifier:s,systemIdentifier:r,index:--e}}function I(t,e,n){let i="";const s=t[e];if('"'!==s&&"'"!==s)throw new Error(`Expected quoted string, found "${s}"`);for(e++;e<t.length&&t[e]!==s;)i+=t[e],e++;if(t[e]!==s)throw new Error(`Unterminated ${n} value`);return[++e,i]}function S(t,e){e=P(t,e);let n="";for(;e<t.length&&!/\s/.test(t[e]);)n+=t[e],e++;if(!$(n))throw new Error(`Invalid element name: "${n}"`);let i="";if("E"===t[e=P(t,e)]&&C(t,"MPTY",e))e+=4;else if("A"===t[e]&&C(t,"NY",e))e+=2;else{if("("!==t[e])throw new Error(`Invalid Element Expression, found "${t[e]}"`);for(e++;e<t.length&&")"!==t[e];)i+=t[e],e++;if(")"!==t[e])throw new Error("Unterminated content model")}return{elementName:n,contentModel:i.trim(),index:e}}function C(t,e,n){for(let i=0;i<e.length;i++)if(e[i]!==t[n+i+1])return!1;return!0}function $(t){if(r(t))return t;throw new Error(`Invalid entity name ${t}`)}const j=/^[-+]?0x[a-fA-F0-9]+$/,D=/^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/,V={hex:!0,leadingZeros:!0,decimalPoint:".",eNotation:!0};const M=/^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;function _(t){return"function"==typeof t?t:Array.isArray(t)?e=>{for(const n of t){if("string"==typeof n&&e===n)return!0;if(n instanceof RegExp&&n.test(e))return!0}}:()=>!1}class k{constructor(t){this.options=t,this.currentNode=null,this.tagsNodeStack=[],this.docTypeEntities={},this.lastEntities={apos:{regex:/&(apos|#39|#x27);/g,val:"'"},gt:{regex:/&(gt|#62|#x3E);/g,val:">"},lt:{regex:/&(lt|#60|#x3C);/g,val:"<"},quot:{regex:/&(quot|#34|#x22);/g,val:'"'}},this.ampEntity={regex:/&(amp|#38|#x26);/g,val:"&"},this.htmlEntities={space:{regex:/&(nbsp|#160);/g,val:" "},cent:{regex:/&(cent|#162);/g,val:""},pound:{regex:/&(pound|#163);/g,val:""},yen:{regex:/&(yen|#165);/g,val:""},euro:{regex:/&(euro|#8364);/g,val:""},copyright:{regex:/&(copy|#169);/g,val:""},reg:{regex:/&(reg|#174);/g,val:""},inr:{regex:/&(inr|#8377);/g,val:""},num_dec:{regex:/&#([0-9]{1,7});/g,val:(t,e)=>String.fromCodePoint(Number.parseInt(e,10))},num_hex:{regex:/&#x([0-9a-fA-F]{1,6});/g,val:(t,e)=>String.fromCodePoint(Number.parseInt(e,16))}},this.addExternalEntities=F,this.parseXml=X,this.parseTextData=L,this.resolveNameSpace=B,this.buildAttributesMap=G,this.isItStopNode=Z,this.replaceEntitiesValue=R,this.readStopNodeData=J,this.saveTextToParentTag=q,this.addChild=Y,this.ignoreAttributesFn=_(this.options.ignoreAttributes)}}function F(t){const e=Object.keys(t);for(let n=0;n<e.length;n++){const i=e[n];this.lastEntities[i]={regex:new RegExp("&"+i+";","g"),val:t[i]}}}function L(t,e,n,i,s,r,o){if(void 0!==t&&(this.options.trimValues&&!i&&(t=t.trim()),t.length>0)){o||(t=this.replaceEntitiesValue(t));const i=this.options.tagValueProcessor(e,t,n,s,r);return null==i?t:typeof i!=typeof t||i!==t?i:this.options.trimValues||t.trim()===t?H(t,this.options.parseTagValue,this.options.numberParseOptions):t}}function B(t){if(this.options.removeNSPrefix){const e=t.split(":"),n="/"===t.charAt(0)?"/":"";if("xmlns"===e[0])return"";2===e.length&&(t=n+e[1])}return t}const U=new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?","gm");function G(t,e,n){if(!0!==this.options.ignoreAttributes&&"string"==typeof t){const n=s(t,U),i=n.length,r={};for(let t=0;t<i;t++){const i=this.resolveNameSpace(n[t][1]);if(this.ignoreAttributesFn(i,e))continue;let s=n[t][4],o=this.options.attributeNamePrefix+i;if(i.length)if(this.options.transformAttributeName&&(o=this.options.transformAttributeName(o)),"__proto__"===o&&(o="#__proto__"),void 0!==s){this.options.trimValues&&(s=s.trim()),s=this.replaceEntitiesValue(s);const t=this.options.attributeValueProcessor(i,s,e);r[o]=null==t?s:typeof t!=typeof s||t!==s?t:H(s,this.options.parseAttributeValue,this.options.numberParseOptions)}else this.options.allowBooleanAttributes&&(r[o]=!0)}if(!Object.keys(r).length)return;if(this.options.attributesGroupName){const t={};return t[this.options.attributesGroupName]=r,t}return r}}const X=function(t){t=t.replace(/\r\n?/g,"\n");const e=new T("!xml");let n=e,i="",s="";for(let r=0;r<t.length;r++)if("<"===t[r])if("/"===t[r+1]){const e=W(t,">",r,"Closing Tag is not closed.");let o=t.substring(r+2,e).trim();if(this.options.removeNSPrefix){const t=o.indexOf(":");-1!==t&&(o=o.substr(t+1))}this.options.transformTagName&&(o=this.options.transformTagName(o)),n&&(i=this.saveTextToParentTag(i,n,s));const a=s.substring(s.lastIndexOf(".")+1);if(o&&-1!==this.options.unpairedTags.indexOf(o))throw new Error(`Unpaired tag can not be used as closing tag: </${o}>`);let l=0;a&&-1!==this.options.unpairedTags.indexOf(a)?(l=s.lastIndexOf(".",s.lastIndexOf(".")-1),this.tagsNodeStack.pop()):l=s.lastIndexOf("."),s=s.substring(0,l),n=this.tagsNodeStack.pop(),i="",r=e}else if("?"===t[r+1]){let e=z(t,r,!1,"?>");if(!e)throw new Error("Pi Tag is not closed.");if(i=this.saveTextToParentTag(i,n,s),this.options.ignoreDeclaration&&"?xml"===e.tagName||this.options.ignorePiTags);else{const t=new T(e.tagName);t.add(this.options.textNodeName,""),e.tagName!==e.tagExp&&e.attrExpPresent&&(t[":@"]=this.buildAttributesMap(e.tagExp,s,e.tagName)),this.addChild(n,t,s,r)}r=e.closeIndex+1}else if("!--"===t.substr(r+1,3)){const e=W(t,"--\x3e",r+4,"Comment is not closed.");if(this.options.commentPropName){const o=t.substring(r+4,e-2);i=this.saveTextToParentTag(i,n,s),n.add(this.options.commentPropName,[{[this.options.textNodeName]:o}])}r=e}else if("!D"===t.substr(r+1,2)){const e=w(t,r);this.docTypeEntities=e.entities,r=e.i}else if("!["===t.substr(r+1,2)){const e=W(t,"]]>",r,"CDATA is not closed.")-2,o=t.substring(r+9,e);i=this.saveTextToParentTag(i,n,s);let a=this.parseTextData(o,n.tagname,s,!0,!1,!0,!0);null==a&&(a=""),this.options.cdataPropName?n.add(this.options.cdataPropName,[{[this.options.textNodeName]:o}]):n.add(this.options.textNodeName,a),r=e+2}else{let o=z(t,r,this.options.removeNSPrefix),a=o.tagName;const l=o.rawTagName;let u=o.tagExp,h=o.attrExpPresent,d=o.closeIndex;this.options.transformTagName&&(a=this.options.transformTagName(a)),n&&i&&"!xml"!==n.tagname&&(i=this.saveTextToParentTag(i,n,s,!1));const f=n;f&&-1!==this.options.unpairedTags.indexOf(f.tagname)&&(n=this.tagsNodeStack.pop(),s=s.substring(0,s.lastIndexOf("."))),a!==e.tagname&&(s+=s?"."+a:a);const c=r;if(this.isItStopNode(this.options.stopNodes,s,a)){let e="";if(u.length>0&&u.lastIndexOf("/")===u.length-1)"/"===a[a.length-1]?(a=a.substr(0,a.length-1),s=s.substr(0,s.length-1),u=a):u=u.substr(0,u.length-1),r=o.closeIndex;else if(-1!==this.options.unpairedTags.indexOf(a))r=o.closeIndex;else{const n=this.readStopNodeData(t,l,d+1);if(!n)throw new Error(`Unexpected end of ${l}`);r=n.i,e=n.tagContent}const i=new T(a);a!==u&&h&&(i[":@"]=this.buildAttributesMap(u,s,a)),e&&(e=this.parseTextData(e,a,s,!0,h,!0,!0)),s=s.substr(0,s.lastIndexOf(".")),i.add(this.options.textNodeName,e),this.addChild(n,i,s,c)}else{if(u.length>0&&u.lastIndexOf("/")===u.length-1){"/"===a[a.length-1]?(a=a.substr(0,a.length-1),s=s.substr(0,s.length-1),u=a):u=u.substr(0,u.length-1),this.options.transformTagName&&(a=this.options.transformTagName(a));const t=new T(a);a!==u&&h&&(t[":@"]=this.buildAttributesMap(u,s,a)),this.addChild(n,t,s,c),s=s.substr(0,s.lastIndexOf("."))}else{const t=new T(a);this.tagsNodeStack.push(n),a!==u&&h&&(t[":@"]=this.buildAttributesMap(u,s,a)),this.addChild(n,t,s,c),n=t}i="",r=d}}else i+=t[r];return e.child};function Y(t,e,n,i){this.options.captureMetaData||(i=void 0);const s=this.options.updateTag(e.tagname,n,e[":@"]);!1===s||("string"==typeof s?(e.tagname=s,t.addChild(e,i)):t.addChild(e,i))}const R=function(t){if(this.options.processEntities){for(let e in this.docTypeEntities){const n=this.docTypeEntities[e];t=t.replace(n.regx,n.val)}for(let e in this.lastEntities){const n=this.lastEntities[e];t=t.replace(n.regex,n.val)}if(this.options.htmlEntities)for(let e in this.htmlEntities){const n=this.htmlEntities[e];t=t.replace(n.regex,n.val)}t=t.replace(this.ampEntity.regex,this.ampEntity.val)}return t};function q(t,e,n,i){return t&&(void 0===i&&(i=0===e.child.length),void 0!==(t=this.parseTextData(t,e.tagname,n,!1,!!e[":@"]&&0!==Object.keys(e[":@"]).length,i))&&""!==t&&e.add(this.options.textNodeName,t),t=""),t}function Z(t,e,n){const i="*."+n;for(const n in t){const s=t[n];if(i===s||e===s)return!0}return!1}function W(t,e,n,i){const s=t.indexOf(e,n);if(-1===s)throw new Error(i);return s+e.length-1}function z(t,e,n,i=">"){const s=function(t,e,n=">"){let i,s="";for(let r=e;r<t.length;r++){let e=t[r];if(i)e===i&&(i="");else if('"'===e||"'"===e)i=e;else if(e===n[0]){if(!n[1])return{data:s,index:r};if(t[r+1]===n[1])return{data:s,index:r}}else"\t"===e&&(e=" ");s+=e}}(t,e+1,i);if(!s)return;let r=s.data;const o=s.index,a=r.search(/\s/);let l=r,u=!0;-1!==a&&(l=r.substring(0,a),r=r.substring(a+1).trimStart());const h=l;if(n){const t=l.indexOf(":");-1!==t&&(l=l.substr(t+1),u=l!==s.data.substr(t+1))}return{tagName:l,tagExp:r,closeIndex:o,attrExpPresent:u,rawTagName:h}}function J(t,e,n){const i=n;let s=1;for(;n<t.length;n++)if("<"===t[n])if("/"===t[n+1]){const r=W(t,">",n,`${e} is not closed`);if(t.substring(n+2,r).trim()===e&&(s--,0===s))return{tagContent:t.substring(i,n),i:r};n=r}else if("?"===t[n+1])n=W(t,"?>",n+1,"StopNode is not closed.");else if("!--"===t.substr(n+1,3))n=W(t,"--\x3e",n+3,"StopNode is not closed.");else if("!["===t.substr(n+1,2))n=W(t,"]]>",n,"StopNode is not closed.")-2;else{const i=z(t,n,">");i&&((i&&i.tagName)===e&&"/"!==i.tagExp[i.tagExp.length-1]&&s++,n=i.closeIndex)}}function H(t,e,n){if(e&&"string"==typeof t){const e=t.trim();return"true"===e||"false"!==e&&function(t,e={}){if(e=Object.assign({},V,e),!t||"string"!=typeof t)return t;let n=t.trim();if(void 0!==e.skipLike&&e.skipLike.test(n))return t;if("0"===t)return 0;if(e.hex&&j.test(n))return function(t){if(parseInt)return parseInt(t,16);if(Number.parseInt)return Number.parseInt(t,16);if(window&&window.parseInt)return window.parseInt(t,16);throw new Error("parseInt, Number.parseInt, window.parseInt are not supported")}(n);if(-1!==n.search(/.+[eE].+/))return function(t,e,n){if(!n.eNotation)return t;const i=e.match(M);if(i){let s=i[1]||"";const r=-1===i[3].indexOf("e")?"E":"e",o=i[2],a=s?t[o.length+1]===r:t[o.length]===r;return o.length>1&&a?t:1!==o.length||!i[3].startsWith(`.${r}`)&&i[3][0]!==r?n.leadingZeros&&!a?(e=(i[1]||"")+i[3],Number(e)):t:Number(e)}return t}(t,n,e);{const s=D.exec(n);if(s){const r=s[1]||"",o=s[2];let a=(i=s[3])&&-1!==i.indexOf(".")?("."===(i=i.replace(/0+$/,""))?i="0":"."===i[0]?i="0"+i:"."===i[i.length-1]&&(i=i.substring(0,i.length-1)),i):i;const l=r?"."===t[o.length+1]:"."===t[o.length];if(!e.leadingZeros&&(o.length>1||1===o.length&&!l))return t;{const i=Number(n),s=String(i);if(0===i||-0===i)return i;if(-1!==s.search(/[eE]/))return e.eNotation?i:t;if(-1!==n.indexOf("."))return"0"===s||s===a||s===`${r}${a}`?i:t;let l=o?a:n;return o?l===s||r+l===s?i:t:l===s||l===r+s?i:t}}return t}var i}(t,n)}return void 0!==t?t:""}const K=T.getMetaDataSymbol();function Q(t,e){return tt(t,e)}function tt(t,e,n){let i;const s={};for(let r=0;r<t.length;r++){const o=t[r],a=et(o);let l="";if(l=void 0===n?a:n+"."+a,a===e.textNodeName)void 0===i?i=o[a]:i+=""+o[a];else{if(void 0===a)continue;if(o[a]){let t=tt(o[a],e,l);const n=it(t,e);void 0!==o[K]&&(t[K]=o[K]),o[":@"]?nt(t,o[":@"],l,e):1!==Object.keys(t).length||void 0===t[e.textNodeName]||e.alwaysCreateTextNode?0===Object.keys(t).length&&(e.alwaysCreateTextNode?t[e.textNodeName]="":t=""):t=t[e.textNodeName],void 0!==s[a]&&s.hasOwnProperty(a)?(Array.isArray(s[a])||(s[a]=[s[a]]),s[a].push(t)):e.isArray(a,l,n)?s[a]=[t]:s[a]=t}}}return"string"==typeof i?i.length>0&&(s[e.textNodeName]=i):void 0!==i&&(s[e.textNodeName]=i),s}function et(t){const e=Object.keys(t);for(let t=0;t<e.length;t++){const n=e[t];if(":@"!==n)return n}}function nt(t,e,n,i){if(e){const s=Object.keys(e),r=s.length;for(let o=0;o<r;o++){const r=s[o];i.isArray(r,n+"."+r,!0,!0)?t[r]=[e[r]]:t[r]=e[r]}}}function it(t,e){const{textNodeName:n}=e,i=Object.keys(t).length;return 0===i||!(1!==i||!t[n]&&"boolean"!=typeof t[n]&&0!==t[n])}class st{constructor(t){this.externalEntities={},this.options=function(t){return Object.assign({},v,t)}(t)}parse(t,e){if("string"==typeof t);else{if(!t.toString)throw new Error("XML data is accepted in String or Bytes[] form.");t=t.toString()}if(e){!0===e&&(e={});const n=a(t,e);if(!0!==n)throw Error(`${n.err.msg}:${n.err.line}:${n.err.col}`)}const n=new k(this.options);n.addExternalEntities(this.externalEntities);const i=n.parseXml(t);return this.options.preserveOrder||void 0===i?i:Q(i,this.options)}addEntity(t,e){if(-1!==e.indexOf("&"))throw new Error("Entity value can't have '&'");if(-1!==t.indexOf("&")||-1!==t.indexOf(";"))throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");if("&"===e)throw new Error("An entity with value '&' is not permitted");this.externalEntities[t]=e}static getMetaDataSymbol(){return T.getMetaDataSymbol()}}function rt(t,e){let n="";return e.format&&e.indentBy.length>0&&(n="\n"),ot(t,e,"",n)}function ot(t,e,n,i){let s="",r=!1;for(let o=0;o<t.length;o++){const a=t[o],l=at(a);if(void 0===l)continue;let u="";if(u=0===n.length?l:`${n}.${l}`,l===e.textNodeName){let t=a[l];ut(u,e)||(t=e.tagValueProcessor(l,t),t=ht(t,e)),r&&(s+=i),s+=t,r=!1;continue}if(l===e.cdataPropName){r&&(s+=i),s+=`<![CDATA[${a[l][0][e.textNodeName]}]]>`,r=!1;continue}if(l===e.commentPropName){s+=i+`\x3c!--${a[l][0][e.textNodeName]}--\x3e`,r=!0;continue}if("?"===l[0]){const t=lt(a[":@"],e),n="?xml"===l?"":i;let o=a[l][0][e.textNodeName];o=0!==o.length?" "+o:"",s+=n+`<${l}${o}${t}?>`,r=!0;continue}let h=i;""!==h&&(h+=e.indentBy);const d=i+`<${l}${lt(a[":@"],e)}`,f=ot(a[l],e,u,h);-1!==e.unpairedTags.indexOf(l)?e.suppressUnpairedNode?s+=d+">":s+=d+"/>":f&&0!==f.length||!e.suppressEmptyNode?f&&f.endsWith(">")?s+=d+`>${f}${i}</${l}>`:(s+=d+">",f&&""!==i&&(f.includes("/>")||f.includes("</"))?s+=i+e.indentBy+f+i:s+=f,s+=`</${l}>`):s+=d+"/>",r=!0}return s}function at(t){const e=Object.keys(t);for(let n=0;n<e.length;n++){const i=e[n];if(t.hasOwnProperty(i)&&":@"!==i)return i}}function lt(t,e){let n="";if(t&&!e.ignoreAttributes)for(let i in t){if(!t.hasOwnProperty(i))continue;let s=e.attributeValueProcessor(i,t[i]);s=ht(s,e),!0===s&&e.suppressBooleanAttributes?n+=` ${i.substr(e.attributeNamePrefix.length)}`:n+=` ${i.substr(e.attributeNamePrefix.length)}="${s}"`}return n}function ut(t,e){let n=(t=t.substr(0,t.length-e.textNodeName.length-1)).substr(t.lastIndexOf(".")+1);for(let i in e.stopNodes)if(e.stopNodes[i]===t||e.stopNodes[i]==="*."+n)return!0;return!1}function ht(t,e){if(t&&t.length>0&&e.processEntities)for(let n=0;n<e.entities.length;n++){const i=e.entities[n];t=t.replace(i.regex,i.val)}return t}const dt={attributeNamePrefix:"@_",attributesGroupName:!1,textNodeName:"#text",ignoreAttributes:!0,cdataPropName:!1,format:!1,indentBy:"  ",suppressEmptyNode:!1,suppressUnpairedNode:!0,suppressBooleanAttributes:!0,tagValueProcessor:function(t,e){return e},attributeValueProcessor:function(t,e){return e},preserveOrder:!1,commentPropName:!1,unpairedTags:[],entities:[{regex:new RegExp("&","g"),val:"&amp;"},{regex:new RegExp(">","g"),val:"&gt;"},{regex:new RegExp("<","g"),val:"&lt;"},{regex:new RegExp("'","g"),val:"&apos;"},{regex:new RegExp('"',"g"),val:"&quot;"}],processEntities:!0,stopNodes:[],oneListGroup:!1};function ft(t){this.options=Object.assign({},dt,t),!0===this.options.ignoreAttributes||this.options.attributesGroupName?this.isAttribute=function(){return!1}:(this.ignoreAttributesFn=_(this.options.ignoreAttributes),this.attrPrefixLen=this.options.attributeNamePrefix.length,this.isAttribute=gt),this.processTextOrObjNode=ct,this.options.format?(this.indentate=pt,this.tagEndChar=">\n",this.newLine="\n"):(this.indentate=function(){return""},this.tagEndChar=">",this.newLine="")}function ct(t,e,n,i){const s=this.j2x(t,n+1,i.concat(e));return void 0!==t[this.options.textNodeName]&&1===Object.keys(t).length?this.buildTextValNode(t[this.options.textNodeName],e,s.attrStr,n):this.buildObjectNode(s.val,e,s.attrStr,n)}function pt(t){return this.options.indentBy.repeat(t)}function gt(t){return!(!t.startsWith(this.options.attributeNamePrefix)||t===this.options.textNodeName)&&t.substr(this.attrPrefixLen)}ft.prototype.build=function(t){return this.options.preserveOrder?rt(t,this.options):(Array.isArray(t)&&this.options.arrayNodeName&&this.options.arrayNodeName.length>1&&(t={[this.options.arrayNodeName]:t}),this.j2x(t,0,[]).val)},ft.prototype.j2x=function(t,e,n){let i="",s="";const r=n.join(".");for(let o in t)if(Object.prototype.hasOwnProperty.call(t,o))if(void 0===t[o])this.isAttribute(o)&&(s+="");else if(null===t[o])this.isAttribute(o)||o===this.options.cdataPropName?s+="":"?"===o[0]?s+=this.indentate(e)+"<"+o+"?"+this.tagEndChar:s+=this.indentate(e)+"<"+o+"/"+this.tagEndChar;else if(t[o]instanceof Date)s+=this.buildTextValNode(t[o],o,"",e);else if("object"!=typeof t[o]){const n=this.isAttribute(o);if(n&&!this.ignoreAttributesFn(n,r))i+=this.buildAttrPairStr(n,""+t[o]);else if(!n)if(o===this.options.textNodeName){let e=this.options.tagValueProcessor(o,""+t[o]);s+=this.replaceEntitiesValue(e)}else s+=this.buildTextValNode(t[o],o,"",e)}else if(Array.isArray(t[o])){const i=t[o].length;let r="",a="";for(let l=0;l<i;l++){const i=t[o][l];if(void 0===i);else if(null===i)"?"===o[0]?s+=this.indentate(e)+"<"+o+"?"+this.tagEndChar:s+=this.indentate(e)+"<"+o+"/"+this.tagEndChar;else if("object"==typeof i)if(this.options.oneListGroup){const t=this.j2x(i,e+1,n.concat(o));r+=t.val,this.options.attributesGroupName&&i.hasOwnProperty(this.options.attributesGroupName)&&(a+=t.attrStr)}else r+=this.processTextOrObjNode(i,o,e,n);else if(this.options.oneListGroup){let t=this.options.tagValueProcessor(o,i);t=this.replaceEntitiesValue(t),r+=t}else r+=this.buildTextValNode(i,o,"",e)}this.options.oneListGroup&&(r=this.buildObjectNode(r,o,a,e)),s+=r}else if(this.options.attributesGroupName&&o===this.options.attributesGroupName){const e=Object.keys(t[o]),n=e.length;for(let s=0;s<n;s++)i+=this.buildAttrPairStr(e[s],""+t[o][e[s]])}else s+=this.processTextOrObjNode(t[o],o,e,n);return{attrStr:i,val:s}},ft.prototype.buildAttrPairStr=function(t,e){return e=this.options.attributeValueProcessor(t,""+e),e=this.replaceEntitiesValue(e),this.options.suppressBooleanAttributes&&"true"===e?" "+t:" "+t+'="'+e+'"'},ft.prototype.buildObjectNode=function(t,e,n,i){if(""===t)return"?"===e[0]?this.indentate(i)+"<"+e+n+"?"+this.tagEndChar:this.indentate(i)+"<"+e+n+this.closeTag(e)+this.tagEndChar;{let s="</"+e+this.tagEndChar,r="";return"?"===e[0]&&(r="?",s=""),!n&&""!==n||-1!==t.indexOf("<")?!1!==this.options.commentPropName&&e===this.options.commentPropName&&0===r.length?this.indentate(i)+`\x3c!--${t}--\x3e`+this.newLine:this.indentate(i)+"<"+e+n+r+this.tagEndChar+t+this.indentate(i)+s:this.indentate(i)+"<"+e+n+r+">"+t+s}},ft.prototype.closeTag=function(t){let e="";return-1!==this.options.unpairedTags.indexOf(t)?this.options.suppressUnpairedNode||(e="/"):e=this.options.suppressEmptyNode?"/":`></${t}`,e},ft.prototype.buildTextValNode=function(t,e,n,i){if(!1!==this.options.cdataPropName&&e===this.options.cdataPropName)return this.indentate(i)+`<![CDATA[${t}]]>`+this.newLine;if(!1!==this.options.commentPropName&&e===this.options.commentPropName)return this.indentate(i)+`\x3c!--${t}--\x3e`+this.newLine;if("?"===e[0])return this.indentate(i)+"<"+e+n+"?"+this.tagEndChar;{let s=this.options.tagValueProcessor(e,t);return s=this.replaceEntitiesValue(s),""===s?this.indentate(i)+"<"+e+n+this.closeTag(e)+this.tagEndChar:this.indentate(i)+"<"+e+n+">"+s+"</"+e+this.tagEndChar}},ft.prototype.replaceEntitiesValue=function(t){if(t&&t.length>0&&this.options.processEntities)for(let e=0;e<this.options.entities.length;e++){const n=this.options.entities[e];t=t.replace(n.regex,n.val)}return t};const mt={validate:a};module.exports=e})();

/***/ }),

/***/ 466:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-ssm","description":"AWS SDK for JavaScript Ssm Client for Node.js, Browser and React Native","version":"3.972.0","scripts":{"build":"concurrently \'yarn:build:types\' \'yarn:build:es\' && yarn build:cjs","build:cjs":"node ../../scripts/compilation/inline client-ssm","build:es":"tsc -p tsconfig.es.json","build:include:deps":"yarn g:turbo run build -F=\\"$npm_package_name\\"","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"premove dist-cjs dist-es dist-types tsconfig.cjs.tsbuildinfo tsconfig.es.tsbuildinfo tsconfig.types.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo ssm","test:e2e":"yarn g:vitest run -c vitest.config.e2e.mts --mode development","test:e2e:watch":"yarn g:vitest watch -c vitest.config.e2e.mts","test:index":"tsc --noEmit ./test/index-types.ts && node ./test/index-objects.spec.mjs"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"5.2.0","@aws-crypto/sha256-js":"5.2.0","@aws-sdk/core":"3.972.0","@aws-sdk/credential-provider-node":"3.972.0","@aws-sdk/middleware-host-header":"3.972.0","@aws-sdk/middleware-logger":"3.972.0","@aws-sdk/middleware-recursion-detection":"3.972.0","@aws-sdk/middleware-user-agent":"3.972.0","@aws-sdk/region-config-resolver":"3.972.0","@aws-sdk/types":"3.972.0","@aws-sdk/util-endpoints":"3.972.0","@aws-sdk/util-user-agent-browser":"3.972.0","@aws-sdk/util-user-agent-node":"3.972.0","@smithy/config-resolver":"^4.4.6","@smithy/core":"^3.20.6","@smithy/fetch-http-handler":"^5.3.9","@smithy/hash-node":"^4.2.8","@smithy/invalid-dependency":"^4.2.8","@smithy/middleware-content-length":"^4.2.8","@smithy/middleware-endpoint":"^4.4.7","@smithy/middleware-retry":"^4.4.23","@smithy/middleware-serde":"^4.2.9","@smithy/middleware-stack":"^4.2.8","@smithy/node-config-provider":"^4.3.8","@smithy/node-http-handler":"^4.4.8","@smithy/protocol-http":"^5.3.8","@smithy/smithy-client":"^4.10.8","@smithy/types":"^4.12.0","@smithy/url-parser":"^4.2.8","@smithy/util-base64":"^4.3.0","@smithy/util-body-length-browser":"^4.2.0","@smithy/util-body-length-node":"^4.2.1","@smithy/util-defaults-mode-browser":"^4.3.22","@smithy/util-defaults-mode-node":"^4.2.25","@smithy/util-endpoints":"^3.2.8","@smithy/util-middleware":"^4.2.8","@smithy/util-retry":"^4.2.8","@smithy/util-utf8":"^4.2.0","@smithy/util-waiter":"^4.2.8","tslib":"^2.6.2"},"devDependencies":{"@tsconfig/node20":"20.1.8","@types/node":"^20.14.8","concurrently":"7.0.0","downlevel-dts":"0.10.1","premove":"4.0.0","typescript":"~5.8.3"},"engines":{"node":">=20.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-ssm","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-ssm"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nccwpck_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nccwpck_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nccwpck_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__nccwpck_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__nccwpck_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__nccwpck_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__nccwpck_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__nccwpck_require__.o(definition, key) && !__nccwpck_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__nccwpck_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__nccwpck_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__nccwpck_require__.f).reduce((promises, key) => {
/******/ 				__nccwpck_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__nccwpck_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".index.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__nccwpck_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__nccwpck_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	if (typeof __nccwpck_require__ !== 'undefined') __nccwpck_require__.ab = __dirname + "/";
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			179: 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__nccwpck_require__.o(moreModules, moduleId)) {
/******/ 					__nccwpck_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__nccwpck_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__nccwpck_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __nccwpck_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __nccwpck_require__(3109);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=index.js.map